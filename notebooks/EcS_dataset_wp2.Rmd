---
title: "Edad con Salud WP2 dataset harmonization process"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), 'First created on 30 Sept. 2022. Updated on %d de %B de %Y')`"
output:
  html_notebook: 
  toc: yes
  toc_float: yes
institute: CCOMS, Universidad Autónoma de Madrid
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 80
---
# Step 0. Preparation

## Overview

Here, I prepare the full Edad con Salud (2 assessment waves) to be uploaded to 
OPAL, as part of RESPOND WP2 IPD meta-analysis. I will follow the 
[OPAL handbook for WP2](https://drzmainz.sharepoint.com/:w:/r/sites/obiba-wp2/Shared%20Documents/harmonisation/data%20upload%20preparation/handbook_datauploadprep.docx?d=w15b8e9fe38734104a507dcedc3af3d49&csf=1&web=1&e=6Hu6Lm)

1. Merge all the assessment waves in a dataset with a number of rows equal to 
wavesBYparticipants. 
2. Create as many new variables as needed, as per the OPAL handbook for WP2.
3. Transform variables that require transformation outside the OBIBA environment
(sensitive data).
4. Remove all columns that are not included in the RESPOND WP2 codebook. 
5. Recode missing data
5. Create a new hashed ID and remove the old one. 
6. Export a .csv file to be uploaded to OPAL.

## Required libraries

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
library(lubridate)
library(naniar)
library(stringi)
library(readstata13)
library(readxl)
library(ecs.data)
```

## Constants on variable harmonization

_Coding of missing values:_
 - -991 specifies a variable has not been assessed in general (e.g., at this
 point of data collection), so it is missing by design. 
 
 - -992 specifies 'refused to answer' NAs
 
 - -993 specifies missings (default) from data collections that
actually took place (eg, this exact questionnaire had been assessed at this
timepoint, but the participant did not answer for whatever reason).

```{r constants}

MISSING_DESIGN <- -991
REFUSED_ANSWER <- -992 
NON_RESPONSE <- -993

BASELINE_FILEPATH <- file.path(read_ecs_folder("DB"),
                               "Ola_3/Cohorte_2019/rawdata_c2019w1.dta")
COVID_FILEPATH <- file.path(read_ecs_folder("DB"), 
                        "Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")
```

## Data importation

Data is extracted from the OneDrive folders `Bases de datos maestras`. For
RESPOND WP2, the used folders are `Cohort 2019`and `COVID Substudy`. Files are
in .dta format, which is a double format. It contains:

  - the variable type (class)
  - the label (label, part of the metadata)
  
To facilitate the work, it is necessary to make variable transformations so that
`value-label` does not interfere, as it doesn't say anything about the
categorical or continuous consideration of the variables. 

**Before doing the data analysis it is required to convert the vectors with **
**`value_labels`** into factors, numeric or character vectors. To do this, it is
possible to use `unlabelled()`, `to_factor()` o `unclass()`
before data cleaning or after, to keep the info in the export. 

The original databases are then imported and copies are created for testing.

```{r}
data_2019 <- read_dta(BASELINE_FILEPATH, encoding = "UTF-8")
data_COVID <- read_dta(COVID_FILEPATH)
```

```{r}
# data_2019 <- read.dta13(BASELINE_FILEPATH, encoding = "UTF-8")
# data_COVID <- read.dta13(COVID_FILEPATH, encoding = "UTF-8", 
#                          fromEncoding = "CP1252")
# 
# data_2019_test <- data_2019
# data_COVID_test <- data_COVID
```

# Dataset inspection

## Remove and rename variables

We want to check that the column names are adequate. 
```{r}
raw_2019_colnames <- colnames(data_2019)
raw_COVID_colnames <- colnames(data_COVID)
```

How many columns are duplicated?
```{r}
intersect(raw_2019_colnames, raw_COVID_colnames)
```
Are in each dataset unique values for columns? Yes.
```{r}
print(raw_2019_colnames[duplicated(raw_2019_colnames)])
print(raw_COVID_colnames[duplicated(raw_COVID_colnames)])
```

```{r}
raw_2019_colnames
```

```{r}
raw_COVID_colnames
```

On COVID Substudy there's one case that is not on baseline wave. We have to
remove it. Firstly, we detect it using anti_join():

```{r}
ID_ECS_subs <- data_COVID %>%
                anti_join(data_2019, by = "ID_ECS") %>% 
                select(ID_ECS) %>% pull()

```

And then we remove it (is ID_ECS == 6900702)
```{r}
data_COVID <- data_COVID %>% 
  filter(ID_ECS != ID_ECS_subs)
```

Then, we create a test-dataframe for both waves to try different strategies to
armonize the variables involved.

```{r}
data_2019_test <- data_2019
data_COVID_test <- data_COVID
```

## Waves identification
```{r}
data_2019_test <- data_2019 %>%
              add_column(wave = 1, .before = "ID_ECS")
  
```

```{r}
data_COVID_test <- data_COVID %>%
              add_column(wave = 2, .before = "ID_ECS")
  
```

## Follow-up cases
COVID substudy is a follow-up study from baseline. We have to know what cases
are in both waves:
```{r}
ID_ECS_both <- data_COVID_test %>%
               semi_join(data_2019_test, by = "ID_ECS") %>% 
               select(ID_ECS) %>% 
               pull()
  
```

This generates a vector that contains 1853 values: the cases that are in both
waves of the study.

```{r}
# ID_ECS_w1w2 <- integer(3002)
# ID_ECS_w1w2 <- ifelse(data_2019_test$ID_ECS == ID_ECS_both, 1, 0)

combi <- match(data_COVID_test$ID_ECS, data_2019_test$ID_ECS) #positions of the
#cases that are in both waves
fill0 <- rep(0, 3002 - length(ID_ECS_both))

ID_ECS_w1w2 <- ifelse(combi, ID_ECS_both, fill0)
length(ID_ECS_w1w2)
length(fill0)
```

```{r}
ids_2019 <- data_2019_test %>% select(ID_ECS, wave)
ids_covid <- data_COVID_test %>% select(ID_ECS, wave)

ids <- full_join(ids_2019, ids_covid); ids
```


```{r}
prueba <- left_join(data_2019_test, data_COVID_test, by = "ID_ECS")

birthday_COVID <- prueba %>% 
                  group_by(ID_ECS) %>% 
                  mutate(
                    birthday_COVID = case_when(
                      wave.x == 1 & wave.y == 2 ~ q1010_birth_date.x,
                      wave.x == 1 | wave.y == 2 ~ 0
                    )
                  )
```


We have to harmonize the format of dates:
Firstly, we create separate vectors with the dates:
```{r dates-format}
fecha2019 <- lubridate::ymd(data_2019$q0006_date) #date of interview wave 1
fechaCOVID <- lubridate::dmy(data_COVID_test$FECHAFIN)
birthday <- lubridate::ymd(data_2019$q1010_birth_date)
birthday_COVID <- data_2019_test %>% 
                  filter(ID_ECS_both %in% ID_ECS) %>%
                  select(q1010_birth_date) %>% 
                  lubridate::ymd()
                  

```

```{r}
data_COVID_test <- data_2019_test %>% 
                  mutate(q1010_birth_date = lubridate::ymd(q1010_birth_date))
```



# Step 1. Harmonisation of wave 1

## 1. GENDER (q1009_sex)

**Self-identified gender** 
  - 1: male 
  - 2: female 
  - 3: other/diverse 
  -991: not assessed
  -992: refused to answer
  -993: missing (default)

Our categories are: 
  - 1 = male; 
  - 2 = female 
(the question is not about the self-identified gender, but sex).

### Variable exploration

```{r}
data_2019 %>%
  freq_table(q1009_sex)

data_2019 %>%
  select(q1009_sex) %>%
  summarise_all(funs(sum(is.na(.))))
```

### Variable harmonization
In this case we simply rename this variable and convert it into a factor, 
changing the labels as they are the same (the ones we have and the proposed ones)
```{r}
data_2019_test <- data_2019_test %>% 
  mutate(gender = factor(x = q1009_sex,
                          levels = c("1", "2", "3", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("male", 
                                    "female",
                                    "other/diverse",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(gender)
```

## 2. CORESIDENCE
There's no variable from which to create, but knowing that all participants
are from Spain, we can do it from scratch. This variable should be complemented
with the NUTS code (see below/later on on this script).

### Variable harmonization
```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    coresidence = "ES"
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(coresidence)
```


## 3. MIGRATION

**Country of birth other than country of residence**: 
  - 1 = Yes 
  - 2 = No 
  - 3 = No information
  - 991 = missing by design
  - 992 = refused to answer
  - 993 = missing (default)

Our variable has registered the name of each country. As we did the sample
collection in Spain, we can assume that responses that are different than Spain
are indicators of migration.

### Variable exploration

```{r}
data_2019 %>%
  select(q1018_country) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>% 
  freq_table(q1018_country) # 1 = Spain, !1 = other countries
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    migration = if_else(q1018_country == 1, 2, 1), 
    migration = factor(x = migration,
                       levels = c("1", "2", "3", MISSING_DESIGN,
                                                REFUSED_ANSWER, 
                                                NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "no information",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(migration)
```



##4 & 5.AGE (q1010_birth_date &/OR q1011_age)

The variable **age_continuous** is a continuous variable from 1 to 100. There is
also another variable, **age_cat**, a categorical v. with the following
levels: - \< 18 - 18 - 44 - 45 - 64 - 65 - 94 - \> 95

To obtain it we have two variables: date of birth and age.

There's no NAs in any of the variables. Elvira points out that there are
problems with the date of birth variable in some IDs (ID_ECS):

    18702401
    5600601
    3100602
    18702701
    2802002
    17801501
    16602601
    5800201
    19600501
    3300201
    7101202
    7101401
    14300101
    16800301

<!-- !TODO: Utilizar la fecha de entrevista - fecha de nacimiento salvo en los casos -->
<!-- señalados -->

### Variable exploration

```{r}
data_2019 %>%
  select(q1010_birth_date, q1011_age) %>%
  summarise_all(funs(sum(is.na(.))))

ID_NAs <- c(18702401,
    5600601,
    3100602,
    18702701,
    2802002,
    17801501,
    16602601,
    5800201,
    19600501,
    3300201,
    7101202,
    7101401,
    14300101,
    16800301) 

data_2019 %>%  
  filter(ID_ECS == 18702401 |
         ID_ECS == 5600601 |
         ID_ECS == 3100602 |
         ID_ECS == 18702701 | 
         ID_ECS == 2802002 |
         ID_ECS == 17801501 | 
         ID_ECS == 16602601 | 
         ID_ECS == 5800201 |
         ID_ECS == 19600501 | 
         ID_ECS == 3300201 |
         ID_ECS == 7101202 |
         ID_ECS == 7101401 |
         ID_ECS == 14300101 | 
         ID_ECS == 16800301) %>% 
  select(q1010_birth_date, q1011_age, q1010_year, q1010_month, q1010_day) %>% 
  View()

data_2019 %>%  
  filter(ID_ECS %in% ID_NAs) %>% 
  select(q1010_birth_date, q1011_age, q1010_year, q1010_month, q1010_day) %>% 
  View()


```

We use exclusively the Age variable:

```{r}
data_2019_test %>%
  freq_table(q1011_age) %>% 
  print(n = 82)
```

### Variables creation
```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    diff_bday_int = year(fecha2019) - year(birthday),
    diff_bday_int = as.double(diff_bday_int),
    age_continuous = if_else(
                        ID_ECS %in% ID_NAs, q1011_age, 
                        diff_bday_int
                        ),
    age_cat = case_when(
           age_continuous < 18 ~ 1,
           age_continuous >= 18 & age_continuous <= 44 ~ 2,
           age_continuous >= 45 & age_continuous <= 64 ~ 3,
           age_continuous >= 65 & age_continuous <= 94 ~ 4, 
           age_continuous >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels = c("1", "2", "3", "4", "5",
                                     MISSING_DESIGN,
                                     REFUSED_ANSWER,
                                     NON_RESPONSE),
                          labels = c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```


### Checking new variables

```{r}
data_2019_test %>% 
  freq_table(age_cat)

data_2019_test %>% 
  select(age_continuous, age_cat, q1011_age, q1010_birth_date) %>% 
  View()
#¿Hay algunos casos en los que la edad continua es un número mayor que la 
#establecida?
```

## 6. EMPLOYMENT STATUS (`q1503_work_now` & `q1504_reason`.)

**Employment status** has the following levels:

-   1 = Have a job (employed or self-employed)
-   2 = In education
-   3 = Care work (family) / homeworker/ on parental leave
-   4 = On long-term sick leave/disability
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
-   6 = unemployed or job-seeking
-   7 = retired

-991 = not assessed -993 = missing (default)

`q1503_work_now` (c2019_w1) *Currently working?*: 
- 1 = Yes 
- 2 = No

`q1504_reason` (c2019_w1) *Reason not working*:

-   1 = homemaker
-   2 = couldn't find a job
-   3 = unpaid/voluntary
-   4 = studies/training
-   5 = health
-   6 = care family
-   7 = no need
-   8 = not permitted
-   9 = retired/too old
-   10 = laid off
-   11 = seasonal work
-   12 = does not want to for a while
-   13 = vacation/sick or maternity leave
-   87 = other.

As a proposal, I suggest the following combination of both variables:

-   1 = Have a job (employed or self-employed) == `1 (q1503_work_now)`
-   2 = In education (currently studying) == `4 (q1504_reason)`
-   3 = Care work (family) / homeworker / on parental leave == `1, 6`
    `(q1504_reason)`** 
-   4 = On long-term sick leave/disability == `5 (health) (q1504_reason)`,
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
    (other) == `3 (unpaid/voluntary), 7 (no need), 8 (not permitted), 11,`
   ` 12 (does not want to for a while), 13, 87 (other)`
-   6 = unemployed or job-seeking == `2 (couldn't find a job), 10 (laid off)`, 
`11 (seasonal work)`,
-   7 = retired == `9 (retired/too old)`

### Variable exploration

```{r}
data_2019 %>%
  select(q1503_work_now, q1504_reason) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs (347 en work-now y 1387 en reason)

data_2019 %>% 
  freq_table(q1503_work_now) #1 = yes; 2 = no; NAs = -93

data_2019 %>% 
  freq_table(q1504_reason) 
```

### Variable creation

```{r}

data_2019_test <-
  data_2019_test %>%
  mutate(employment_st = case_when(
                  q1503_work_now == 1 ~ 1, #have a job
                  q1504_reason == 4 ~ 2, #studying
           q1504_reason == 1 | q1504_reason == 6 ~ 3, #care work 
           q1504_reason == 5 ~ 4, # on long term sick leave disability
           q1504_reason == 3 | q1504_reason == 7 | q1504_reason == 8 | q1504_reason == 11 | q1504_reason == 12  | q1504_reason == 13 | q1504_reason == 87 ~ 5, #other reasons
           q1504_reason == 2 | q1504_reason == 10 |q1057 == 11 ~ 6, #unemployed or job-seeking
           q1504_reason == 9 ~ 7, #retired,
           is.na(q1504_reason) | is.na(q1503_work_now) ~ NON_RESPONSE
         ),
          employment_st = factor(x = employment_st,
                          levels = c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("have a job (employed or self-employed)",
                                    "in education",
                                    "care work (familiy) / homeworker/ on parental leave",
                                    "on long-term sick leave/disability",
                                    "unable to work due to reasons not mentioned elsewhere in this list",
                                    "unemployed or job-seeking",
                                    "retired",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
                                    )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(employment_st) %>%
  freq_table(employment_st)
```


## 7. CONTRACT (q1510b_contract_earner)

**Permanent/temporary contract**

Changes made after consulting with IPD-Respond team:

-   1 officer ===== 1 permanent
-   2 indefinite period (not officer) ===== 4 (other)
-   3 temporal or contract of works and services ===== 2 temporary
-   4 verbal or without contract ===== 4
-   888 DK ===== -993
-   999 refused to answer ===== -992

### Variable exploration

```{r}
data_2019 %>%
  select(q1510b_contract_earner) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  freq_table(q1510b_contract_earner)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(contract = case_when(
        q1510b_contract_earner == 1 ~ 1, #officer --> permanent
        q1510b_contract_earner == 3  ~ 2, #temporal or contract of works and services --> temporary
        q1510b_contract_earner == 4 |
        q1510b_contract_earner == 2 ~ 4, #verbal or without contract & indefinite period (not officer) --> other
        q1510b_contract_earner == 888 ~ NON_RESPONSE, 
        q1510b_contract_earner == 999 ~ REFUSED_ANSWER,
        is.na(q1510b_contract_earner) ~ NON_RESPONSE

         ),
          contract = factor(x = contract,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
 )))

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(contract)
```


# 8. EMPLOYMENT TYPE (`q1510_workday`)

-   1 - Full time
-   2 - Part time
-   3 - No paid work
-   4 - Other
-   -991 not assessed
-   -992 refused to answer
-   -993 missing (default)

In EcS (`q1510_workday`):

-   1 Part time (morning and afternoon) ===== 2
-   2 Continuous morning working day ===== 1
-   3 Continuous afternoon working day ===== 1
-   4 Continuous night working day ===== 1
-   5 Reduced work day ===== 4
-   6 Shift work / irregular or variable work ==== 4
-   7 Other type ==== 4
-   888 DK ==== -992

### Variable exploration

```{r}
data_2019 %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>%
  freq_table(q1510e_workday)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(employment_ty = case_when(
       q1510e_workday == 1 ~ 2, #part time --> part time
       q1510e_workday == 2 ~ 1, #continuous morning working day --> full time
       q1510e_workday == 3  ~ 1, #continuous afternoon working day --> full time
       q1510e_workday == 4 ~ 1, #continuous night working day --> full time
       q1510e_workday == 5 ~ 4, #reduced work day --> other
       q1510e_workday == 6 ~ 4, #shift work --> other
       q1510e_workday == 7 ~ 4, #other --> other
       q1510e_workday == 888 ~ REFUSED_ANSWER,
        is.na(q1510e_workday) ~ NON_RESPONSE

         ),
          employment_ty = factor(x = employment_ty,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
 )))


```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(employment_ty)

```



## 9. HC WORKER (To be modified)
*defined as: A healthcare worker is anyone who works in a healthcare or social
care setting, including healthcare students on clinical placement, frontline
healthcare workers and other healthcare workers not in direct patient contact.

These settings include, but are not limited to, state-funded and private
organisations providing services in the following areas: disability, older
persons, nursing homes, acute and non acute hospitals, community hospitals,
mental health, social inclusion, palliative care, chronic illness, primary care
(GP, dental, pharmacies, physiotherapy clinics), health and well being, hospice,
rehabilitation, home care, paramedics, and community services (e.g. youth,
substance abuse, suicide prevention, community development).

HC_worker has to be a dichotomous variable that indicates if a participants fits
in the previous definition (1 = yes; 2 = no). In EcS we have `q1510_occ`on base-
line, which indicates in a free-text variable the occupation of the participants.
`q1510_catoccu` uses the CIUO-08 (ISCO codes from OIT) from categorize the 
occupations of the participants. 

To proceed, we follow the next steps:

1. Explore unique values of this variable & see if `q1510_catoccu`is useful.
2. Extract patterns that are of our interest. 
3. Create the new variable. 


```{r}
occ_unique <- data_2019 %>%
  select(q1510_occ) %>%
  distinct()  
  
View(occ_unique)

data_2019 %>%
  select(q1510_occ, q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.)))) #Los NAs coinciden entre ambas; en 
#respuesta abierta son "".
```

There are 1824 unique values for this variable and 347 NAs (in both variables;
in free-text they appear as ""). This would be useful in order
to process the variable "profession" later on. 

`q1510_catoccu`indicates the categorization of the 10 main groups, but not
the subcategories, which are the ones that could be interesting to use. We'll
try if using it as a filter is useful. 


Barely it does, as the principal category of our interest leaves out interesting
occupations (e.g., auxiliar de enfermería), which are on groups 2, 3, 7, 8. 
As it  doesn't allow us to differentiate health care workers from other
professionals, we'll just work with `q1510_occ`and explore manually all the
free-text unique values. The ones that are interesting for us are on
`"HC_workersCat.txt"`. 

To facilitate pattern detection, we convert to lowercase all the values of 
`q1510_occ` using `str_to_lower()`de `stringr`. To eliminate accents, 
`stri_trans_general(x, "Latin-ASCII")`.

```{r}
data_2019_test %>% 
  mutate(
    q1510_occ_utf8 = as_utf8(q1510_occ),
    q1510_occ_utf8 = str_to_lower(q1510_occ_utf8, locale = "spa"),
    q1510_occ_itf8 = stringi::stri_trans_general(q1510_occ_utf8, "Latin-ASCII")
  ) %>% 
  select(q1510_occ, q1510_occ_utf8) %>% 
  View()
```

Import the .txt that has all the responses to create HC_workers:

```{r}
library(readr)
occ_unique <- read_delim("C:/Users/Cristina/Downloads/HC-workerCat.txt", 
     delim = "\t", escape_double = FALSE, 
     col_names = FALSE, trim_ws = TRUE)
#occ_unique <- as.character(occ_unique)

```

```{r}
data_2019_test <- data_2019 %>% 
  mutate( 
    #hc_worker = if_else(str_detect(q1510_occ, occ_unique$X1), 1, 2),
    hc_worker = if_else(q1510_occ %in% occ_unique$X1, 1, 2),
    hc_worker = factor(x = hc_worker,
                                  levels = c("1", "2",
                                             MISSING_DESIGN, 
                                             REFUSED_ANSWER, 
                                             NON_RESPONSE),
                                  labels = c("yes",
                                            "no",
                                            "not assessed",
                                            "refused to answer",
                                            "missing (default)"
                                            )))
#TODO: Ver por qué no funciona str_detect 
#Se ha hecho un apaño con if_else, pero realmente tendríamos que ver qué
#pasa con str_detect porque a lo mejor es posible que alguno se nos haya
#pasado.
```


```{r}
data_2019_test %>% 
  freq_table(hc_worker)
```


## A REVISAR 10. PROFESSION (q1510_catoccu)

**Best description of current occupation(s)**
We will include this variable in raw format in the database just for 
knowing levels of OIT categorization rather than sector. Following
recommendations of IPD-RESPOND team, we would try to keep assumptions to a
minimum and when in doubt, code things as other:


-   1 Legislators === 7 (civil services, politics)
-   2 Professionals === 14 (others)
-   3 Technicians ==== 14 (others) 
-   4 Clerks ===== 12 (installation, maintenance, cleaning and repairs)
-   5 Service workers ==== 5 (first responder: paramedic/firefighter/police)
-   6 Skilled agricultural workers ==== 14 (others)
-   7 Craft workers ==== 14 (others)
-   8 Plant operators ==== 14 (other)
-   9 Elementary occupations ==== 14 (others)
-   10 Armed forces === 6 (military)


### Variable exploration

```{r}
data_2019 %>%
  select(q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  freq_table(q1510_catoccu) 
```

### Variable creation

```{r}
#Creamos la variable
data_2019_test <-
  data_2019_test %>%
  mutate(profession = case_when(
                      q1510_catoccu ==  5  ~  5 , #service workers --> first responders: paramedic/firefighter/police
                      q1510_catoccu ==  10  ~  6 , #armed forces --> military
                      q1510_catoccu ==  1  ~  7 , #legislators --> civil services, politics
                      q1510_catoccu ==  4  ~  12 , #clerks --> installation, maintenance, cleaning and reparis
                      q1510_catoccu ==  8 | 
                      q1510_catoccu ==  3 | 
                      q1510_catoccu ==  6 |
                      q1510_catoccu ==  7 | 
                      q1510_catoccu ==  9 | 
                      q1510_catoccu ==  2  ~  14, #others
                      is.na(q1510_catoccu) ~ NON_RESPONSE
                      
         ), 
         profession = factor(x = profession,
                                  levels = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14",
                                             MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                                  labels = c("undergoing education",
                                            "education and research",
                                            "arts, entertainment, sports and media",
                                            "healthcare",
                                            "first responder (paramedic/firefighter/police)",
                                            "military",
                                            "civil services, politics",
                                            "finance and economy",
                                            "industry",
                                            "sales and services (incl. restaurants and bars)",
                                            "transport (goods and people)",
                                            "installation, maintenance, cleaning, and repairs",
                                            "currently not working",
                                            "other",
                                            "not assessed",
                                            "refused to answer",
                                            "missing (default)"
                                            )))

```


### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(profession)
```

## 11. EDUCATION (q1016_highest)

**Highest level of education according to ISCED Classification**:

-   1 = primary/basic: (primary education and lower secundary education)
-   2 = secondary/intermediate: (upper secondary education, post-secondary
    non-tertiary education)
-   3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or
    equivalent level, master's or equivalent level, doctoral or equivalent
    level)
-   4 = no formal education / less than basic (no schooling, early childhood
    education) -991 = not assessed -993: level not stated - if following yellow
    box, if not, "missing (default)"

Our variable, `q1016_highest`, has as levels (doesn't have *non-tertiary
education*): - 0 = No formal education - 1 = Primary education not completed - 2
= Primary education completed - 3 = Lower secondary education completed - 4 =
Upper secondary education completed - 5 = University/college completed - 6 =
Master degree, PhD completed - 888 = don't know

As a proposal, I suggest: - 1 = primary/basic --\> 1, 2, 3 - 2 =
secondary/intermediate: 4, - 3 = tertiary/advanced: 5, 6 - 4 = no formal
education / less than basic: 0

### Variable exploration

```{r}
data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs, but 888 as DK.

data_2019 %>% 
  freq_table(q1016_highest)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(education = case_when(
           q1016_highest == 0 ~ 4,
           q1016_highest == 1 | q1016_highest == 2 | q1016_highest == 3 ~ 1,
           q1016_highest == 4 ~ 2, 
           q1016_highest == 5 | q1016_highest == 6 ~ 3,
           q1016_highest == 888 ~ NON_RESPONSE,
         ), 
         education = factor(x = education,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("primary/basic", 
                                    "secondary/intermediate",
                                    "tertiary/advanced",
                                    "no formal education",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(education)
```



## 12. RELATIONSHIP STATUS (q1012_mar_stat)

**Relationship status** is a categorical variable with the following levels: 1 =
Single 2 = Married /in a civil union 3 = in a relationship and living together 4
= in a relationship and living apart 5 = divorced/separated 6 = widowed 7 =
other

Our variable `q1012_mar_stat` is coded as: 1 = never married (and no cohabiting)
2 = currently married/law-partner 3 = cohabiting 4 = separated/divorced 5 =
widowed

As the categories doesn't match exactly, I propose the following categorisation:
1 = single --\> 1 (never married and no cohabiting) 2 = married / in a civil
union --\> 2 (currently married/law-partner) 3 = in a relationship and living
together --\> 3 (cohabiting) 4 = in a relationship and living apart --\>
MISSING_DESIGN 5 = divorced/separated --\> 4 (separated/divorced) 6 = widowed
--\> 5 (widowed) 7 = other --\> MISSING_DESIGN

### Variable exploration

```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  freq_table(q1012_mar_stat)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(relationship = case_when(
           q1012_mar_stat == 1 ~ 1,
           q1012_mar_stat == 2 ~ 2,
           q1012_mar_stat == 3 ~ 3,
           q1012_mar_stat == 4 ~ 5, 
           q1012_mar_stat == 5 ~ 6,
         ), 
         relationship = factor(x = relationship,
                          levels = c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("single", 
                                    "married/in a civil union",
                                    "in a relationship and living together",
                                    "in a relationship and living apart",
                                    "divorced/separated",
                                    "widowed",
                                    "other",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(relationship)
```

## 13. CHILDREN (q1056/q1058)

**Do you have children, live with children or take care of children in your**
**household?** - 1 = yes, - 2 = no - 991 - 993

Our variables `q1056` & `q1058` ask about biological and adopted children
(separated) (1 = yes; 2 = no). Elvira suggested to combine them and we'll follow
this approach.

### Variable exploration

```{r}
data_2019 %>%
  select(q1056, q1058) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>% 
  freq_table(q1056) #1 = yes (2241); #2 = no (761)

data_2019 %>% 
  freq_table(q1058) #1 = yes (24); #2 = no (2978)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children = case_when(
           q1056 == 1 | q1058 == 1 ~ 1,
           q1056 == 2 | q1058 == 2 ~ 2
         ), 
         children = factor(x = children,
                          levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(children) #2253 = yes; 749 = no  
```



## 14. CHILDREN HOUSEHOLD (q0407_age_01-q0407_age_08/q0407_age_10)
__Are there children in your household?__
- 1 = Yes;
- 2 = No.


### Variable exploration
```{r}
freq_table(data_2019_test, q0407_age_01)

freq_table(data_2019_test, q0407_age_02)

freq_table(data_2019_test, q0407_age_03)

freq_table(data_2019_test, q0407_age_04)

freq_table(data_2019_test, q0407_age_05)

freq_table(data_2019_test, q0407_age_06)

freq_table(data_2019_test, q0407_age_07)

freq_table(data_2019_test, q0407_age_08)

freq_table(data_2019_test, q0407_age_09)

freq_table(data_2019_test, q0407_age_10)



data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  summarise_all(funs(sum(is.na(.)))) #A lot of NAs

data_2019 %>% 
  select(q0407_age_01, q0407_age_02, q0407_age_03, q0407_age_04, q0407_age_05, q0407_age_06, q0407_age_07, q0407_age_08, q0407_age_10) %>% 
  glimpse()
```

### Variable creation
```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children_hh = 
           case_when(
              q0407_age_01 < 18 | q0407_age_02 < 18 | q0407_age_03 < 18 | q0407_age_04 < 18 | q0407_age_05 < 18 | q0407_age_06 < 18 | q0407_age_07 < 18 | q0407_age_08 < 18 |  q0407_age_09 < 18 | q0407_age_10 < 18 ~ 1,
              
              q0407_age_01 >= 18 | q0407_age_02 >= 18 | q0407_age_03 >= 18 | q0407_age_04 >= 18 | q0407_age_05 >= 18 | q0407_age_06 >= 18 | q0407_age_07 >= 18 | q0407_age_08 >= 18 |  q0407_age_09 >= 18 | q0407_age_10 >= 18 ~ 2,
              
           
              is.na(q0407_age_01) | is.na(q0407_age_02) | is.na(q0407_age_03) | is.na(q0407_age_04) |is.na(q0407_age_05) | is.na(q0407_age_06) | is.na(q0407_age_07) | is.na(q0407_age_08) | is.na(q0407_age_09) |is.na(q0407_age_10) ~ NON_RESPONSE
  ),
        children_hh = factor(x = children_hh,
                          levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)"))
  )
```

### Comprobación
```{r}
freq_table(data_2019_test, children_hh) #5 households with children
```

## 15. N. O. CHILDREN (q1057/q1059)

Is the same as the previous one but in a continuous way: \_\_How many children
do you have? (including children who are not your own but live in the same
household or who you care for in your household?) - 1 = no children - 2 = one
child - 3 = two or three - 4 = four or more - 991 - 993

Variables in ECS makes a differentiation between biological and adopted children
(1+, DK). As a proposal, it is suggested to combine the two variables.

### Variable exploration

```{r}
data_2019 %>%
  select(q1057, q1059) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs

data_2019 %>%
  freq_table(q1057) 

data_2019 %>%
  freq_table(q1059) 
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
         
         q1057_NA = replace_na(q1057, 0),
         q1057_NA = na_if(q1057_NA, 888),
         q1059_NA = replace_na(q1059, 0),
         add_children = q1057_NA + q1059_NA,
         
         
         nofchildren = case_when(
                                  add_children == 0 ~  1, #no children
                                  add_children == 1 ~ 2, #one children
                                  add_children == 2 | add_children == 3 ~ 3, #two or three children
                                  add_children >= 4 ~ 4, # four or more,
                                  is.na(add_children) ~ NON_RESPONSE
                                 
         ), 
         nofchildren = factor(x = nofchildren,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("no children", 
                                    "one child",
                                    "two or three",
                                    "four or more",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))

```


### Checking new variable

```{r}
data_2019_test %>%
  freq_table(nofchildren)
```


##16. LIVINGALONE
**¿Cuál es el número total de personas que viven habitualmente en este hogar?**
Dos categorías: - 1 = alone; - 2 = not alone.

En ECS partimos de `q0401_hh_total`, que es una variable cuantitativa del 1 al
10.

#### Variable exploration

```{r}
data_2019 %>%
  freq_table(q0401_hh_total)

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs
```

#### Variable creation

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(living_alone = if_else(q0401_hh_total == 1, 1, 2),
         living_alone = factor(x = living_alone,
                               levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                               labels = c("alone", 
                                          "not alone", 
                                          "not assessed", 
                                          "refused to answer",
                                          "missing (default)"))) %>%
  select(living_alone) %>% 
    glimpse()


var_label(data_2019_test$living_alone) <- "Living alone"

```

#### Checking new variable

```{r}
data_2019_test %>%
  freq_table(living_alone)
```

## 17. HOUSEHOLD SIZE (q0401_hh_total)

**How many people, including yourself, live in your household** 
- 1: one person 
- 2: two persons 
- 3: three or four persons 
- 4: five or more persons 
- 5: live in an institution

Variable `q0401_hh_total` reflects the number of people (1-10 to 10 people),
but doesn't take into account if they live in an institution. This was done by
item `q0400a`. It's not a problem because on baseline there wasn't any participant
in that case. We just don't include any case labelled as 5.


### Exploración de variables

```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  freq_table(q0401_hh_total) 
```

### Creación de la variable

```{r}
data_2019_test <- data_2019 %>% 
  mutate(hh_size = case_when(
                  q0401_hh_total == 1 ~ "1",
                  q0401_hh_total == 2 ~ "2",
                  q0401_hh_total == 3 ~ "3",
                  q0401_hh_total == 4 ~ "3",
                  q0401_hh_total >= 5 ~ "4"),
         
         hh_size = factor(x = hh_size,
                          levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("one person", 
                                    "two persons", 
                                    "three or four persons", 
                                    "five or more persons", 
                                    "live in an institution", 
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)"))
  )

var_label(data_2019_test$hh_size) <- "Household size"

```

### Comprobación del funcionamiento de la nueva variable

```{r}
freq_table(data_2019_test, hh_size)

data_2019_test %>%
  group_by(hh_size) %>% 
  pivot_longer(hh_size, names_to = "size", values_to = "value") %>% 
  select(size, value) %>% 
  distinct() %>% 
  arrange(size, value) %>% 
  print(n = 150)


data_2019_test %>% freq_table(hh_size)
```


## 18. INCOME QUARTILES

Las variables relacionadas con los ingresos que se manejan en esta BBDD son:

-   `q0410g_total`: ingresos personales brutos de todos los miembros de su
    familia durante los últimos 12M.
-   `q0410i_ss`: ingresos brutos de su hogar durante los últimos 12M procedentes
    de la pensión de jubilación.
-   `q0410j_government`: ingresos brutos de su hogar (...) procedentes de progra
    mas oficiales (paro, hijos dependientes, viudedad, orfan- dad, asistencia
    general)
-   `q0410k_other`: de fuentes privadas (pensiones, inversiones, alimenticias o
    de mantenimiento).

Se descarta `q1519` para este fin porque pregunta por la situación financiera en
la infancia.

### Exploración de variables

Vemos cuántos valores únicos hay por cada variable y las representamos gráfica-
mente. Se trata de una variable categórica que representa rangos. Se encuentran
34 valores distintos dentro de esta variable.

```{r}
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),
               names_to = "income", 
               values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)
```

```{r}
data_2019 %>%
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>%
  summarise_all(funs(sum(is.na(.))))
```

```{r}
data_2019 %>% 
  freq_table(q0410g_total) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410i_ss) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410j_government) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410k_other) %>% 
  print(n = 50)
```

```{r}
g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4)
```


#### Recodificación de la variable

Para proceder con el tratamiento de esta variable, Dani me envía su script
`Edad_con_Salud_Data.R`. La idea que se extrae de ese script es recodificar
estas cuatro variables por la mediana del rango establecido para poder sumarlas
y crear los quintiles en base a esto.

Debido al doble formato de Stata, primero convertimos las variables a numéricas
y luego a factores.

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  View()
```


```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    q0410g_total = as.numeric(q0410g_total),
    q0410i_ss = as.numeric(q0410i_ss),
    q0410j_government = as.numeric(q0410j_government),
    q0410k_other = as.numeric(q0410k_other),
    
    q0410g_total = as.factor(q0410g_total),
    q0410i_ss = as.factor(q0410i_ss),
    q0410j_government = as.factor(q0410j_government),
    q0410k_other = as.factor(q0410k_other)
  )
```

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE, 
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )
```

```{r}
data_2019_test %>% 
  select(q0410g_total,  
         q0410g_total_r, 
         q0410i_ss, 
         q0410i_ss_r, 
         q0410j_government, 
         q0410j_government_r, 
         q0410k_other,
         q0410k_other_r) %>% 
  str()
```

Encontramos que la recodificación que se ha hecho no es la que buscábamos,
aunque si seleccionamos dos variables (original y recodificada) vemos que
podemos hacer otras cosas para seguir operando:

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410g_total_r) %>% 
  View()
```

Se han modificado los levels, pero no las labels. En cualquier caso, para seguir
avanzando, tenemos que convertirlo a carácter y luego a integer:

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_total_r = as.character(q0410g_total_r),
        q0410i_ss_r = as.character(q0410i_ss_r),
        q0410j_government_r = as.character(q0410j_government_r),
        q0410k_other_r = as.character(q0410k_other_r),
        
        q0410g_total_r = as.integer(q0410g_total_r),
        q0410i_ss_r = as.integer(q0410i_ss_r),
        q0410j_government_r = as.integer(q0410j_government_r),
        q0410k_other_r = as.integer(q0410k_other_r)
  )
```

Comprobamos que están los NAs bien codificados (-993 y NA)
```{r}
data_2019_test %>%
  select(q0410g_total_r, q0410i_ss_r, q0410j_government_r, q0410k_other_r) %>%
  summarise_all(funs(sum(is.na(.)))) #Están bien los NAs, 91 de proxy
```

```{r}
data_2019_test %>% 
  freq_table(q0410g_total_r) %>%  # 371 + 819 = 1190 NON_RESPONSE
  print(n = 26)
```

```{r}
data_2019_test  %>% 
  freq_table(q0410i_ss_r) #267 + 824 = 1091 NON_RESPONSE
```

```{r}
data_2019_test  %>% 
  freq_table(q0410j_government_r) #230 + 766 = 966 NON_RESPONSE
```

```{r}
data_2019_test  %>% 
  freq_table(q0410k_other_r) #291 + 710 = 1001 NON_RESPONSE
```


Necesitamos crear otra variable a partir de esta teniendo en cuenta los -993 y
-93 con missing para que no se tengan en cuenta a la hora de calcular los
quintiles, utilizando na_if().

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_tot_NA = na_if(q0410g_total_r, NON_RESPONSE),
        q0410g_tot_NA = na_if(q0410g_tot_NA, REFUSED_ANSWER),
        q0410i_ss_NA = na_if(q0410i_ss_r, NON_RESPONSE),
        q0410i_ss_NA = na_if(q0410i_ss_NA, REFUSED_ANSWER),
        q0410j_gov_NA = na_if(q0410j_government_r, NON_RESPONSE),
        q0410j_gov_NA = na_if(q0410j_gov_NA, REFUSED_ANSWER),
        q0410k_other_NA = na_if(q0410k_other_r, NON_RESPONSE),
        q0410k_other_NA = na_if(q0410k_other_NA, REFUSED_ANSWER)
)
```

```{r}
data_2019_test  %>% 
 freq_table(q0410i_ss_NA)
```


```{r}
data_2019_test %>%
  select( q0410g_tot_NA, q0410i_ss_NA, q0410j_gov_NA, q0410k_other_NA) %>%
  summarise_all(funs(sum(is.na(.))))
```
Ahora mismo están como NAs los que son MISSING_DESIGN (proxy) y los NON_RESPONSE
Una vez que tenemos esto, ya podemos continuar operando.

```{r}
data_c2019w1 |> transmute(across(q0410g_total:q0410k_other, is.na)) |> distinct()
```


#### Creación de la variable

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
    hh_income_r_NA = q0410g_tot_NA + q0410i_ss_NA + q0410j_gov_NA + q0410k_other_NA)
```

```{r}
data_2019_test %>% 
  freq_table(hh_income_r_NA)
```

Tenemos 1429 NAs, en los que se incluyen los MISSING_DESIGN y los NON_RESPONSE.

```{r}
glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r_NA)
```


```{r}
quartiles19 <- c(9816, 15015, 22024) 
```

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
  hhquartile = case_when(
                          hh_income_r_NA <= quartiles19[1] ~ 1,
                          hh_income_r_NA > quartiles19[1] & hh_income_r_NA <= quartiles19[2] ~ 2,
                          hh_income_r_NA > quartiles19[2] & hh_income_r_NA <= quartiles19[3] ~ 3,
                          hh_income_r_NA > quartiles19[3] ~ 4,
                          is.na(hh_income_r_NA) & is.na(q0410g_total_r) & 
                                                  is.na(q0410i_ss_r) &
                                                  is.na(q0410j_government_r) &
                                                  is.na(q0410k_other_r)
                                                           ~ MISSING_DESIGN,
                          is.na(hh_income_r_NA) ~ NON_RESPONSE),                     

  hhquartile = factor(x = hhquartile,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("first quartile", 
                                    "second quartile", 
                                    "third quartile", 
                                    "fourth quartile", 
                                    "not assessed", 
                                    "missing (default)")))
                          
```

#### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(hhquartile)
```

## 19. INCOME QUINTILES

#### Variable creation
```{r}
quintiles19 <- c(8847, 12997, 17422, 24104)
```

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
  hhquintile = case_when(
                          hh_income_r_NA <= quintiles19[1] ~ 1,
                          hh_income_r_NA > quintiles19[1] & hh_income_r_NA <= quintiles19[2] ~ 2,
                          hh_income_r_NA > quintiles19[2] & hh_income_r_NA <= quintiles19[3] ~ 3,
                          hh_income_r_NA > quintiles19[3] & hh_income_r_NA <= quintiles19[4] ~ 4,
                          hh_income_r_NA > quintiles19[4] ~ 5,
                          is.na(hh_income_r_NA) & is.na(q0410g_total_r) & 
                                                  is.na(q0410i_ss_r) &
                                                  is.na(q0410j_government_r) &
                                                  is.na(q0410k_other_r)
                                                           ~ MISSING_DESIGN,
                          is.na(hh_income_r_NA) ~ NON_RESPONSE),                     

  hhquintile = factor(x = hhquintile,
                          levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("first quintile", 
                                    "second quintile", 
                                    "third quintile", 
                                    "fourth quintile",
                                    "fifth quintile",
                                    "not assessed", 
                                    "missing (default)")))
                          
```

#### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(hhquintile)
```

Aquí tenemos 1338 NAs y los 91 proxy. 


## STRESSORS: life events
We have to import this outcome (already created) from OneDrive.

```{r}
lte <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_LTE.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            lte, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q465", "q466", "q467"))) %>% 
  colnames()
```

## BRS (resilience scale)

We have to import this outcome (already created) from OneDrive.

```{r}
brs <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_briefresiliencescale.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            brs, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q753", "q754"))) %>% 
  colnames()
```

## SOCIAL SUPPORT & LONELINESS
We have to import this outcome (already created) from OneDrive.

```{r}
loneliness_ss_si <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Loneliness, social support and social isolation.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            loneliness_ss_si, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q63"))) %>% 
  colnames()
```

## SOCIAL PARTICIPATION

To be created from baseline using q6613-q6621 (Adaptación del Índice de
Aislamiento Social - Shankar, McMunn, Banks y Steptoe (2011))

¿Con qué frecuencia en los últimos 12 meses usted

- q6613_club: ... asistió a una reunión con algún grupo, club u organización?
- q6618_relig: ... asistió a actividades religiosas (no incluya bodas y 
funerales)?
- q6619_leave: ... salió de su hogar/vivienda para asistir a reuniones sociales,
actividades, programas o eventos o para visitar a amigos/as familiares?
- q6621_assoc: ... acudió a centros o asociaciones de mayores, centros de día,
grupos de autoayuda, universidades para la tercera edad?

- 1: Nunca
- 2: Una o dos veces al año 
- 3: Una o dos veces al mes
- 4: Una o dos veces por semana
- 5: A diario

- 999: NA


```{r}
data_2019_test %>% 
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>% 
  glimpse()

data_2019 %>%
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  freq_table(q6613_club)


data_2019 %>% 
  freq_table(q6618_relig)

data_2019 %>% 
  freq_table(q6619_leave)

data_2019 %>% 
  freq_table(q6621_assoc)
```

To create this variable:
- Not married/not cohabiting with a partner == 1, 
- had less than monthly contact with children, other inmediate family and friends
(q6619_leave == 2 & 1)
- if no participation in any organization,s, religious groups, or committees 
(q6613_club == 1; q6621_assoc == 1)

En total es una escala de 5 puntos (la original), pero como aquí sólo tenemos 4
la escala irá de 0 a 4 señalando que mayores puntuaciones tienen una mayor
aislamiento social. 

Lo podemos reconvertir a la inversa para que señale participación social. 

\*En variable_list.xlsx aparece una fila duplicada con social participation que
dice "size_sn", pero es una variable que no existe en la BBDD ni en la
documentación de cohorte 2019.

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(q6613_club_r =
           case_when(
             (q6613_club == 3 | q6613_club == 4 | q6613_club == 5) ~ 1,
             is.na(q6613_club) ~ NA,
             TRUE ~ 0),
         
          q6618_relig_r = 
           case_when(
             (q6618_relig == 3 | q6618_relig == 4 |  q6618_relig == 5) ~ 1,
             is.na(q6618_relig) ~ NA,
             TRUE ~ 0),
         
         q6619_leave_r =
           case_when(
             (q6619_leave == 3 | q6619_leave == 4 |  q6619_leave == 5) ~ 1,
             is.na(q6619_leave) ~ NA,
             TRUE ~ 0),
         
         q6621_assoc_r =
           case_when(
             (q6621_assoc == 3 | q6621_assoc == 4 |  q6621_assoc == 5) ~ 1,
             q6621_assoc == 999 ~ NON_RESPONSE,
             is.na(q6621_assoc) ~ NA,
             TRUE ~ 0),
         
         social_participation = q6613_club_r + 
                                q6618_relig_r + 
                                q6619_leave_r +
                                q6621_assoc_r,
         
         social_participation =
           case_when(
             (social_participation < 0) ~ NON_RESPONSE,
             is.na(social_participation) & is.na(q6613_club) & 
                                           is.na(q6618_relig) &
                                           is.na(q6619_leave) &
                                           is.na(q6621_assoc) ~ MISSING_DESIGN,
             TRUE ~ social_participation
           )
             )
```

```{r}
data_2019_test %>% 
  select(social_participation) %>%
  freq_table(social_participation)
```


The individual items are already on the dataset:
```{r}
data_2019_test %>% 
  select(starts_with(c("q661", "q662"))) %>% 
  colnames()
```

## ALCOHOL CONSUMPTION
We have to import this outcome (already created) from OneDrive.

```{r}
alcohol <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Alchool Consumption.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            alcohol, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q300"))) %>% 
  colnames()
```

## TOBACCO CONSUMPTION
We have to import this outcome (already created) from OneDrive.

```{r}
tobacco <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_tobaccoconsumption.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            tobacco, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q300"))) %>% 
  colnames()
```

## DEPRESSION


```{r}
depression <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_depressionDSM5.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            depression, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q422", "q421", "q4223", "q4700"))) %>% 
  colnames()
```

## FLOURISHING SCALE

```{r}
flourishing <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Flourishing Scale.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            flourishing, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q75"))) %>% 
  colnames()
```

## NEGATIVE AND POSITIVE AFFECT

```{r}
negposaf <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Positive and Negative Affect.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            negposaf, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q702", "q703", "q711", "q7069", "q707", "q706"))) %>% 
  colnames()
```

## QUALITY OF LIFE

```{r}
qol <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Quality of Life.dta")
```


We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            qol, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q700", "q7010"))) %>% 
  colnames()
```

## EXTRAVERSION & NEUROTICISM

```{r}
personality <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_EPQR-A.dta")
```


We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            personality, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q464", "q465"))) %>% 
  colnames()
```

## SELF-EFFICACY
```{r}
data_2019_test %>% 
  select(starts_with(c("q7008"))) %>% 
  colnames()
```

## STRESSORS

```{r}
data_2019_test %>% 
  select(starts_with(c("q201", "q751", #sleep problems,
                       "q304", #nutrition
                       "q200","q41" #pain
                       ))) %>% 
  colnames()
```

## MATERIAL DEPRIVATION
```{r}
materialdep <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_materialdeprivation.dta")
```


We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            materialdep, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q0411"))) %>% 
  colnames()
```

## GAD

```{r}
anxiety <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_anxietyDSM4.dta")
```


We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            anxiety, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q45", "q6010", "q621", "q7008a"))) %>% 
  colnames()
```

# Step 2. Harmonization of wave 2

## AGE (q1010_birth_date &/OR q1011_age from baseline) --- PENDING

The variable **age_continuous** is a continuous variable from 1 to 100. There is
also another variable, **age_cat**, a categorical v. with the following
levels: - \< 18 - 18 - 44 - 45 - 64 - 65 - 94 - \> 95

To obtain it we have two variables: date of birth and age.

There's no NAs in any of the variables. Elvira points out that there are
problems with the date of birth variable in some IDs (ID_ECS):

    18702401
    5600601
    3100602
    18702701
    2802002
    17801501
    16602601
    5800201
    19600501
    3300201
    7101202
    7101401
    14300101
    16800301
### Variable exploration

We have to see which of these IDs are on COVID substudy. To do so we execute:

```{r}
data_COVID %>% 
  filter(ID_ECS %in% ID_NAs) %>% 
  select(ID_ECS, FECHAFIN)
```


And we got that the ones missing are just four cases:

```{r}
ID_NAs_sub <- c(2802002,
                3100602,
                17801501,
                14300101)
```

We want to know how many information we have from these cases. Apparently, we
only have the year on `q1010_year`
```{r}
data_2019 %>% 
  filter(ID_ECS %in% ID_NAs_sub) %>% 
  select(ID_ECS, q1010_birth_date, q1011_age, q1010_year, q1010_month, q1010_day)
```

of these four, we know the value for `q1010_year` and we can make an approxima-
tion of the age based on this. We create a variable that has the actual birth
date for all cases on covid substudy but for the fourth missing cases, only the
year:

```{r}
birthday_COVID <- data_2019_test %>% 
  mutate(
    birthday_COVID = case_when(
      ID_ECS == ID_ECS_both  ~ q1010_birth_date,
      ID_ECS == ID_NAs_sub ~ q1010_year
    ) %>% 
      select(birthday_COVID)
  )
```


### Variables creation
```{r}
data_COVID_test <-
  data_COVID_test %>% 
  mutate(
    age_continuous = year(fechaCOVID) - year(birthday_COVID),
    age_cat = case_when(
           age_continuous < 18 ~ 1,
           age_continuous >= 18 & age_continuous <= 44 ~ 2,
           age_continuous >= 45 & age_continuous <= 64 ~ 3,
           age_continuous >= 65 & age_continuous <= 94 ~ 4, 
           age_continuous >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels = c("1", "2", "3", "4", "5",
                                     MISSING_DESIGN,
                                     REFUSED_ANSWER,
                                     NON_RESPONSE),
                          labels = c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```


### Checking new variables

```{r}
data_2019_test %>% 
  freq_table(age_cat)

data_2019_test %>% 
  select(age_continuous, age_cat, q1011_age, q1010_birth_date) %>% 
  View()
#¿Hay algunos casos en los que la edad continua es un número mayor que la 
#establecida?
```



## BRS (resilience scale)

We have to import this outcome (already created) from OneDrive.

```{r}
brsw2 <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_brief resilience scale_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            brsw2, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SM26")) %>% 
  colnames()
```


## SOCIAL SUPPORT (OSLO - 3) & LONELINESS

We have to import this outcome (already created) from OneDrive.

```{r}
socialsupw2 <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_loneliness and social support_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            socialsupw2, 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO9")) %>% 
  colnames()
```

```{r}
data_COVID_test %>% 
  select(num_range("SOLO7_", 1:3)) %>% 
  colnames()
```


## SOCIAL PARTICIPATION
This variable, SOLO2, is already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO2")) %>% 
  colnames()
```

## SUBSTANCE USE (alcohol)

```{r}
data_COVID_test %>% 
   select(starts_with("ALCOH1")) %>% 
   colnames()
```

##SUBSTANCE USE (TABACCO)

```{r}
data_COVID_test %>% 
   select(starts_with("FUM1")) %>% 
   colnames()
```
¿Hay puntuación compuesta?

## MENTAL HEALTH (depression)

We have to import this outcome (already created) from OneDrive.

```{r}
depression <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_depression_ICD10.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            depression, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with(c("SM8", "SM_3", "SM"))) %>% 
  colnames()
```


## MENTAL HEALTH (sucidality)
We have to import this outcome (already created) from OneDrive.

```{r}
suicidality <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_Suicidalideation.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            suicidality, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(SM9) %>% 
  colnames()
```



## NEGATIVE & POSITIVE AFFECT

We have to import this outcome (already created) from OneDrive.

```{r}
negposaffect <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_ positive and negative affect_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            negposaffect, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(num_range("SM22_", 1:5)) %>% #negative affect
  colnames()
```

```{r}
data_COVID_test %>% 
  select(num_range("SM22_", 6:7)) %>% #positive  affect
  colnames()
```

## QUALITY OF LIFE 

```{r}
data_COVID_test %>% 
  select(SM21) %>% 
  colnames()
```


## STRESSORS: sleep problems

```{r}
data_COVID_test %>%  
  select(num_range("SUE", 2:3)) %>% 
  colnames()
```


## STRESSORS: pain

```{r}
data_COVID_test %>%  
  select(num_range("DOLOR", 1:4), -DOLOR2) %>% 
  colnames()
```

## STRESSORS: Economy & unemployment

We have to import this outcome (already created) from OneDrive.

```{r}
economic <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_economic.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            economic, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(num_range("ECON", 4:5)) %>% 
  colnames()
```


## STRESSORS: COVID 
Five variables: infected, severity_raw, rel_isolated, rel_deceased, rel_concerned

We have to import this outcome (already created) from OneDrive.

```{r}
covidcc <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_ailment.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            covidcc, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("COVID")) %>% 
  colnames()
```


## STRESSORS: noise

```{r}
data_COVID_test %>% 
  select(starts_with("ECON1_1")) %>% 
  colnames()
```

## LIVING ALONE

We have to import this outcome (already created) from OneDrive.

```{r}
livingalone <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_social interactions_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one 
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            livingalone, 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO1_")) %>% 
  colnames()
```




# Step 3. Create new variables

## Lockdown stringency index

The file has got data from several countries. I only want to import the Spanish data.

```{r}
stringency_index <- 
  readr::read_csv("https://raw.githubusercontent.com/OxCGRT/covid-policy-tracker/master/data/OxCGRT_nat_latest.csv") %>% 
  filter(CountryCode == "ESP")
```

```{r}
stringency_index <- 
  stringency_index %>% 
  mutate(date = ymd(Date)) %>% 
  select(!Date)
```

Aquí lo que se hace es convertir la variable fecha en "date" para que coincida
con la variable "date" de stringency_index.
```{r}
data_2019_test %>% 
  mutate(date = as_date(`q0006_date`)) -> data_2019_test

data_COVID_test <- data_COVID_test %>% 
  mutate(date = lubridate::dmy('FECHAFIN')) #esto no funciona y no sé porqué

data_COVID_test$date <- lubridate::dmy(data_COVID_test$FECHAFIN)
```

```{r}
data_2019_test <- left_join(data_2019_test,
                    stringency_index,
                    by = "date")

data_COVID_test <- left_join(data_COVID_test,
                    stringency_index,
                    by = "date")

rm(stringency_index)
```
Ya hemos conseguido añadir este conjunto de variables. 

## Google Mobility
Descargamos el archivo .zip de los informes regionales de Google 
(https://www.google.com/covid19/mobility/). Nuestras olas son del año 
2019 y 2020, por lo que tenemos que guardar los datasets relativos a España
en esos dos ciclos. 

Como es el cambio de movilidad por el COVID, sólo hay
información relativa al 2020.

```{r}
mobility <- read.csv("~/workspace/2020_ES_Region_Mobility_Report.csv", stringsAsFactors = TRUE)
```

```{r collapse=TRUE}
mobility %>% 
  select(sub_region_1) %>% 
  table() # CCAA
mobility %>% 
  select(sub_region_2) %>% 
  table() # Province
```

En Edad con Salud sólo tenemos datos de Madrid y Barcelona. Este valor de
ciudad está codificado en los datasets originales como "origin". 

```{r}
mobility <- mobility %>% 
  filter(sub_region_2 %in% c("Barcelona") | sub_region_1 %in% c("Community of Madrid") )
```

Estas etiquetas no coinciden con las etiquetas en la variable `origin` ( 1 = bcn, 2 = MAD). Por tanto,
vamos a crear una nueva variable `province` en los dos datasets como en el
objeto `mobility`.

```{r}
data_2019_test %>% 
  select(origin) %>% 
  count(origin)

data_2019_test <- 
  data_2019_test %>%
  mutate(province = case_when(origin == 1 ~ "Barcelona",
                              origin == 2 ~ "Community of Madrid"))

data_COVID_test %>% 
  select(origin) %>% 
  count(origin)

data_COVID_test <- 
  data_COVID_test %>%
  mutate(province = case_when(origin == 1 ~ "Barcelona",
                              origin == 2 ~ "Community of Madrid"))
```

```{r}
str(data_2019_test$province)
str(data_COVID_test$province)
```
Habrá que unir el dataset "mobility" a través de ORIGIN en ambos datasets
(hacerlo cuando ya estén combinados).

## NUTS
Importamos el dataset obtenido en OBIBA/NUTS2021_nomenclature of territrial units
for statistics.

Tenemos que importar:
- Nuts provinces (NUTS 1 to 3)
- Nuts Urban - Rural
- Nuts Urban-rural remoteness
```{r}
nuts_provinces <- read_excel("~/workspace/NUTS2021.xlsx", 
                       sheet = "NUTS 1 to 3")
```

```{r}
nuts_urbanrural <- read_excel("~/workspace/NUTS2021.xlsx",
                              sheet = "Urban - Rural")
```

```{r}
nuts_urbanruralremoteness <- read_excel("~/workspace/NUTS2021.xlsx",
                                        sheet = "Urban-rural remoteness")
```

```{r}
nuts_provinces <- 
  nuts_provinces %>% 
  mutate(NUTS3 = str_replace_all("NUTS level 3",
                                   "'",
                                   ""),
         CODE  = str_replace_all("CODE 2021",
                                   "'",
                                   "")
  )
```

```{r collapse=TRUE}
str(nuts_provinces)
str(nuts_urbanrural)
str(nuts_urbanruralremoteness)
```

```{r}
nuts_provinces  <- 
  nuts_provinces %>% 
      rename(nuts_id = `Code 2021` ,
             province = `NUTS level 3`)

nuts_urbanrural <- 
  nuts_urbanrural %>% 
  rename(nuts_id = NUTS_ID,
         nuts_urbanrural_category = `URBAN-RURAL CATEGORY`,
         nuts_urbanrural_label = `URBAN-RURAL LABEL`)

nuts_urbanruralremoteness <- 
  nuts_urbanruralremoteness %>% 
  rename(nuts_id = `NUTS ID`,
         nuts_remoteness_category = `CATEGORY CODE`,
         nuts_remoteness_label = `CATEGORY LABEL`)

```

Succesive merging

```{r}
nuts_ds <- 
  left_join(nuts_provinces,
          nuts_urbanrural,
          by = "nuts_id") %>% 
  left_join(.,
            nuts_urbanruralremoteness,
            by = "nuts_id")
```


```{r}
rm(nuts_provinces,
   nuts_urbanrural,
   nuts_urbanruralremoteness)
```


```{r}
nuts_ds %>% 
  filter(province == "Madrid")

nuts_ds <-
  nuts_ds %>% 
  mutate(province = case_when(province == "Madrid" ~ "Community of Madrid",
                              TRUE ~ province))

nuts_ds %>% 
  filter(province == "Community of Madrid")
  
```

```{r}
df_2019 <- 
  left_join(data_2019_test,
            nuts_ds,
            by = "province")

df_covid <- 
  left_join(data_COVID_test,
            nuts_ds,
            by = "province")
rm(nuts_ds) 
```

Ya se han incluido las variables NUTS. 