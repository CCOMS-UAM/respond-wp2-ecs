---
title: "Edad con Salud WP2 dataset harmonization process"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), 'First created on 30 Sept. 2022. Updated on %d de %B de %Y')`"
output:
  html_document:
    df_print: paged
  toc: yes
  toc_float: yes
  html_notebook: null
institute: CCOMS, Universidad Autónoma de Madrid
editor_options:
  chunk_output_type: console
  markdown:
    wrap: 80
---

# Step 0. Preparation

## Overview

Here, I prepare the full Edad con Salud (2 assessment waves) database to be
uploaded to OPAL, as part of RESPOND WP2 IPD meta-analysis. I will follow the
[OPAL handbook for
WP2](https://drzmainz.sharepoint.com/:w:/r/sites/obiba-wp2/Shared%20Documents/harmonisation/data%20upload%20preparation/handbook_datauploadprep.docx?d=w15b8e9fe38734104a507dcedc3af3d49&csf=1&web=1&e=6Hu6Lm)

1.  Inspect the Cohort 2019 and COVID substudy databases.
2.  Harmonization process: 2.1. Create as many new variables as needed, as per
    the OPAL handbook for WP2, for 2019 cohort & COVID subestudy. 2.2. Transform
    variables that require transformation outside the OBIBA environment
    (sensitive data) 2.3. Recode missing data
3.  Merge all the assessment waves in a dataset with a number of rows equal to
    wavesBYparticipants.
4.  Remove all columns that are not included in the RESPOND WP2 codebook.
5.  Create a new hashed ID and remove the old one.
6.  Export a .csv file to be uploaded to OPAL.

## Required libraries

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
library(lubridate)
library(naniar)
library(stringi)
library(readstata13)
library(readxl)
library(ecs.data)
library(utf8)
library(digest)
library(forcats)
```

## Constants on variable harmonization

*Coding of missing values:*

-   -991 specifies a variable has not been assessed in general (e.g., at this
    point of data collection), so it is missing by design.

-   -992 specifies 'refused to answer' NAs

-   -993 specifies missings (default) from data collections that actually took
    place (eg, this exact questionnaire had been assessed at this timepoint, but
    the participant did not answer for whatever reason).

```{r constants}
MISSING_DESIGN <- -991
REFUSED_ANSWER <- -992 #999
NON_RESPONSE <- -993 #888

BASELINE_FILEPATH <- file.path(read_ecs_folder("DB"),
                               "Ola_3/Cohorte_2019/rawdata_c2019w1.dta")
COVID_FILEPATH <- file.path(read_ecs_folder("DB"),
                            "Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")
```

## Data importation

Data is extracted from the OneDrive folders `Bases de datos maestras`. For
RESPOND WP2, the used folders are `Cohort 2019`and `COVID Substudy`. Files are
in .dta format, which is a double format. It contains:

-   the variable type (class)
-   the label (label, part of the metadata)

For ease of work, it is necessary to make variable transformations so that
`value-label` does not interfere, as it doesn't say anything about the
categorical or continuous consideration of the variables.

**Before doing the data analysis it is required to convert the vectors with**
**`value_labels`** into factors, numeric or character vectors. To do this, it is
possible to use `unlabelled()`, `to_factor()` o `unclass()` before data cleaning
or after that, to keep the info in the export process.

The original databases are then imported and copies are created for testing
purposes.

```{r data-importation}
data_2019 <- read_dta(BASELINE_FILEPATH, encoding = "UTF-8")
data_COVID <- read_dta(COVID_FILEPATH, encoding = "UTF-8")
```

# Step 1. Data inspection

## Checking columns

We check that the variable names are correct, if there are duplicate columns and
if the column names of each wave are unique. This should be the case because of
the nature of the coding of the `Edad con Salud` interviews.

```{r}
raw_2019_colnames <- colnames(data_2019)
raw_COVID_colnames <- colnames(data_COVID)
```

```{r}
intersect(raw_2019_colnames, raw_COVID_colnames)
```

```{r}
print(raw_2019_colnames[duplicated(raw_2019_colnames)])
print(raw_COVID_colnames[duplicated(raw_COVID_colnames)])
```

The variables common to both datasets are `ID_ECS` and `origin`. `ID_ECS` would
be the key variable to join both datasets. There are no duplicates on each
dataset and everything looks perfectly fine on this respect.

```{r}
rm(raw_2019_colnames)
rm(raw_COVID_colnames)
```

## Checking rows

There's one case on COVID substudy that is not on baseline wave. We have to
remove it. Firstly, we detect it using anti_join():

```{r}
id_ecs_subs_notBL <- data_COVID %>%
  anti_join(data_2019, by = "ID_ECS") %>%
  select(ID_ECS) %>% pull()
```

And then we remove it (is ID_ECS == 6900702)

```{r}
data_COVID <- data_COVID %>%
  filter(ID_ECS != id_ecs_subs_notBL)
```

```{r}
rm(id_ecs_subs_notBL)
```

Now we duplicate both datasets for testing purposes:

```{r}
data_2019_test <- data_2019
data_COVID_test <- data_COVID
```

## Follow-up cases

In order to know which cases are in both waves, we use semi_join:

```{r}
# id_ecs_both <- data_COVID_test %>%
#                semi_join(data_2019_test, by = "ID_ECS") %>% 
#                select(ID_ECS) %>% 
#                pull()
```

On the other hand, we need to make sure that each unique ID is represented two
times in the dataset, regardless of whether they completed one or both
assessment waves. As we are harmonizing wave by wave, this has to be added on
the COVID substudy database.

```{r}
unique_ids <- data_2019 |>
  select(ID_ECS) |>
  group_by(ID_ECS) |>
  summarise(n = n()) |> select(ID_ECS)
```

```{r}
data_COVID_test <- right_join(data_COVID_test,
                              unique_ids,
                              by = "ID_ECS")
```

## Identifying waves

Wave 1 (baseline):

```{r}
data_2019_test <- data_2019_test %>%
  add_column(wave = 1, .after = "ID_ECS")

data_2019_test <-
  data_2019_test |> select(ID_ECS, wave, everything())  
```

Wave 2 (COVID):

```{r}
data_COVID_test <- data_COVID_test %>%
  add_column(wave = 2, .after = "ID_ECS")

data_COVID_test <-
  data_COVID_test |> select(ID_ECS, wave, everything()) 
```

## Adjusting date format

Date format is important because we are using this variables to create some of
the required variables for RESPOND WP2.

```{r dates-format}
data_2019_test <- data_2019_test %>%
  mutate(
    q0006_date = lubridate::ymd(q0006_date),
    q1010_birth_date = lubridate::ymd(q1010_birth_date)
  )

data_COVID_test <- data_COVID_test %>%
  mutate(FECHAFIN = as_factor(FECHAFIN),
         FECHAFIN = lubridate::dmy(FECHAFIN)) 
```

# Step 2. Wave 1 harmonization

Variables to be harmonized are the following:

-   Gender
-   coresidence
-   Migration
-   Age: categorical
-   Age: continuous
-   Employment status
-   Type of contract
-   Employment type
-   Healthcare workers
-   Profession
-   Education
-   Relationship status
-   Children
-   Children household
-   Number of children
-   Living alone
-   Household
-   Income quartiles
-   Income quintiles
-   NUTS code - left for when we have both waves harmonised

## 2.1. Gender

**Self-identified gender**

-   1: male
-   2: female
-   3: other/diverse
-   -991: not assessed
-   -992: refused to answer
-   -993: missing (default)

Our categories are:

-   1 = male;
-   2 = female (the question is not about the self-identified gender, but sex).

### Variable exploration

```{r}
data_2019 %>%
  freq_table(q1009_sex)

data_2019 %>%
  select(q1009_sex) %>%
  summarise_all( ~ sum(is.na(.)))
```

### Variable harmonization

In this case we simply rename this variable and convert it into a factor,
changing the labels as the values match between the two categorizations.

```{r}
data_2019_test <- data_2019_test %>%
  mutate(gender = factor(
    x = q1009_sex,
    levels = c("1", "2", "3", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
    labels = c(
      "male",
      "female",
      "other/diverse",
      MISSING_DESIGN,
      REFUSED_ANSWER,
      NON_RESPONSE
    )
  ))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(gender)
```

## 2.2 Country of residence

There's no variable from which to create, but knowing that all participants are
from Spain, we can do it from scratch. This variable should be complemented with
the NUTS code (see below/later on on this script).

### Variable harmonization

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(coresidence = "ES",
         coresidence = factor(
           coresidence,
           levels = c("ES", MISSING_DESIGN,
                      REFUSED_ANSWER,
                      NON_RESPONSE),
           labels = c("ES",
                      MISSING_DESIGN,
                      REFUSED_ANSWER,
                      NON_RESPONSE)
         ))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(coresidence)
```

## 2.3. Migration

**Country of birth other than country of residence**:

-   1 = Yes
-   2 = No
-   3 = No information
-   -991 = missing by design
-   -992 = refused to answer
-   -993 = missing (default)

Our variable in EcS `q1018_country` has registered the name of each country. As
we did the sample collection in Spain, we can assume that responses that are
different than Spain are indicators of migration.

### Variable exploration

```{r}
data_2019 %>%
  select(q1018_country) %>%
  summarise_all( ~ sum(is.na(.))) #No NAs

data_2019 %>%
  freq_table(q1018_country) # 1 = Spain, !1 = other countries
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    migration = if_else(q1018_country == 1, 2, 1),
    migration = factor(
      x = migration,
      levels = c("1", "2", "3", MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE),
      labels = c(
        "yes",
        "no",
        "no information",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(migration)
```

## 2.4. & 2.5. Age

The variable `age_continuous` is a continuous variable (1-100). `age_cat` is the
categorical version with the following levels:

-   \< 18
-   18 - 44
-   45 - 64
-   65 - 94
-   \> 95

### Variable exploration

To create these variables we are going to use `q1010_birth_date` and `q1011_age`
because there are some IDs that their information on birthdate is lost. Firstly,
we create a vector that contains those IDs.

```{r}
ID_NAs <- c(
  18702401,
  5600601,
  3100602,
  18702701,
  2802002,
  17801501,
  16602601,
  5800201,
  19600501,
  3300201,
  7101202,
  7101401,
  14300101,
  16800301
) 
```

For those cases, we have the correct information on variables `age` and
`q1010_year` (birthdate - year).

```{r}
data_2019 %>%
  filter(ID_ECS %in% ID_NAs) %>%
  select(q1010_birth_date,
         q1011_age,
         q1010_year,
         q1010_month,
         q1010_day)
```

### Variables' creation

The next steps were followed:

1.  Create the difference in years between birth-date and 2019 interview date
    (in years).

2.  Create `age_continuous`: if we have the complete information, use the
    difference between birth-date and interview date (`q0006_date`) just created
    to establish the age of the participants; if this data is missing, use
    `q1011_age`. We use floor() to rounding up to the participant's current
    integer years.

3.  Create `age_cat` by recategorizing `age_continuous`.

```{r}
#Age at the time the interview was done (in years)
bl_time <- data_2019_test %>%
  mutate(bl_time = q1010_birth_date %--% q0006_date,
         #año-mes-dia
         bl_time = bl_time / years()) %>% select(bl_time) %>% pull()
```

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    age_continuous = if_else(ID_ECS %in% ID_NAs, q1011_age,
                             bl_time),
    age_continuous = floor(age_continuous),
    age_cat = case_when(
      age_continuous < 18 ~ 1,
      age_continuous >= 18 & age_continuous <= 44 ~ 2,
      age_continuous >= 45 & age_continuous <= 64 ~ 3,
      age_continuous >= 65 & age_continuous <= 94 ~ 4,
      age_continuous >= 95 ~ 5
    ),
    age_cat = factor(
      x = age_cat,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "below 18 years",
        "18-44",
        "45-64",
        "65-94",
        "95 years or older",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )

```

### Checking new variable

```{r}
#Check the "estimated age" matches with q1011_age even in the cases that we don't have q1010_birth_date
data_2019_test %>%
  freq_table(age_cat)

data_2019_test %>%
  select(age_continuous, age_cat, q1011_age, q1010_birth_date)


data_2019_test %>% filter(ID_ECS %in% ID_NAs) %>%
  select(ID_ECS, age_continuous, age_cat, q1011_age, q1010_birth_date)
```

## 2.6. Employment status (`q1503_work_now` & `q1504_reason`.)

**Employment status** has the following levels:

-   1 = Have a job (employed or self-employed)
-   2 = In education
-   3 = Care work (family) / homeworker/ on parental leave
-   4 = On long-term sick leave/disability
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
-   6 = unemployed or job-seeking
-   7 = retired
-   -991 = not assessed
-   -993 = missing (default)

`q1503_work_now` (c2019_w1) *Currently working?*:

-   1 = Yes
-   2 = No

`q1504_reason` (c2019_w1) *Reason not working*:

-   1 = homemaker
-   2 = couldn't find a job
-   3 = unpaid/voluntary
-   4 = studies/training
-   5 = health
-   6 = care family
-   7 = no need
-   8 = not permitted
-   9 = retired/too old
-   10 = laid off
-   11 = seasonal work
-   12 = does not want to for a while
-   13 = vacation/sick or maternity leave
-   87 = other.

As a proposal, the re-categorization to be done has to be:

-   1 = Have a job (employed or self-employed) == `1 (q1503_work_now)`
-   2 = In education (currently studying) == `4 (q1504_reason)`
-   3 = Care work (family) / homeworker / on parental leave == `1, 6`
    `(q1504_reason)`\*\*
-   4 = On long-term sick leave/disability == `5 (health) (q1504_reason)`,
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
    (other) == `3 (unpaid/voluntary), 7 (no need), 8 (not permitted), 11,`
    `12 (does not want to for a while), 13, 87 (other)`
-   6 = unemployed or job-seeking == `2 (couldn't find a job), 10 (laid off)`,
    `11 (seasonal work)`,
-   7 = retired == `9 (retired/too old)`

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    employment_st = case_when(
      q1503_work_now == 1 ~ 1,
      #have a job
      q1504_reason == 4 ~ 2,
      #studying
      q1504_reason == 1 | q1504_reason == 6 ~ 3,
      #care work
      q1504_reason == 5 ~ 4,
      # on long term sick leave disability
      q1504_reason == 3 |
        q1504_reason == 7 |
        q1504_reason == 8 |
        q1504_reason == 11 |
        q1504_reason == 12  |
        q1504_reason == 13 | q1504_reason == 87 ~ 5,
      #other reasons
      q1504_reason == 2 |
        q1504_reason == 10 | q1057 == 11 ~ 6,
      #unemployed or job-seeking
      q1504_reason == 9 ~ 7,
      #retired,
      is.na(q1504_reason) |
        is.na(q1503_work_now) ~ NON_RESPONSE
    ),
    employment_st = factor(
      x = employment_st,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "have a job (employed or self-employed)",
        "in education",
        "care work (family) / homeworker/ on parental leave",
        "on long-term sick leave/disability",
        "unable to work due to reasons not mentioned elsewhere in this list",
        "unemployed or job-seeking",
        "retired",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>%
  select(employment_st) %>%
  freq_table(employment_st)
```

## 2.7. Contract (q1510b_contract_earner)

**Permanent/temporary contract**

Changes made after consulting with IPD-Respond team:

-   1 officer ===== 1 permanent
-   2 indefinite period (not officer) ===== 4 (other)
-   3 temporal or contract of works and services ===== 2 temporary
-   4 verbal or without contract ===== 4
-   888 DK ===== -993
-   999 refused to answer ===== -992

### Variable exploration

```{r}
data_2019 %>%
  select(q1510b_contract_earner) %>%
  summarise_all(~ sum(is.na(.))) #741

data_2019 %>%
  freq_table(q1510b_contract_earner)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    contract = case_when(
      q1510b_contract_earner == 1 ~ 1,
      #officer --> permanent
      q1510b_contract_earner == 3  ~ 2,
      #temporal or contract of works and services --> temporary
      q1510b_contract_earner == 4 |
        q1510b_contract_earner == 2 ~ 4,
      #verbal or without contract & indefinite period (not officer) --> other
      q1510b_contract_earner == 888 ~ NON_RESPONSE,
      q1510b_contract_earner == 999 ~ REFUSED_ANSWER,
      is.na(q1510b_contract_earner) ~ NON_RESPONSE
      
    ),
    contract = factor(
      x = contract,
      levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "permanent",
        "temporary",
        "self-employed",
        "other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(contract)
```

## 2.8. Employment type (`q1510_workday`)

-   1 - Full time
-   2 - Part time
-   3 - No paid work
-   4 - Other
-   -991 not assessed
-   -992 refused to answer
-   -993 missing (default)

In EcS (`q1510_workday`):

-   1 Part time (morning and afternoon) ===== 2
-   2 Continuous morning working day ===== 1
-   3 Continuous afternoon working day ===== 1
-   4 Continuous night working day ===== 1
-   5 Reduced work day ===== 4
-   6 Shift work / irregular or variable work ==== 4
-   7 Other type ==== 4
-   888 DK ==== -992

### Variable exploration

```{r}
data_2019 %>%
  select(q1510e_workday) %>%
  summarise_all( ~ sum(is.na(.)))

data_2019 %>%
  freq_table(q1510e_workday)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    employment_ty = case_when(
      q1510e_workday == 1 ~ 2,
      #part time --> part time
      q1510e_workday == 2 ~ 1,
      #continuous morning working day --> full time
      q1510e_workday == 3  ~ 1,
      #continuous afternoon working day --> full time
      q1510e_workday == 4 ~ 1,
      #continuous night working day --> full time
      q1510e_workday == 5 ~ 4,
      #reduced work day --> other
      q1510e_workday == 6 ~ 4,
      #shift work --> other
      q1510e_workday == 7 ~ 4,
      #other --> other
      q1510e_workday == 888 ~ REFUSED_ANSWER,
      is.na(q1510e_workday) ~ NON_RESPONSE
      
    ),
    employment_ty = factor(
      x = employment_ty,
      levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "Full time",
        "Part time",
        "No paid work",
        "Other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(employment_ty)
```

## 2.9. HC worker

\*defined as: *A healthcare worker is anyone who works in a healthcare or
social* *care setting, including healthcare students on clinical placement,
frontline* *healthcare workers and other healthcare workers not in direct
patient contact.*

*These settings include, but are not limited to, state-funded and private*
*organisations providing services in the following areas: disability, older*
*persons, nursing homes, acute and non acute hospitals, community hospitals,*
*mental health, social inclusion, palliative care, chronic illness, primary
care* *(GP, dental, pharmacies, physiotherapy clinics), health and well being,
hospice,* *rehabilitation, home care, paramedics, and community services (e.g.
youth,* *substance abuse, suicide prevention, community development).*

HC_worker has to be a dichotomous variable that indicates if a participants fits
in the previous definition (1 = yes; 2 = no). In EcS we have `q1510_occ`on base-
line, which indicates in a free-text variable the occupation of the
participants. `q1510_catoccu` uses the CIUO-08 (ISCO codes from OIT) from
categorize the occupations of the participants.

To proceed, we follow the next steps:

1.  Explore unique values of this variable & see if `q1510_catoccu`is useful.
2.  Extract patterns that are of our interest.
3.  Create the new variable.

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_occ, q1510_catoccu) %>%
  summarise_all( ~ sum(is.na(.)))
#Both variables has the same NAs,
#only is just that on the free-text variable, NAs looks like "".
```

```{r}
occ_unique <- data_2019 %>%
  select(q1510_occ) %>%
  distinct()  
```

There are 1824 unique values for this variable and 347 NAs (in both variables;
in free-text they appear as ""). This would be useful in order to process the
variable"profession" later on.

`q1510_catoccu`indicates the categorization of the 10 main groups, but not the
subcategories, which are the ones that could be interesting for us to use. We'll
try if using it as a filter is useful.

Barely it does, as the principal category of our interest leaves out interesting
occupations (e.g., *auxiliar de enfermería*), which are on groups 2, 3, 7, 8. As
it doesn't allow us to differentiate health care workers from other
professionals, we'll just work with `q1510_occ`and explore manually all the
free-text unique values. The ones that are interesting for us are on
`"HC_workersCat.txt"`.

To facilitate pattern detection, we convert to lowercase all the values of
`q1510_occ` using `str_to_lower()`de `stringr`. To eliminate accents,
`stri_trans_general(x, "Latin-ASCII")`.

```{r}
data_2019_test %>%
  mutate(
    q1510_occ_utf8 = as_utf8(q1510_occ),
    q1510_occ_utf8 = str_to_lower(q1510_occ_utf8, locale = "spa"),
    q1510_occ_itf8 = stringi::stri_trans_general(q1510_occ_utf8, "Latin-ASCII")
  ) %>%
  select(q1510_occ, q1510_occ_utf8) 

#As a promising approach that we are not following due to resources limit
```

### Variable creation

Import the .txt that has all the responses to create HC_workers:

```{r}
library(readr)
occ_unique <- read_delim(
  "./dat/HC-workerCat.txt",
  #"C:/Users/Cristina/Downloads/HC-workerCat.txt"
  delim = "\t",
  escape_double = FALSE,
  col_names = FALSE,
  trim_ws = TRUE
)
```

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    hc_worker = if_else(q1510_occ %in% occ_unique$X1, 1, 2),
    hc_worker = factor(
      x = hc_worker,
      levels = c("1", "2",
                 MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE),
      labels = c("yes",
                 "no",
                 MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE)
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(hc_worker)
```

## 2.10. Profession (q1510_catoccu)

**Best description of current occupation(s)** We will include this variable in
raw format in the database just for knowing levels of OIT categorization rather
than sector. Following recommendations of IPD-RESPOND team, we would try to keep
assumptions to a minimum and when in doubt, code things as other:

-   1 Legislators === 7 (civil services, politics)
-   2 Professionals === 14 (others)
-   3 Technicians ==== 14 (others)
-   4 Clerks ===== 12 (installation, maintenance, cleaning and repairs)
-   5 Service workers ==== 5 (first responder: paramedic/firefighter/police)
-   6 Skilled agricultural workers ==== 14 (others)
-   7 Craft workers ==== 14 (others)
-   8 Plant operators ==== 14 (other)
-   9 Elementary occupations ==== 14 (others)
-   10 Armed forces === 6 (military)

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_catoccu) %>%
  summarise_all( ~ sum(is.na(.)))

data_2019 %>%
  freq_table(q1510_catoccu) 
```

### Variable creation

```{r}
#Creating variable
data_2019_test <-
  data_2019_test %>%
  mutate(
    profession = case_when(
      #service workers --> first responders: paramedic/firefighter/police
      hc_worker == "yes" ~  4,
      #hc_worker = healthcare
      q1510_catoccu ==  5 ~ 5,
      q1510_catoccu ==  10  ~  6 ,
      #armed forces --> military
      q1510_catoccu ==  1  ~  7 ,
      #legislators --> civil services, politics
      q1510_catoccu ==  4  ~  12 ,
      #clerks --> installation, maintenance, cleaning and reparis
      q1510_catoccu ==  8 |
        q1510_catoccu ==  3 |
        q1510_catoccu ==  6 |
        q1510_catoccu ==  7 |
        q1510_catoccu ==  9 |
        q1510_catoccu ==  2  ~  14,
      #others
      is.na(q1510_catoccu) ~ NON_RESPONSE
      
    ),
    profession = factor(
      x = profession,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "undergoing education",
        "education and research",
        "arts, entertainment, sports and media",
        "healthcare",
        "first responder (paramedic/firefighter/police)",
        "military",
        "civil services, politics",
        "finance and economy",
        "industry",
        "sales and services (incl. restaurants and bars)",
        "transport (goods and people)",
        "installation, maintenance, cleaning, and repairs",
        "currently not working",
        "other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(profession)
```

The vast majority is classified as "other" (1897/3002). It is not a very useful
variable; it requires to work with free-text variables.

## 2.11. Education (q1016_highest)

**Highest level of education according to ISCED Classification**:

-   1 = primary/basic: (primary education and lower secondary education)
-   2 = secondary/intermediate: (upper secondary education, post-secondary
    non-tertiary education)
-   3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or
    equivalent level, master's or equivalent level, doctoral or equivalent
    level)
-   4 = no formal education / less than basic (no schooling, early childhood
    education)
-   -991 = not assessed
-   -993: level not stated - if following yellow box, if not, NON_RESPONSE

Our variable, `q1016_highest`, has as levels (doesn't have *non-tertiary
education*):

-   0 = No formal education
-   1 = Primary education not completed
-   2 = Primary education completed
-   3 = Lower secondary education completed
-   4 = Upper secondary education completed
-   5 = University/college completed
-   6 = Master degree, PhD completed
-   888 = don't know

As a proposal, I suggest:

-   1 = primary/basic --\> 1, 2, 3
-   2 = secondary/intermediate --\> 4
-   3 = tertiary/advanced --\> 5, 6
-   4 = no formal education / less than basic: 0

## Variable exploration

```{r}
data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(~sum(is.na(.))) #No NAs, but 888 as DK.

data_2019 %>% 
  freq_table(q1016_highest)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    education = case_when(
      q1016_highest == 0 ~ 4,
      q1016_highest == 1 |
        q1016_highest == 2 | q1016_highest == 3 ~ 1,
      q1016_highest == 4 ~ 2,
      q1016_highest == 5 | q1016_highest == 6 ~ 3,
      q1016_highest == 888 ~ NON_RESPONSE,
    ),
    education = factor(
      x = education,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "primary/basic",
        "secondary/intermediate",
        "tertiary/advanced",
        "no formal education",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(education)
```

## 2.12. Relationship status (q1012_mar_stat)

**Relationship status** is a categorical variable with the following levels:

-   1 = Single
-   2 = Married /in a civil union
-   3 = in a relationship and living together
-   4 = in a relationship and living apart
-   5 = divorced/separated
-   6 = widowed
-   7 = other

Our variable `q1012_mar_stat` is coded as:

-   1 = never married (and no cohabiting)
-   2 = currently married/law-partner
-   3 = cohabiting
-   4 = separated/divorced
-   5 = widowed

As the categories doesn't match exactly, I propose the following categorisation:

-   1 = single --\> 1 (never married and no cohabiting)
-   2 = married / in a civil union --\> 2 (currently married/law-partner)
-   3 = in a relationship and living together --\> 3 (cohabiting)
-   4 = in a relationship and living apart --\> MISSING_DESIGN
-   5 = divorced/separated --\> 4 (separated/divorced)
-   6 = widowed --\> 5 (widowed)
-   7 = other --\> MISSING_DESIGN

### Variable exploration

```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(~sum(is.na(.))) #No NAs

data_2019 %>%
  freq_table(q1012_mar_stat)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    relationship = case_when(
      q1012_mar_stat == 1 ~ 1,
      q1012_mar_stat == 2 ~ 2,
      q1012_mar_stat == 3 ~ 3,
      q1012_mar_stat == 4 ~ 5,
      q1012_mar_stat == 5 ~ 6,
    ),
    relationship = factor(
      x = relationship,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "single",
        "married/in a civil union",
        "in a relationship and living together",
        "in a relationship and living apart",
        "divorced/separated",
        "widowed",
        "other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(relationship)
```

## 2.13. Children

**Do you have children, live with children or take care of children in your**
**household?**

-   1 = yes
-   2 = no

Our variables `q1056` & `q1058` ask about biological and adopted children
(separatedly) (1 = yes; 2 = no). We'll combine both in a single variable.

### Variable exploration

```{r}
data_2019 %>%
  select(q1056, q1058) %>%
  summarise_all( ~ sum(is.na(.))) #No NAs

data_2019 %>%
  freq_table(q1056) #1 = yes (2241); #2 = no (761)

data_2019 %>%
  freq_table(q1058) #1 = yes (24); #2 = no (2978)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    children = case_when(q1056 == 1 | q1058 == 1 ~ 1,
                         q1056 == 2 | q1058 == 2 ~ 2),
    children = factor(
      x = children,
      levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c("yes",
                 "no",
                 MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE)
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(children) #2253 = yes; 749 = no  
```

## 2.14. Children household

**Are there children in your household?**

-   1 = yes
-   2 = no

This variable should be created based on the Cohort 2019 (wave 1) variables:
`q0407_age_01:q0407_age_010`, as they indicate how many members with different
ages are in the participants' household.

### Variable exploration

```{r}
data_2019 %>%
  select(q0407_age_01:q0407_age_10) %>%
  summarise_all( ~ sum(is.na(.))) #A lot of NAs

data_2019 %>%
  select(q0407_age_01:q0407_age_10) %>%
  glimpse()
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    children_hh =
      case_when(
        q0407_age_01 < 18 |
          q0407_age_02 < 18 |
          q0407_age_03 < 18 |
          q0407_age_04 < 18 |
          q0407_age_05 < 18 |
          q0407_age_06 < 18 |
          q0407_age_07 < 18 |
          q0407_age_08 < 18 |
          q0407_age_09 < 18 | q0407_age_10 < 18 ~ 1,
        
        q0407_age_01 >= 18 |
          q0407_age_02 >= 18 |
          q0407_age_03 >= 18 |
          q0407_age_04 >= 18 |
          q0407_age_05 >= 18 |
          q0407_age_06 >= 18 |
          q0407_age_07 >= 18 |
          q0407_age_08 >= 18 |
          q0407_age_09 >= 18 | q0407_age_10 >= 18 ~ 2,
        
        
        is.na(q0407_age_01) |
          is.na(q0407_age_02) |
          is.na(q0407_age_03) |
          is.na(q0407_age_04) |
          is.na(q0407_age_05) |
          is.na(q0407_age_06) |
          is.na(q0407_age_07) |
          is.na(q0407_age_08) |
          is.na(q0407_age_09) | is.na(q0407_age_10) ~ NON_RESPONSE
      ),
    children_hh = factor(
      x = children_hh,
      levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c("yes",
                 "no",
                 MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE)
    )
  )
```

### Checking new variable

```{r}
freq_table(data_2019_test, children_hh) 
```

## 2.15. Number of children (q1057/q1059)

Same as the previous one, this variable indicates in a continuous way **How**
\_\_many children do you have? (including children who are not your own but live
in the same household or who do you care for in your household?)

-   1 = no children
-   2 = one child
-   3 = two or three
-   4 = four or more

In EcS there's a difference made between biological and adopted children (1+,
DK). Our proposal is to combine both.

### Variable exploration

```{r}
data_2019 %>%
  select(q1057, q1059) %>%
  summarise_all( ~ sum(is.na(.))) #NAs

data_2019 %>%
  freq_table(q1057)

data_2019 %>%
  freq_table(q1059) 
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    q1057_NA = replace_na(q1057, 0),
    q1057_NA = na_if(q1057_NA, 888),
    q1059_NA = replace_na(q1059, 0),
    add_children = q1057_NA + q1059_NA,
    
    
    nofchildren = case_when(
      add_children == 0 ~  1,
      #no children
      add_children == 1 ~ 2,
      #one children
      add_children == 2 |
        add_children == 3 ~ 3,
      #two or three children
      add_children >= 4 ~ 4,
      # four or more,
      is.na(add_children) ~ NON_RESPONSE
      
    ),
    nofchildren = factor(
      x = nofchildren,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "no children",
        "one child",
        "two or three",
        "four or more",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(nofchildren)
```

## 2.16. Living alone

**Do you live alone or together with others?** - 1 = alone - 2 = not alone

ECS has `q0401_hh_total`, which is a continuous variable from 1 to 10.

### Variable exploration

```{r}
data_2019 %>%
  freq_table(q0401_hh_total)

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all( ~ sum(is.na(.))) #No NAs
```

### Variable creation

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    living_alone = if_else(q0401_hh_total == 1, 1, 2),
    living_alone = factor(
      x = living_alone,
      levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "alone",
        "not alone",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(living_alone)
```

## 2.17. Household size

**How many people, including yourself, live in your household?**

-   1: one person
-   2: two persons
-   3: three or four persons
-   4: five or more persons
-   5: live in an institution

Variable `q0401_hh_total` reflects the number of people (1-10 to 10 people). In
ECS there's no case that lives in an institution - so category no 5 won't have
any case on our sample.

### Variable exploration

```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(~sum(is.na(.))) #No NAs

data_2019 %>%
  freq_table(q0401_hh_total) 
```

### Variable creation

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    hh_size = case_when(
      q0401_hh_total == 1 ~ "1",
      q0401_hh_total == 2 ~ "2",
      q0401_hh_total == 3 ~ "3",
      q0401_hh_total == 4 ~ "3",
      q0401_hh_total >= 5 ~ "4"
    ),
    
    hh_size = factor(
      x = hh_size,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "one person",
        "two persons",
        "three or four persons",
        "five or more persons",
        "live in an institution",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  group_by(hh_size) %>%
  pivot_longer(hh_size, names_to = "size", values_to = "value") %>%
  select(size, value) %>%
  distinct() %>%
  arrange(size, value) %>%
  print(n = 150)


data_2019_test %>%
  freq_table(hh_size)
```

## 2.18. Quartiles & quintiles

Quartiles and quintiles have to be created from baseline cohort. We'll sum all
the variables that collect data on income:

-   `q0410g_total`: gross personal income of all members of your family during
    the last 12M.
-   `q0410i_ss`: gross household income during the last 12M from the retirement
    pension.
-   `q0410j_government`: gross household income (...) from official programs
    (unemployment, dependent children, widows, widowers, orphans, general
    assistance, ...).
-   `q0410k_other`: from private sources (pensions, investments, alimony or
    maintenance).

We have to take into account:

-   The characteristics of the double format of database variables in Stata make
    it necessary to do some previous transformations to be able to handle it
    properly.

-   The NAs for each variable result in a number of NAs different from the
    number of NAs for each of these variables separately.

### Variable exploration

All variables have 91 NAs (proxy respondents). But the numbers of `888`(don't
know) and `999` (refuse) could be different.

```{r}
data_2019 %>% 
  freq_table(q0410g_total) %>% 
  print(n = 50) #888 = 371; 999 = 819; 91 = NAs
```

```{r}
data_2019 %>% 
  freq_table(q0410i_ss) %>% 
  print(n = 50) #888 = 267; 999 = 824; 91 = NAs. Most of the sample are in '1' & '2'
#but not much; 321 + 645
```

```{r}
data_2019  %>% 
  freq_table(q0410j_government) %>% 
  print(n = 50) #888 = 371; 999 = 819; 91 = NAs. Most of the sample are in '1' & '2'
```

```{r}
data_2019  %>% 
  freq_table(q0410k_other) %>% 
  print(n = 50) #888 = 291; 999 = 710; 91 = NAs. Most of the sample are in '1' & '2'
```

More people do not want to answer than do not answer because they do not know.
If we explore the NAs pattern (excluding -91 as they are proxy respondents) we
can say that:

```{r}
g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total), width = 30) +
  xlim(800, 1200)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss), width = 30) +
  xlim(800, 1200)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government), width = 30) +
  xlim(800, 1200)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other), width = 30) +
  xlim(800, 1200)

grid.arrange(g1, g2, g3, g4)
```

```{r}
rm(g1, g2, g3, g4)
```

We need to make decisions to manage the values of these variables. First we
explore the distribution of possible response combinations.

<!-- # ```{r} -->
<!-- # temp %>% filter(if_any(everything(), `==`, "valid")) -->
<!-- #  -->
<!-- # ``` -->
<!-- #  -->
<!-- # ```{r} -->
<!-- # temp %>% filter(q0410g_total_rec == "valid") %>% count(wt = n) -->
<!-- # ``` -->

The pattern of NAs (999 and 888) is very similar.

We assume that most of the respondents' income will be in what they answer in
item `q0410g_total`. Therefore, if in this variable we find a "valid" response,
in the following ones, the don't know or refuse will become 0.

If in this variable the answer is "don't know" or "refuse", a decision will be
made for the cases depending on which type of answer has been given to a greater
extent. Thus, if in "total": - we have a response that is a "don't know" and we
find that same response in another variable, we classify it as "don't know" in
the final sum; - If we have an answer that is "refuse" and we find that same
answer in another variable, we classify it as "refuse" in the final sum.

### Variable recoding

These variables are originally factor variables with a value of a number from 1
to 33 and a label indicating the median value of the established range.

We have, therefore, to convert these factor variables into numeric variables
whose values are the information of the median of the established range
(currently they are there as labels). To do this, we will:

-   recode them into the respective medians,
-   change their format,
-   change the value of the NAs to what was agreed in RESPOND,
-   convert the missing values into NAs in order to be able to do the sum,
-   sum
-   and divide by quintiles and convert the NAs into their original values.

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE, 
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )
```

As factors can't be summed, we have to convert these variables in character, and
then in integer.

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    across(q0410g_total_r:q0410k_other_r, as.character),
    across(q0410g_total_r:q0410k_other_r, as.integer),
    q0410g_total_r_NA = q0410g_total_r,
    q0410i_ss_r_NA = q0410i_ss_r,
    q0410j_government_r_NA = q0410j_government_r,
    q0410k_other_r_NA = q0410k_other_r,
    across(q0410g_total_r:q0410k_other_r, ~ na_if(., NON_RESPONSE)),
    across(q0410g_total_r:q0410k_other_r, ~ na_if(., REFUSED_ANSWER)),
    across(q0410g_total_r:q0410k_other_r, ~ coalesce(., 0)),
    hh_income_r = q0410g_total_r + q0410i_ss_r + q0410j_government_r + q0410k_other_r
  )
```

### Variable creation

```{r}
data_2019_test %>%
  freq_table(hh_income_r) %>% print(n = 168)
```

We have 99 NAs, including MISSING_DESIGN and NON_RESPONSE.

```{r}
quartiles19 <- c(9816, 15015, 22024)
quintiles19 <- c(8847, 12997, 17422, 24104)
```

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    hhquartile = case_when(
      hh_income_r >= 0 & is.na(q0410j_government) &
        is.na(q0410k_other) &
        is.na(q0410i_ss) ~ MISSING_DESIGN,
      hh_income_r >= 0 &
        (
          q0410i_ss_r_NA == NON_RESPONSE
          |
            q0410j_government_r_NA == NON_RESPONSE
          |
            q0410k_other_r_NA == NON_RESPONSE
        )
      ~ NON_RESPONSE,
      hh_income_r <= quartiles19[1] ~ 1,
      hh_income_r > quartiles19[1] &
        hh_income_r <= quartiles19[2] ~ 2,
      hh_income_r > quartiles19[2] &
        hh_income_r <= quartiles19[3] ~ 3,
      hh_income_r > quartiles19[3] ~ 4
    ),
    
    hhquartile = factor(
      x = hhquartile,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
      labels = c(
        "first quartile",
        "second quartile",
        "third quartile",
        "fourth quartile",
        MISSING_DESIGN,
        NON_RESPONSE
      )
    ),
    
    hhquintile = case_when(
      hh_income_r >= 0 & is.na(q0410j_government) &
        is.na(q0410k_other) &
        is.na(q0410i_ss) ~ MISSING_DESIGN,
      hh_income_r >= 0 &
        (
          q0410i_ss_r_NA == NON_RESPONSE
          |
            q0410j_government_r_NA == NON_RESPONSE
          |
            q0410k_other_r_NA == NON_RESPONSE
        )
      ~ NON_RESPONSE,
      hh_income_r <= quintiles19[1] ~ 1,
      hh_income_r > quintiles19[1] &
        hh_income_r <= quintiles19[2] ~ 2,
      hh_income_r > quintiles19[2] &
        hh_income_r <= quintiles19[3] ~ 3,
      hh_income_r > quintiles19[3] &
        hh_income_r <= quintiles19[4] ~ 4,
      hh_income_r > quintiles19[4] ~ 5
    ),
    
    
    hhquintile = factor(
      x = hhquintile,
      levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
      labels = c(
        "first quintile",
        "second quintile",
        "third quintile",
        "fourth quintile",
        "fifth quintile",
        MISSING_DESIGN,
        NON_RESPONSE
      )
    )
    
  )
```

### Checking new variables

```{r}
data_2019_test %>% 
  freq_table(hhquartile)
```

```{r}
data_2019_test %>% 
  freq_table(hhquintile)
```

```{r}
rm(quintiles19, quartiles19)
```

Finally we got 91 as not assessed (proxy respondants) and 386 missing (default).

## Province

It will be useful for joining mobility dataset.

```{r}
data_2019_test <-
  data_2019_test |> mutate(province = case_when(
    q0101a_psu == 9 ~ "Barcelona",
    q0101a_psu == 13 ~ "Community of Madrid"
  ))
```

## From here, variables that do not need harmonization but do need to be in Wave 1.

## Stressors

We have to import this outcome (already created) from OneDrive.

```{r}
lte <-
  read_dta(
    "~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_LTE.dta"
  )
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            lte %>% select(ID_ECS, LTE),
                            by = "ID_ECS")
```

```{r}
data_2019_test %>% freq_table(LTE)
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q465", "q466", "q467"))) %>% 
  colnames()
```

```{r}
rm(lte)
```

## BRS (resilience scale)

We have to import this outcome (already created) from OneDrive.

```{r}
brs <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_briefresiliencescale.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            brs %>% select(ID_ECS, resilience_scale), 
                            by = "ID_ECS")
```

```{r}
data_2019_test %>% freq_table(resilience_scale) %>% print(n = 100)
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q753", "q754"))) %>% 
  colnames()
```

```{r}
rm(brs)
```

## Social support & Loneliness

We have to import this outcome (already created) from OneDrive.

```{r}
loneliness_ss_si <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Loneliness, social support and social isolation.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            loneliness_ss_si %>% select(
                              ID_ECS,
                              social_support,
                              loneliness,
                              isolation
                            ), 
                            by = "ID_ECS")
```

```{r}
data_2019_test %>% freq_table(social_support)

data_2019_test %>% freq_table(loneliness)

data_2019_test %>% freq_table(isolation)

```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q63"))) %>% 
  colnames()
```

```{r}
rm(loneliness_ss_si)
```

## Social participation

To be created from baseline using q6613-q6621 (Adapted from Social Isolation
Index - Shankar, McMunn, Banks and Steptoe (2011)).

How often in the past 12 months did you

-   `q6613_club`: ... attended a meeting with any group, club, or organization?

-   `q6618_relig`: ... attended religious activities (do not include weddings
    and funerals)? funerals)?

-   `q6619_leave`: ... went out of your home to attend social gatherings,
    activities, programs or events or to visit family friends?

-   `q6621_assoc`: ... did you go to senior centers or associations, day
    centers, self-help groups, universities for the elderly?

-   1: Never

-   2: Once or twice a year

-   3: Once or twice a month

-   4: Once or twice a week

-   5: Daily

-   999: NA

### Variable exploration

```{r}
data_2019_test %>% 
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>% 
  glimpse()

data_2019 %>%
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>%
  summarise_all(~sum(is.na(.)))

data_2019 %>% 
  freq_table(q6613_club)

data_2019 %>% 
  freq_table(q6618_relig)

data_2019 %>% 
  freq_table(q6619_leave)

data_2019 %>% 
  freq_table(q6621_assoc)
```

### Variable creation

To create this variable:

-   Not married/not cohabiting with a partner == 1,
-   had less than monthly contact with children, other immediate family and
    friends (q6619_leave == 2 & 1)
-   if no participation in any organizations, religious groups, or committees
    (q6613_club == 1; q6621_assoc == 1)

In total, the original scale it is a 5-point scale, but since we only have 4
items here, the scale will go from 0 to 4, indicating that higher scores have
greater social isolation.

We can reverse the score to indicate social participation.

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
          q6613_club = as.factor(q6613_club),
          q6619_leave = as.factor(q6619_leave),
          q6618_relig = as.factor(q6618_relig),
          q6621_assoc = as.factor(q6621_assoc),
          
          q6613_club_r = recode_factor(
              q6613_club,
              `1` = 0, 
              `2` = 0,
              `3` = 1,
              `4` = 1,
              `5` = 1,
              .default = NA_real_),
          
           q6619_leave_r = recode_factor(
              q6619_leave,
              `1` = 0, 
              `2` = 0,
              `3` = 1,
              `4` = 1,
              `5` = 1,
              .default = NA_real_),
          
           q6618_relig_r = recode_factor(
              q6618_relig,
              `1` = 0, 
              `2` = 0,
              `3` = 1,
              `4` = 1,
              `5` = 1,
              .default = NA_real_),
          
           q6621_assoc_r = recode_factor(
             q6621_assoc,
              `1` = 0, 
              `2` = 0,
              `3` = 1,
              `4` = 1,
              `5` = 1,
              `999` = NON_RESPONSE,
              .default = NA_real_),
          
          q6613_club_r = as.character(q6613_club_r),
          q6619_leave_r = as.character(q6619_leave_r),
          q6618_relig_r = as.character(q6618_relig_r),
          q6621_assoc_r = as.character(q6621_assoc_r),
         
         q6613_club_r = as.numeric(q6613_club_r),
          q6619_leave_r = as.numeric(q6619_leave_r),
          q6618_relig_r = as.numeric(q6618_relig_r),
          q6621_assoc_r = as.numeric(q6621_assoc_r),
         
         social_participation = q6613_club_r + 
                                q6618_relig_r + 
                                q6619_leave_r +
                                q6621_assoc_r,
         
         social_participation =
           case_when(
             (social_participation < 0) ~ NON_RESPONSE,
             is.na(social_participation) & is.na(q6613_club) & 
                                           is.na(q6618_relig) &
                                           is.na(q6619_leave) &
                                           is.na(q6621_assoc) ~ MISSING_DESIGN,
             TRUE ~ social_participation
           ),
         q6613_club = as.numeric(q6613_club), #for treating NAs later
          q6619_leave = as.numeric(q6619_leave),
          q6618_relig = as.numeric(q6618_relig),
          q6621_assoc = as.numeric(q6621_assoc)
             )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(social_participation)
#higher scores have greater social participation.
```

The individual items are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q661", "q662"))) %>% 
  colnames()
```

## Alcohol consumption

We have to import this outcome (already created) from OneDrive.

```{r}
alcohol <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Alchool Consumption.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            alcohol %>%  select(ID_ECS, alcohol_consumption), 
                            by = "ID_ECS")
```

```{r}
data_2019_test %>%
  freq_table(alcohol_consumption)
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q300"))) %>% 
  colnames()
```

```{r}
rm(alcohol)
```

## Tobacco consumption

We have to import this outcome (already created) from OneDrive.

```{r}
tobacco <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_tobaccoconsumption.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            tobacco %>% select(ID_ECS, tobacco), 
                            by = "ID_ECS")
```

```{r}
data_2019_test %>% freq_table(tobacco)
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q300"))) %>% 
  colnames()
```

```{r}
rm(tobacco)
```

## Depression

```{r}
depression <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_depressionDSM5.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            depression %>% select(ID_ECS, depression_lifetime,
                                                  depression_12m, depression_12treatment), 
                            by = "ID_ECS")
```

The rest of variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q422", "q421", "q4223", "q4700"))) %>% 
  colnames()
```

```{r}
rm(depression)
```

## Flourishing scale (eudaimonic wellbeing)

```{r}
flourishing <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Flourishing Scale.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            flourishing %>% select(ID_ECS, flourishing_scale), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q75"))) %>% 
  colnames()
```

```{r}
rm(flourishing)
```

## Negative and positive affect

```{r}
negposaf <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Positive and Negative Affect.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            negposaf %>% select(ID_ECS, negativeaffect,
                                                positiveaffect, netaffect), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q702", "q703", "q711", "q7069", "q707", "q706"))) %>% 
  colnames()
```

```{r}
rm(negposaf)
```

## Quality of life

```{r}
qol <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_Quality of Life.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            qol %>% select(ID_ECS, WHOQOL_AGE), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q700", "q7010"))) %>% 
  colnames()
```

```{r}
rm(qol)
```

## Extraversion and neuroticism

```{r}
personality <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_EPQR-A.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            personality %>% select(ID_ECS, neuroticism, extraversion), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q464", "q465"))) %>% 
  colnames()
```

```{r}
rm(personality)
```

## Self-efficacy

```{r}
data_2019_test %>% 
  select(starts_with(c("q7008"))) %>% 
  colnames()
```

## Stressors

```{r}
data_2019_test %>% 
  select(starts_with(c("q201", "q751", #sleep problems,
                       "q304", #nutrition
                       "q200","q41" #pain
                       ))) %>% 
  colnames()
```

## Material deprivation

```{r}
materialdep <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_materialdeprivation.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            materialdep %>% select(ID_ECS, material), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q0411"))) %>% 
  colnames()
```

```{r}
rm(materialdep)
```

## GAD (anxiety)

```{r}
anxiety <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Ola 3/Outcomes/Cohorte 2019/Outcome datasets/Outcome_anxietyDSM4.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(data_2019_test,
                            anxiety %>% select(ID_ECS, GAD12m, GAD), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_2019_test %>% 
  select(starts_with(c("q45", "q6010", "q621", "q7008a"))) %>% 
  colnames()
```

```{r}
rm(anxiety)
```

## Outcome variables related to loneliness and social interaction:

```{r}
socialint <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/history/Social_interaction.dta")

```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_2019_test <- left_join(
  data_2019_test,
  socialint %>% select(
    ID_ECS,
    size_sn,
    social_int_ff_pre,
    social_int_vr_pre,
    social_int_total_pre
  ),
  by = "ID_ECS"
)
```

### Network size (size_sn)

Sum of all the affirmative responses to the **social network** items. Range goes
from 0 to 8.

```{r}
data_2019_test |> select(q6010a_spouse:q6010k_inlaw)
```

### Social interaction face-to-face (pre-lockdown) (social_int_ff_pre)

Sum score of face-to-face social interactions with members of their social
network. Missing values in the face-to-face social interaction items (section
q6210) were recoded as 1 ("Never") when the corresponding social network item
was 2 ("No"). Then, all responses were summed up.

The variable ranges from 7 - 35.

```{r}
data_2019_test |> select(q6211_spouse:q6217v_friends)
```

### Social interaction virtual (pre-lockdown) (social_int_vr_pre)

Sum score of technology-mediated social interactions with members of their
social network. Missing values in the technology-mediated social interaction
items (section q6210v) were recoded as 1 "Never") when the corresponding social
network item was 2 ("No"). Then, all responses to these items, plus additional
item q6221v were summed up.

```{r}
data_2019_test |> select(q6211_spouse:q6221v_unknown)
```

### Social interaction score total (pre-lockdown) (social_int_total_pre)

Sum score of social interactions (face-to-face or technology-mediated)
interactions with member of their social network. Sum of social_int_ff_pre and
social_int_vr_pre. Ranges from 15 to 75.

```{r}
data_2019_test |> select(q6211_spouse:q6221v_unknown)
```

##2.28. Recoding NAs

I will first get a description of missing values 100% NAs:

```{r eval = FALSE}
data_2019_test %>%
  miss_var_summary() %>%
  filter(pct_miss == 100) %>%
  data.frame
```

NAs, in general

```{r}
data_2019_test %>% 
  miss_var_summary() %>% 
  data.frame
```

### Proxy respondents

```{r}
data_2019_test %>% 
  filter(proxy == 1) %>% 
  miss_var_summary() %>% 
  data.frame
```

There are 91 NAs for proxy respondents in some items. We have to recode it as
-991 (missing by design)

```{r}
data_2019_test <- data_2019_test %>%
  mutate(
    proxy = case_when(
      is.na(q1005_proxy) ~ 0,
      TRUE ~ 1
    ),
    proxy = factor(
      x = proxy,
      levels = c(0, 1),
      labels = c("No", "Yes"),
    )
  )
```

```{r}
data_2019_test %>% select(proxy) %>% freq_table(proxy)
```

```{r}
data_2019_test <- data_2019_test %>%
  mutate(across(
    .cols = where(is.numeric),
    .fns = ~ if_else(proxy == "Yes",
                     replace_na(., MISSING_DESIGN),
                     .)
  ))
```

```{r}
data_2019_test %>% 
  filter(proxy == 1) %>% 
  miss_var_summary() %>% 
  data.frame #It works
```

### Missing (default) & refused answer

```{r}
data_2019_test %>% 
  #filter(proxy == 0) %>% 
  miss_var_summary() %>% 
  data.frame #It works
```

Remaining NAs are NON_RESPONSE.

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    across(
      where(is.numeric),
      coalesce,
      NON_RESPONSE
    )
  )
```

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    across(
      where(
    ~c("888") %in% levels(.)),
   .fns = recode_factor,
   `888` = as.character(NON_RESPONSE)
    )
  )

data_2019_test <- data_2019_test %>% 
  mutate(
    across(
      where(
    ~c("999") %in% levels(.)),
   .fns = recode_factor,
   `999` = as.character(REFUSED_ANSWER)
    )
  )
   
   
```

```{r}
data_2019_test %>% 
  miss_var_summary() %>% 
  data.frame #It works
```

#Arrange by ID_ECS

```{r}
data_2019_test <- data_2019_test |> arrange(desc(ID_ECS))
```

# Step 3. Wave 2 harmonization

```{r}
data_COVID_test <- data_COVID_test |> arrange(desc(ID_ECS))
```

## 3.1. Gender

We assume that gender is the same as that recorded in Wave 1.

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>% 
              select(ID_ECS, gender),
            by = "ID_ECS")
```

## 3.2. Country of residence

We assume that country of residence is the same as in Wave 1, "ES".

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>% 
              select(ID_ECS, coresidence),
            by = "ID_ECS")
```

```{r}
data_COVID_test %>%  select(coresidence) %>% freq_table(coresidence)
```

## 3.3. Migration

We assume that migration has not changed from Wave 1.

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>% 
              select(ID_ECS, migration),
            by = "ID_ECS")
```

```{r}
data_COVID_test %>%  select(migration) %>% freq_table(migration)
```

## 3.4. & 3.5. Age

### Variables exploration

As in wave 1, there are IDs that have a corrupted date of birth. We check which
ones they are.

```{r}
data_COVID_test %>% 
  filter(ID_ECS %in% ID_NAs) %>% 
  select(ID_ECS, FECHAFIN)
```

We want to know how many information we have on these cases.

```{r}
ID_NAs_sub <- c(2802002,
                3100602,
                17801501,
                14300101)
```

```{r}
data_2019_test %>% 
  filter(ID_ECS %in% ID_NAs_sub) %>% 
  select(ID_ECS, q1010_birth_date, q1011_age, q1010_year, q1010_month, q1010_day)
```

For these cases we know the value for `q1010_year` and we can make an approxima-
tion of the age based on this. We create a variable that has the actual birth
date for all cases on covid substudy but for the fourth missing cases, only the
year.

To avoid problems and improve data accessibility, we do a left_join using COVID
database as a reference dataset and adding to it the variables related to age
and dates from the baseline database.

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(
    data_2019_test %>%
      select(
        ID_ECS,
        q1010_birth_date,
        q1011_age,
        q1010_year,
        q1010_month,
        q1010_day,
        q0006_date
      ),
    by = "ID_ECS"
  )
```

```{r}
data_COVID_test %>%
  filter(ID_ECS %in% ID_NAs_sub) %>%
  select(ID_ECS,
         q1010_birth_date,
         q0006_date,
         FECHAFIN,
         q1011_age,
         q1010_year)
```

```{r}
data_COVID_test %>%
  filter(!ID_ECS %in% ID_NAs_sub) %>%
  select(ID_ECS,
         q1010_birth_date,
         q0006_date,
         FECHAFIN,
         q1011_age,
         q1010_year)
```

### Variable creation

```{r}
covid_time <- data_COVID_test %>%
  mutate(covid_time = q1010_birth_date %--% FECHAFIN,
         #año-mes-dia
         covid_time = covid_time / years(),) %>% select(covid_time) %>%  pull()
```

```{r}
time_between_BL_covid <- data_COVID_test %>%
  mutate(
    time_between_BL_covid = q0006_date %--% FECHAFIN,
    #año-mes-dia
    time_between_BL_covid = time_between_BL_covid / years()
  ) %>% select(time_between_BL_covid) %>% pull()
```

```{r}
data_COVID_test %>% freq_table(FECHAFIN) %>% print(n = 100) #There are 102 NAs
```

```{r}
data_COVID_test %>% freq_table(q0006_date) %>% print(n = 100) #No NAs
```

We have three situations: 1. We have complete data to have an accurate estimate
of the age: date of birth, date of baseline interview and covid interview. We
calculate the age by doing covid_date - date_of_birth.

2.  We don't have date of birth, but covid_date and baseline_date. We calculate
    the age by doing age on baseline + period between covid_date and
    baseline_date.

3.  We don't have date of birth nor covid_date. We estimate the age by exploring
    if the dates of baseline interview and covid_date are sequential, to extract
    an approximation of time between the two periods.

```{r}
data_COVID_test %>%
  group_by(origin) %>%
  mutate(
    tiempo_base = lag(q0006_date) - lead(q0006_date),
    tiempo_covid = lag(FECHAFIN) - lead(FECHAFIN)
  ) %>%
  select(tiempo_base, tiempo_covid)
```

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    # qq1011_age = dyears(q1011_age),
    # qq1011_age = as.period(qq1011_age),
    age_act = q1011_age + time_between_BL_covid,
    #age_act = year(age_act),
    age_continuous = case_when(ID_ECS %in% ID_NAs_sub ~ age_act,
                               TRUE ~ covid_time),
    #
    # age_continuous = if_else(
    #                     ID_ECS %in% ID_NAs_sub, age_act,
    #                     covid_time
    #                     ),
    age_continuous = floor(age_continuous),
    #we round up to the integer age of
    #the person (when there is one month left until a birthday, it's not said
    #how old we will be, but how old I am)
    age_cat = case_when(
      age_continuous < 18 ~ 1,
      age_continuous >= 18 & age_continuous <= 44 ~ 2,
      age_continuous >= 45 & age_continuous <= 64 ~ 3,
      age_continuous >= 65 & age_continuous <= 94 ~ 4,
      age_continuous >= 95 ~ 5
    ),
    age_cat = factor(
      x = age_cat,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "below 18 years",
        "18-44",
        "45-64",
        "65-94",
        "95 years or older",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

### Checking new variable

```{r}
data_COVID_test %>%
  freq_table(age_cat)

data_COVID_test %>%
  select(age_continuous, age_cat, q1011_age, q1010_birth_date)
#%>% View()

data_COVID_test %>%
  filter(ID_ECS %in% ID_NAs_sub) %>%
  select(
    ID_ECS,
    q1010_birth_date,
    q0006_date,
    FECHAFIN,
    q1011_age,
    q1010_year,
    age_continuous,
    age_cat
  )
```

```{r}
data_COVID_test <- data_COVID_test %>%
  select(!c(
    q1010_birth_date,
    q1011_age,
    q1010_year,
    q1010_month,
    q1010_day,
    q0006_date
  ))
```

## 3.6. Employment status

```{r}
data_COVID_test <-
  data_COVID_test %>% 
  mutate(
    employment_st = MISSING_DESIGN,
    employment_st = factor(
      x = employment_st,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "have a job (employed or self-employed)",
        "in education",
        "care work (familiy) / homeworker/ on parental leave",
        "on long-term sick leave/disability",
        "unable to work due to reasons not mentioned elsewhere in this list",
        "unemployed or job-seeking",
        "retired",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE),
    
  )
)
```

```{r}
data_COVID_test |> freq_table(employment_st)
```

## 3.7. Contract

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(contract = MISSING_DESIGN,
         contract = factor(
           x = contract,
           levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
           labels = c(
             "permanent",
             "temporary",
             "self-employed",
             "other",
             MISSING_DESIGN,
             REFUSED_ANSWER,
             NON_RESPONSE
           )
         ))
```

```{r}
data_COVID_test |> freq_table(contract)
```

## 3.8. Employment type

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    employment_ty = MISSING_DESIGN,
    employment_ty = factor(
      x = employment_ty,
      levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "permanent",
        "temporary",
        "self-employed",
        "other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

```{r}
data_COVID_test |> freq_table(employment_ty)
```

## 3.9. HC worker

Same values as Wave 1.

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>% 
              select(ID_ECS, hc_worker),
            by = "ID_ECS")
```

```{r}
data_COVID_test |> freq_table(hc_worker)
```

## 3.10. Profession

Same values as Wave 1 (as it is something that is stable in time).

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>% 
              select(ID_ECS, profession),
            by = "ID_ECS")
```

```{r}
data_COVID_test |> freq_table(profession)
```

## 3.11. Education

Same values as Wave 1.

```{r}
data_COVID_test <- data_COVID_test %>%
  left_join(data_2019_test %>%
              select(ID_ECS, education),
            by = "ID_ECS")
```

```{r}
data_COVID_test |> freq_table(education)
```

## 3.12. Relationship status

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    relationship = MISSING_DESIGN,
    relationship = factor(
      x = relationship,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "single",
        "married/in a civil union",
        "in a relationship and living together",
        "in a relationship and living apart",
        "divorced/separated",
        "widowed",
        "other",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

```{r}
data_COVID_test |> freq_table(relationship)
```

## 3.13. Children

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(children = MISSING_DESIGN,
         children = factor(
           x = children,
           levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
           labels = c("yes",
                      "no",
                      MISSING_DESIGN,
                      REFUSED_ANSWER,
                      NON_RESPONSE)
         ))
```

```{r}
data_COVID_test |> freq_table(children)
```

## 3.14. Children household

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    children_hh = MISSING_DESIGN,
    children_hh = factor(
      x = children_hh,
      levels = c("1", "2", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c("yes",
                 "no",
                 MISSING_DESIGN,
                 REFUSED_ANSWER,
                 NON_RESPONSE)
    )
  )
```

```{r}
data_COVID_test |> freq_table(children_hh)
```

## 3.15. Number of children

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    nofchildren = MISSING_DESIGN,
    nofchildren = factor(
      x = nofchildren,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "no children",
        "one child",
        "two or three",
        "four or more",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
  )
```

```{r}
data_COVID_test |> freq_table(nofchildren)
```

## 3.16. Living alone

We have to import this outcome (already created) from OneDrive.

```{r}
livingalone <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_social interactions_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                             livingalone %>% select(ID_ECS, living_alone),
                             by = "ID_ECS")
```

```{r}
data_COVID_test <- data_COVID_test %>%
  mutate(
    living_alone = as.character(living_alone),
    living_alone = recode(living_alone,
                          "0" = "2",
                          "1" = "1"),
    living_alone = as.integer(living_alone),
    living_alone = coalesce(living_alone, NON_RESPONSE),
    
    living_alone = factor(
      x = living_alone,
      levels = c("1", "2", NON_RESPONSE, MISSING_DESIGN, REFUSED_ANSWER),
      labels = c(
        "alone",
        "not alone",
        NON_RESPONSE,
        MISSING_DESIGN,
        REFUSED_ANSWER
        
      )
    )
  )
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO1_")) %>% 
  colnames()
```

```{r}
data_COVID_test |> freq_table(living_alone)
```

## 3.17. Household size

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(hh_size = MISSING_DESIGN,
         hh_size = factor(
           x = hh_size,
           levels = c(
             "1",
             "2",
             "3",
             "4",
             "5",
             MISSING_DESIGN,
             REFUSED_ANSWER,
             NON_RESPONSE
           ),
           labels = c(
             "one person",
             "two persons",
             "three or four persons",
             "five or more persons",
             "live in an institution",
             MISSING_DESIGN,
             REFUSED_ANSWER,
             NON_RESPONSE
           )
         ))
```

```{r}
data_COVID_test |> freq_table(hh_size)
```

## 3.18. Quartiles & quintiles

```{r}
data_COVID_test <-
  data_COVID_test %>%
  mutate(
    hhquartile = MISSING_DESIGN,
    hhquintile = MISSING_DESIGN,
    
    
    hhquartile = factor(
      x = hhquartile,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "first quartile",
        "second quartile",
        "third quartile",
        "fourth quartile",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    ),
    
    hhquintile = factor(
      x = hhquintile,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "first quintile",
        "second quintile",
        "third quintile",
        "fourth quintile",
        "fifth quintile",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      )
    )
    
  )
```

```{r}
data_COVID_test |> freq_table(hhquartile)
data_COVID_test |> freq_table(hhquintile)
```

## Stressors

(Separated raw items)

### Sleep problems

```{r}
data_COVID_test %>%  
  select(num_range("SUE", 2:3)) %>% 
  colnames()
```

### Pain

```{r}
data_COVID_test %>%  
  select(num_range("DOLOR", 1:4), -DOLOR2) %>% 
  colnames()
```

### Economy & unemployment

We have to import this outcome (already created) from OneDrive.

```{r}
economic <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_economic.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            economic %>% select(ID_ECS, economy, unemployment), 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(num_range("ECON", 4:5)) %>% 
  colnames()
```

```{r}
rm(economic, livingalone, occ_unique)
```

### COVID

Five variables: `infected`, `severity_raw`, `rel_isolated`, `rel_deceased`,
`rel_concerned`

We have to import this outcome (already created) from OneDrive.

```{r}
covidcc <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_ailment.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(
  data_COVID_test,
  covidcc %>% select(
    ID_ECS,
    infected,
    severity_raw,
    rel_isolated,
    rel_deceased,
    rel_concerned
  ),
  by = "ID_ECS"
)
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("COVID")) %>% 
  colnames()
```

```{r}
rm(covidcc)
```

### Noise

```{r}
data_COVID_test %>% 
  select(starts_with("ECON1_1")) %>% 
  colnames()
```

## BRS (resilience scale)

We have to import this outcome (already created) from OneDrive.

```{r}
brsw2 <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_brief resilience scale_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            brsw2 %>% select(ID_ECS, resilience_scale), 
                            by = "ID_ECS")
```

The rest of stressors variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SM26")) %>% 
  colnames()
```

```{r}
rm(brsw2)
```

## Social support (OSLO-3) & loneliness

We have to import this outcome (already created) from OneDrive.

```{r}
socialsupw2 <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_loneliness and social support_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            socialsupw2 %>%  select(ID_ECS, social_support, loneliness), 
                            by = "ID_ECS")
```

The rest of separated variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO9")) %>% 
  colnames()
```

```{r}
data_COVID_test %>% 
  select(num_range("SOLO7_", 1:3)) %>% 
  colnames()
```

```{r}
rm(socialsupw2)
```

## Social interaction

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            socialint %>% select(ID_ECS,
                                                 pers_rel_affected,
                                                 time_alone), 
                            by = "ID_ECS")
```

### Change in personal relationships (post-lockdown)

Whether the participant declares their personal relationships have been affected
by the lockdown. SOLO3 recoded as -1, 0, or 1, to indicate whether personal
relationships are perceived to heve worsened, stayed unchanged, or improved,
respectively.

```{r}
data_COVID_test |> select(ID_ECS, SOLO3)
```

### Time alone

No further processing from variable SOLO4.

```{r}
data_COVID_test |> select(ID_ECS, SOLO4)
```

```{r}
rm(socialint)
```

## Social participation

This variable, SOLO2, is already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with("SOLO2")) %>% 
  colnames()
```

## Alcohol consumption

```{r}
data_COVID_test %>% 
   select(starts_with("ALCOH1")) %>% 
   colnames()
```

## Tobacco consumption

```{r}
data_COVID_test %>% 
   select(starts_with("FUM1")) %>% 
   colnames()
```

## Depression

We have to import this outcome (already created) from OneDrive.

```{r}
depression <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_depression_ICD10.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            depression %>% select(ID_ECS, d_30d_severity, depression_30d), 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(starts_with(c("SM8", "SM_3", "SM"))) %>% 
  colnames()
```

```{r}
rm(depression)
```

## Suicidality

We have to import this outcome (already created) from OneDrive.

```{r}
suicidality <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_Suicidalideation.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            suicidality %>% select(ID_ECS, suicidal), 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(SM9) %>% 
  colnames()
```

```{r}
rm(suicidality)
```

## Negative and positive affect

We have to import this outcome (already created) from OneDrive.

```{r}
negposaffect <- read_dta("~/../UAM/Marta Miret Garcia - Documentacion Edad con Salud/Edad con salud - Subestudio COVID/Outcomes/Outcome datasets/Outcome_ positive and negative affect_Subestudio_COVID.dta")
```

We join this dataset to the one containing the new variables already harmonized
with left_join. The variable they have in common is ID_ECS and it is the one
that serves as link.

```{r}
data_COVID_test <- left_join(data_COVID_test,
                            negposaffect %>% select(ID_ECS, negativeaffect, positiveaffect, netaffect), 
                            by = "ID_ECS")
```

The rest of individual variables are already on the dataset:

```{r}
data_COVID_test %>% 
  select(num_range("SM22_", 1:5)) %>% #negative affect
  colnames()
```

```{r}
data_COVID_test %>% 
  select(num_range("SM22_", 6:7)) %>% #positive  affect
  colnames()
```

```{r}
rm(negposaffect)
```

## Quality of life

```{r}
data_COVID_test %>% 
  select(SM21) %>% 
  colnames()
```

## 3.28. Recoding NAs

I will first get a description of missing values 100% NAs:

```{r eval = FALSE}
data_COVID_test %>% 
  miss_var_summary() %>% 
  filter(pct_miss == 100) %>% 
  data.frame
```

NAs, in general

```{r}
data_COVID_test %>% 
  miss_var_summary() %>% 
  data.frame
```

### Proxy respondents

```{r}
data_COVID_test %>% 
  select(TIPO_ENT) %>% 
  freq_table(TIPO_ENT)

data_COVID_test %>% 
  select(TIPO_ENT) %>% 
  str()

```

There are 54 NAs for proxy respondents in some items. We have to recode it as
-991 (missing by design)

```{r}
data_COVID_test <- data_COVID_test %>%
  mutate(across(
    .cols = where(is.numeric),
    .fns = ~ if_else(TIPO_ENT == 2 |
                       is.na(TIPO_ENT), #Alternativa == 2,
                     replace_na(., MISSING_DESIGN),
                     .)
  ))
```

```{r}
data_COVID_test <- data_COVID_test %>%
  mutate(age_cat = if_else(
    (TIPO_ENT == 2 | TIPO_ENT == MISSING_DESIGN),
    forcats::fct_na_value_to_level(age_cat, level = "-991"),
    age_cat
  ))
```

```{r}
data_COVID_test %>%
  filter(TIPO_ENT == 2 | TIPO_ENT == MISSING_DESIGN) %>%
  miss_var_summary() %>%
  data.frame #variables that have 95% of missing with this filter are character variables that we don't use here
```

Remaining NAs are NON_RESPONSE.

```{r}
data_COVID_test <- data_COVID_test %>%
  mutate(across(where(is.numeric),
                coalesce,
                NON_RESPONSE))
```

```{r}
data_COVID_test %>%
  miss_var_summary() %>%
  data.frame #It works
```

We'll recategorize '888' (don't know) as missing (default)

```{r}
data_COVID_test <- data_COVID_test %>%
  mutate(across(
    where(is.numeric),
    recode,
    `9` = NON_RESPONSE,
    `888` = NON_RESPONSE,
    `999` = REFUSED_ANSWER
  ))
```

```{r}
data_COVID_test %>% 
  miss_var_summary() %>% 
  filter(pct_miss > 50) %>% 
  data.frame #It works
```

# Step 4. Combination of both datasets

```{r}
data_COVID_test <- left_join(data_COVID_test,
          data_2019_test |> select(ID_ECS, province),
           by = "ID_ECS") #useful for merging google mobility indexes
```

```{r}
df <- bind_rows(data_2019_test, data_COVID_test)
```

```{r}
df <- df %>% select(ID_ECS, wave, everything()) %>% arrange(ID_ECS)
```

Now a bunch of NAs appear for all the baseline variables that were not measured
in wave 2. This will have to be changed later with the full database (they have
to be "MISSING_DESIGN").

# Step 5. Adding new variables

## Lockdown stringency index

The file has got data from several countries. I only want to import the Spanish
data.

```{r}
stringency_index <- 
  readr::read_csv("https://raw.githubusercontent.com/OxCGRT/covid-policy-tracker/master/data/OxCGRT_nat_latest.csv") %>% 
  filter(CountryCode == "ESP")
```

There is only NAs on this dataset?

```{r}
stringency_index <- 
  stringency_index %>% 
  mutate(date = ymd(Date)) %>%  
  select(!Date)
```

we use 'date' as key for joining both datasets:

```{r}
df <- df %>% mutate(
  date = FECHAFIN)
```

```{r}
df <- left_join(df,
                stringency_index,
                by = "date")
```

Now that these values are included in the complete dataset, it is necessary to
modify the missing values. If we are at wave == 1, the missing values are
MISSING_DESIGN (since these are policy indicators that were taken with respect
to the COVID-19 pandemic). If we are in wave == 2, the missing values are
NON_RESPONSE.

```{r}
#Character variables
df <- df %>% mutate(
  CountryName = if_else(wave == 1, coalesce(CountryName, "-991"), CountryName),
  # missing_design = -991
  CountryName = if_else(wave == 2, coalesce(CountryName, "-993"), CountryName),
  #non_response = -993
  CountryCode = if_else(wave == 1, coalesce(CountryCode, "-991"), CountryCode),
  # missing_design = -991
  CountryCode = if_else(wave == 2, coalesce(CountryCode, "-993"), CountryCode),
  #non_response = -993
  Jurisdiction = if_else(wave == 1, coalesce(Jurisdiction, "-991"), Jurisdiction),
  # missing_design = -991
  Jurisdiction = if_else(wave == 2, coalesce(Jurisdiction, "-993"), Jurisdiction),
  #non_response = -993
  `V2B_Vaccine age eligibility/availability age floor (general population summary)` =
    if_else(
      wave == 1,
      coalesce(
        `V2B_Vaccine age eligibility/availability age floor (general population summary)`,
        "-991"
      ),
      `V2B_Vaccine age eligibility/availability age floor (general population summary)`
    ),
  # missing_design = -991
  `V2B_Vaccine age eligibility/availability age floor (general population summary)` = if_else(
    wave == 2,
    coalesce(
      `V2B_Vaccine age eligibility/availability age floor (general population summary)`,
      "-993"
    ),
    `V2B_Vaccine age eligibility/availability age floor (general population summary)`
  ),
  #non_response = -993
  `V2C_Vaccine age eligibility/availability age floor (at risk summary)` =
    if_else(
      wave == 1,
      coalesce(
        `V2C_Vaccine age eligibility/availability age floor (at risk summary)`,
        "-991"
      ),
      `V2C_Vaccine age eligibility/availability age floor (at risk summary)`
    ),
  # missing_design = -991
  `V2C_Vaccine age eligibility/availability age floor (at risk summary)` = if_else(
    wave == 2,
    coalesce(
      `V2C_Vaccine age eligibility/availability age floor (at risk summary)`,
      "-993"
    ),
    `V2C_Vaccine age eligibility/availability age floor (at risk summary)`
  ),
  #non_response = -993
  MajorityVaccinated = if_else(
    wave == 1,
    coalesce(MajorityVaccinated, "-991"),
    MajorityVaccinated
  ),
  # missing_design = -991
  MajorityVaccinated = if_else(
    wave == 2,
    coalesce(MajorityVaccinated, "-993"),
    MajorityVaccinated
  ),
  #non_response = -993
  
)
#Logical to integer variables
df <- df %>% mutate(across(.cols = where(is.logical),
                           .fns = ~ as.integer(.)))


df <- df %>% mutate(across(
  .cols = c(
    RegionName,
    RegionCode,
    `C1M_School closing`:`V2A_Vaccine Availability (summary)`,
    `V2D_Medically/ clinically vulnerable (Non-elderly)`:`ConfirmedDeaths`,
    `PopulationVaccinated`:EconomicSupportIndex_ForDisplay
  ),
  .fns = ~ if_else(wave == 1,
                   replace_na(., MISSING_DESIGN),
                   .)
))

df <- df %>% mutate(across(
  .cols = c(
    RegionName,
    RegionCode,
    `C1M_School closing`:`V2A_Vaccine Availability (summary)`,
    `V2D_Medically/ clinically vulnerable (Non-elderly)`:`ConfirmedDeaths`,
    `PopulationVaccinated`:EconomicSupportIndex_ForDisplay
  ),
  .fns = ~ if_else(wave == 2,
                   replace_na(., NON_RESPONSE),
                   .)
))

df %>% select(ID_ECS, wave, CountryName:EconomicSupportIndex_ForDisplay)
```

## Google Mobility

We download the .zip file of the Google regional reports
(<https://www.google.com/covid19/mobility/>). Our waves are from the year 2019
and 2020, so we have to save the datasets for Spain in those two cycles. As it
is the change of mobility by COVID, there is only information relative to 2020.

```{r}
mobility <- read.csv("./dat/2020_ES_Region_Mobility_Report.csv", stringsAsFactors = TRUE)
```

```{r collapse=TRUE}
mobility %>% 
  select(sub_region_1) %>% 
  table() # CCAA
mobility %>% 
  select(sub_region_2) %>% 
  table() # Province
```

In EcS we only have data from Madrid and Barcelona. This city value is coded in
the original datasets as "origin".

```{r}
mobility <- mobility %>% 
  filter(sub_region_2 %in% c("Barcelona") | sub_region_1 %in% c("Community of Madrid") )
```

In addition, the values of origin and the identifiers of the CCAA and provinces
do not match, so we are going to create a new variable in the final dataset and
in the object 'mobility' to link these two tables.

```{r}
mobility <- mobility %>% 
  mutate(
    province = 
      case_when(sub_region_2 == "Barcelona" ~ "Barcelona",
                sub_region_1 == "Community of Madrid" ~ "Community of Madrid"),
    wave = 2
  )
```

```{r}
mobility %>% 
  mutate(
    province = as.factor(province)) %>% 
  select(province) %>% 
  group_by(province) %>% 
  count() %>% 
  data.frame
```

```{r}
mobility <- mobility %>%  
  mutate(date = as.Date(date))
```

```{r}
df <- left_join(df,
                mobility,
                by = c("date", "province", "wave"))
```

Checking everything works just fine:

```{r}
df |> select(ID_ECS, wave, date, province, country_region_code:residential_percent_change_from_baseline)
```

We have to correct missing values. There are two types of missing values. For
cases on wave == 1, they must be "MISSING_DESIGN" (as they not apply on baseline
cases) For cases on wave == 2, they must be "NON_RESPONSE" (as they apply in
wCOVID, but there is no response for them).

Also, we have to keep in mind that variables from mobility dataset have
different structure. Variables `country_region_code:sub_region_2` and
`iso_3166_2_code` and `place_id` are factors, while
`retail_and_recreation_percent_change_from_baseline:residential_percent_change_from_baseline`
are integers. `metro_area` and `census_fips_code` are LOGI variables. We must
apply different strategies to treat NAs values.

```{r}
#Integer variables
df <- df %>%
  mutate(
    census_fips_code = as.integer(census_fips_code),
    metro_area = as.integer(metro_area)
  )

df <- df %>%
  mutate(across(
    .cols = c(
      retail_and_recreation_percent_change_from_baseline:residential_percent_change_from_baseline,
      census_fips_code,
      metro_area
    ),
    .fns = ~ if_else(wave == 1,
                     replace_na(., MISSING_DESIGN),
                     .)
  ))

df <- df %>%
  mutate(across(
    .cols = c(
      retail_and_recreation_percent_change_from_baseline:residential_percent_change_from_baseline,
      census_fips_code,
      metro_area
    ),
    .fns = ~ if_else(wave == 2,
                     replace_na(., NON_RESPONSE),
                     .)
  )) 
```

```{r}
#Factor variables 

df <- df %>%
  mutate(across(
    .cols = c(country_region_code:sub_region_2, iso_3166_2_code, place_id),
    .fns = ~ if_else(wave == 1,
                     forcats::fct_na_value_to_level(., level = "-991"),
                     .) #missing design
  ))

df <- df %>%
  mutate(across(
    .cols = c(country_region_code:sub_region_2, iso_3166_2_code, place_id),
    .fns = ~ if_else(wave == 2,
                     forcats::fct_na_value_to_level(., level = "-993"),
                     .) #non response
  ))
```

## NUTS

We import the dataset obtained in OBIBA/ NUTS2021_nomenclature of territorial
units for statistics.

We have to import separately:

-   \- NUTS provinces (NUTS 1 to 3).

-   \- NUTS Urban - Rural

-   \- NUTS Urban-rural remoteness

```{r}
nuts_provinces <- read_excel(
  "./dat/NUTS2021.xlsx",
  sheet = "NUTS 1 to 3",
  col_types = c(
    "text",
    "text",
    "text",
    "text",
    "text",
    "numeric",
    "numeric",
    "numeric",
    "skip",
    "skip"
  )
)
```

```{r}
nuts_urbanrural <- read_excel(
  "./dat/NUTS2021.xlsx",
  sheet = "Urban - Rural",
  col_types = c("text",
                "numeric", "text", "skip", "skip",
                "skip", "skip")
)
```

```{r}
nuts_urbanruralremoteness <- read_excel(
  "./dat/NUTS2021.xlsx",
  sheet = "Urban-rural remoteness",
  col_types = c(
    "skip",
    "text",
    "text",
    "numeric",
    "text",
    "skip",
    "skip",
    "skip",
    "skip"
  )
)
```

```{r}
nuts_provinces <-
  nuts_provinces %>%
  mutate(NUTS3 = str_replace_all("NUTS level 3",
                                 "'",
                                 ""),
         CODE  = str_replace_all("CODE 2021",
                                 "'",
                                 ""))
```

```{r collapse=TRUE}
str(nuts_provinces)
str(nuts_urbanrural)
str(nuts_urbanruralremoteness)
```

```{r}
nuts_provinces  <-
  nuts_provinces %>%
  rename(nuts_id = `Code 2021` ,
         province = `NUTS level 3`)

nuts_urbanrural <-
  nuts_urbanrural %>%
  rename(
    nuts_id = NUTS_ID,
    nuts_urbanrural_category = `URBAN-RURAL CATEGORY`,
    nuts_urbanrural_label = `URBAN-RURAL LABEL`
  )

nuts_urbanruralremoteness <-
  nuts_urbanruralremoteness %>%
  rename(
    nuts_id = `NUTS ID`,
    nuts_remoteness_category = `CATEGORY CODE`,
    nuts_remoteness_label = `CATEGORY LABEL`
  )
```

Succesive merging

```{r}
nuts_ds <-
  left_join(nuts_provinces,
            nuts_urbanrural,
            by = "nuts_id") %>%
  left_join(.,
            nuts_urbanruralremoteness,
            by = "nuts_id")
```

```{r}
rm(nuts_provinces,
   nuts_urbanrural,
   nuts_urbanruralremoteness)
```

```{r}
nuts_ds <- nuts_ds %>%
  filter(province == "Madrid" | province == "Barcelona")

nuts_ds <-
  nuts_ds %>%
  mutate(province = case_when(province == "Madrid" ~ "Community of Madrid",
                              TRUE ~ province))
nuts_ds %>%
  filter(province == "Community of Madrid")
  
```

```{r}
df <-
  left_join(df,
            nuts_ds,
            by = "province")

df %>% select(colnames(nuts_ds))

df <- df %>%
  mutate(
    Country = "Spain",
    `NUTS level 1` = coalesce(`NUTS level 1`, "-991",
                              `NUTS level 2` = coalesce(`NUTS level 2`, "-991"))
  )

rm(nuts_ds)
rm(mobility)
```

## UNSD Methodology

```{r}
UNSDcodes <- read_excel("./dat/UNSD — Methodology.xlsx")
```

```{r}
UNSDcodes <- UNSDcodes |> filter(`Country_or_Area` == "Spain")
```

```{r}
df <- df |> 
  mutate(
    ISO_alpha2 = coresidence
)
```

```{r}
df <- left_join(df,
                UNSDcodes,
                by = "ISO_alpha2")
```

```{r}
df %>% select(colnames(UNSDcodes))

df <- df %>% mutate(across(
  .cols = c(Intermediate_Region_Name, LDC, LLDC, SIDS, `NUTS level 2`),
  .fns = ~ as.integer(.)
))

df <- df %>% mutate(across(
  .cols = c(
    Intermediate_Region_Code,
    Intermediate_Region_Name,
    LDC:SIDS,
    `NUTS level 2`
  ),
  .fns = ~ coalesce(., MISSING_DESIGN)
))
```

```{r}
rm(stringency_index, UNSDcodes, unique_ids, bl_time, covid_time, ID_NAs, ID_NAs_sub, time_between_BL_covid)
```

# Step 6. Hashed IDs

The WP2 handbook for harmonisation reads that a unique identifier (random
integer) should be assigned to each participant. We'll use `digest` function and
package.

```{r}
df <- df %>% group_by(ID_ECS) |>
  mutate(hashed_id = digest(ID_ECS, algo = "md5")) %>%
  select(hashed_id, everything())
```

# Step 7. Selecting necessary variables

Firstly, we import the Edad con Salud variable list for RESPOND.

```{r}
ecs_variablelist <- read_excel(
  "./dat/variable_list-EcS_v3.xlsx",
  sheet = "EcS-table format",
  col_types = c("text",
                "skip", "numeric", "text", "skip",
                "skip", "skip")
)
```

```{r}
ecs_varlist <- ecs_variablelist %>% select(variable) %>% pull()
```

```{r}
df <- df %>% ungroup() |> select(hashed_id,
                    wave,
                    gender,
                    coresidence,
                    migration,
                    age_cat,
                    age_continuous,
                    employment_st,
                    contract,
                    employment_ty,
                    hc_worker,
                    profession,
                    education,
                    relationship,
                    children,
                    children_hh,
                    nofchildren,
                    living_alone,
                    hh_size,
                    hhquartile,
                    hhquintile,
                    any_of(ecs_varlist),
                    CountryCode:nuts_remoteness_label)
```

# Step 8. Checking that there are no more NAs

```{r}
#"true" NAs
df <- df %>% mutate(across(
  .cols = where(is.numeric) & any_of(colnames(data_2019_test)),
  .fns = ~ if_else(wave == 2,
                   coalesce(., MISSING_DESIGN),
                   .)
))

df <- df %>% mutate(across(
  .cols = where(is.numeric) & any_of(colnames(data_2019_test)),
  .fns = ~ if_else(wave == 1,
                   coalesce(., NON_RESPONSE),
                   .)
))

df <- df %>% mutate(across(
  .cols = where(is.numeric) & any_of(colnames(data_COVID_test)),
  .fns = ~ if_else(wave == 1,
                   coalesce(., MISSING_DESIGN),
                   .)
))

df <- df %>% mutate(across(
  .cols = where(is.numeric) & any_of(colnames(data_COVID_test)),
  .fns = ~ if_else(wave == 2,
                   coalesce(., NON_RESPONSE),
                   .)
))
```

```{r}
#Recoding 888 & 999

df <- df %>% ungroup() %>%
  mutate(across(.cols = where(is.numeric),
                .fns = ~ na_if(., 888))) #non_response

df <- df %>% ungroup() %>%
  mutate(across(
    .cols = where(is.numeric),
    .fns = ~ coalesce(., NON_RESPONSE)
  ))

df <- df %>% ungroup() %>%
  mutate(across(.cols = where(is.numeric),
                .fns = ~ na_if(., 999))) #refused_answer

df <- df %>% ungroup() %>%
  mutate(across(
    .cols = where(is.numeric),
    .fns = ~ coalesce(., REFUSED_ANSWER)
  ))
```

```{r}
df %>%
  miss_var_summary() %>%
  data.frame
```

We remove the labels of the original missing values, which have been replaced by
the family of -991, -993...:

```{r}
df <- df %>% mutate(
  across(
    .cols = c(q1510e_workday, 
              q1510b_contract_earner,
              q1510_catoccu,
              q1016_highest,
              q1018_country,
              q1012_mar_stat,
              q0410g_total,
              q0410i_ss,
              q0410j_government,
              q0410k_other,
              q4659_ill,
              q4660_illrelative,
              q4661_died,
              q4662_diedrelative,
              q4663_separation,
              q4664_brokeoff,
              q4665_problem,
              q4666_unemployed,
              q4667_sacked,
              q4668_financial,
              q4669_police,
              q4670_stolen,
              q6310_help_neig,
              q6320_close,
              q6330_concern,
              SOLO9A, #"No sabe"
              SOLO9B,
              SOLO9C, #"No sabe", ""No aplicable""
              SOLO2,
              SOLO2A,
              q3009a,
              q3009b,# "DK"     "refuse"
              q3009c,
              q3009d,
              q3009e,
              q3009f,
              q3009g,
              ALCOH1, #"No sabe"
              FUM1A, #"NS/NC(NO LEER)"    
              q4211, #"DK"     "Refuse"
              q4213,
              q4214,
              q4215,
              q4216,
              q4220a,
              q4220b,
              q4220c,
              q4220d,
              q4220e,
              q4220f,
              q4222a,
              q4222b,
              q4222c,
              q4222d,
              q4222e,
              q4222l,
              q4222m,
              q4222n,
              q4222o,
              q4222p,
              q4222q,
              q4222r,
              q4222s,
              q4222t,
              q4222u,
              q4222v,
              q4224,
              q4224a,
              q4224b,
              q4700a, # "Not applicable" "DK"             "Refuse"
              q4700b,
              q4700c,
              q4700d,
              SM8_1, #"NS/NC (no leer)" "NS/NC"
              SM8_2,
              SM8_3, #"NS/NC (no leer)" "NS/NC"
              SM8_4,
              SM8_5, #"NS/NC (no leer)" "NS/NC"
              SM8_6,
              SM8_7, #"NS/NC (no leer)" "NS/NC"
              SM8_8,
              SM8_9, #"NS/NC (no leer)" "NS/NC"
              SM8_10,
              SM_3, #"NS/NC (no leer)"
              SM4,
              SM5,
              SM6,
              SM7,
              q7528,
              q7529,
              q7530,
              q7531,
              q7532,
              q7533,
              q7534,
              q7535,
              q7009a_energy,
              q7009b_control,
              q7009c_achieve,
              q7009d_money,
              q7010b_intimate,
              SM21, # "DK"      "Refused"
              q2016_sleep,
              q2017_rested,
              SUE3, #"NS/NC"
              q2007_pains,
              q2009_difficulty,
              q4112,
              q4120,
              DOLOR1,
              DOLOR3,
              DOLOR4,
              q0411c,
              q0411d,
              q0411e,
              q0411f,
              q0411g,
              q0411h,
              q0411i,
              ECON4,
              ECON5,
              ECON1_1,
              q4550_worrylife,
              q4573_episode12,
              q6211_spouse,
              q6212_parents,
              q6213_children,
              q6214a_grand,
              q6215a_siblings,
              q6215b_inlaw,
              q6217_friends,
              q6211v_spouse,
              q6212v_parents,
              q6213v_children,
              q6214av_grand,
              q6215av_siblings,
              q6215bv_inlaw,
              q6217v_friends,
              q4585_ideation,
              q4586_age,
              q4587_ideat12,
              q4588_age,
              q4589_planification,
              q4590_age,
              q4591_planif12,
              q4592_age,
              q4593_attempt,
              q4594_times,
              q4595_age,
              q4596_type,
              q4597_type12,
              q4598_age,
              q4599a_damage,
              q4599b_attention,
              q4599c_hospi,
              SM9,
              SOLO3,
              SOLO5,
              SOLO5B,
              SOLO6,
              SOLO6B,
              SOLO8A,
              q1011_age,
              SOLO1_999),
    .fns = ~as_factor(.) |>  fct_drop(only = c("DK", "Refusal", 
                                              "No sabe", "No aplicable", 
                                              "Refused", "NS/NC", "NS/NC (no leer)",
                                              "Not applicable", "NS/NC(NO LEER)",
                                              "refuse", "Refuse", "DK/ RF", "NS/NC (NO LEER)",
                                              "NS/NC (NO LEER)", "Dk", "RF", "DK/RF", "No lo sabe",
                                              "No lo sabe (insistir en que dé una respuesta)",
                                              "NS/NC (NO LEER)", "NA", "NS/NC (NO LEER)", "888",
                                              "NS / NC (NO LEER)"
                                              ))
  )
)
```

# Step 9. Stablishes "categories" for categorical variables in Opal

```{r}
df <- df %>% mutate(
  across(
    .cols = c(wave,
              q1504_reason,
              q1503_work_now,
              q1058,
              q1056,
              q7537,
              q7538,
              q7539,
              q7540,
              q7541,
              q7542,
              SM26_1,
              SM26_2,
              SM26_3,
              SM26_4,
              SM26_5,
              SM26_6,
              q6613_club,
              q6618_relig,
              q6619_leave,
              q6621_assoc,
              alcohol_consumption,
              q3007_everalc,
              q3008_last30,
              q3008b_last7,
              q3009a,
              q3009b,
              q3009c,
              q3009d,
               q3009e,
               q3009f,
               q3009g,
              q3001_used_tobac,
              q3002_use_tobaco,
              FUM1B,
              depression_12m,
              depression_12treatment,
              depression_lifetime,
              q4211,
              q4222f,
              q4222g,
              q4222h,
              q4222i,
              q4222j,
              q4222k,
              q4222f,
              q4222h,
              q4222i,
              q4222j,
              q4222k,
              q4225_causemed23,
              q4225_causemed24,
              q4225_causemed25,
              q4225_causemed30,
              q4225_causemed31,
              depression_30d,
              q7029_worr,
              q7030_rush,
              q7031_irrit,
              q7032_depr,
              q7033_tense,
              q7069_worr,
              q7070_rush,
              q7071_irrit,
              q7072_depr,
              q7073_tense,
              q7114_worr,
              q7115_rush,
              q7116_irrit,
              q7117_depr,
              q7118_tense,
              SM22_1,
              SM22_2,
              SM22_3,
              SM22_4,
              SM22_5,
              q7034_calm,
              q7035_enjoy,
              q7074_calm,
              q7075_enjoy,
              q7119_calm,
              q7120_enjoy,
              SM22_6,
              SM22_7, 
              q7001_life,
              q7002_senses,
              q7003_health,
              q7004_yourself,
              q7005_daily,
              q7006_relation,
              q7007_home,
              q7008_time,
              SM21,
              q7008d_cantril,
              q4642_talkative,
              q4643_lively,
              q4649_party,
              q4651_meetings,
              q4655_quiet,
              q4657_livelyothers,
              q4641_mood,
              q4646_fedup,
              q4648_nervous,
              q4650_worried,
              q4653_nerves,
              q4656_alone,
              q6351_companion,
              q6352_leftout,
              q6353_isolated,
              SOLO7_1,
              SOLO7_2,
              SOLO7_3,
              q7008a_control,
              q7008b_coping,
              q7518a_quality,
              q7519_sleep,
              SUE2,
              q3045,
              q3046,
              material,
              economy,
              infected,
              COVID1,
              SOLO1_0,
              SOLO1_1,
              SOLO1_2,
              SOLO1_3,
              SOLO1_4,
              SOLO1_5,
              SOLO1_6,
              SOLO1_7,
              SOLO1_9,
              SOLO1_10,
              SOLO1_11,
              SOLO1_12,
              SOLO1_13,
              SOLO1_999,
              rel_concerned,
              COVID4,
              rel_deceased,
              COVID5,
              rel_isolated,
              COVID3,
              severity_raw,
              COVID1B,
              COVID1C_1,
              COVID1C_2,
              unemployment,
              GAD12m,
              GAD,
              q6010a_spouse,
              q6010b_parents,
              q6010c_children,
              q6010g_friends,
              q6010h_neighbours,
              q6010i_grand,
              q6010j_siblings,
              q6010k_inlaw,
              suicidal,
              SOLO4),
      .fns = ~as_factor(.)
)
)
```

# Step 10. Creates Annotations attribute for Opal

```{r}
#TODO: Not recognized in Opal

df <- df %>% mutate(
  across(
    .cols = (function(x) !is.null(attr(x, "label"))),
    .fns = ~{attr(., "Annotations") <- labelled::var_label(.)
    return(.)},
  )
)

pruebas <- attributes(df$q1510e_workday)
print(pruebas)
```

# Step 11. Creates "Label" attribute for Opal

We extract the labels from Variable List RESPOND file. These are the ones that
we want to appear in "label" section on Opal.

```{r}
labels_codebook <- ecs_variablelist %>% 
  select(label, variable) %>%
  drop_na() %>%
  filter(variable %in% colnames(df)) %>% 
  with(., 
       split(label,
             factor(variable, levels = unique(variable))))

labelled::var_label(df) <- labels_codebook
```

# Step 10. Save .RDS

```{r}
saveRDS(df, "./dat/EcS_df.rds")

data_ECS <- readRDS("./dat/EcS_df.rds")
```

```{r}
#Wave 1
w2019 <- df |> filter(wave == 1)
saveRDS(w2019, "./dat/EcS_w2019.rds")

wCOVID <- df |> filter(wave == 2)
saveRDS(wCOVID, "./dat/EcS_wCOVID.rds")
```

# Final. Session info

```{r, results='markup'}
devtools::session_info()
```