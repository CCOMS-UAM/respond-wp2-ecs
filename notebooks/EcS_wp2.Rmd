---
title: "Edad con Salud WP2 dataset harmonization process"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), 'First created on 30 Sept. 2022. Updated on %d de %B de %Y')`"
output:
  html_notebook: 
  toc: yes
  toc_float: yes
institute: CCOMS, Universidad Autónoma de Madrid
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 80
---

# Step 0. Preparation

## Overview

Here, I prepare the full Edad con Salud (2 assessment waves) to be uploaded to
OPAL, as part of RESPOND WP2 IPD meta-analysis. I will follow the [OPAL handbook
for
WP2](https://drzmainz.sharepoint.com/:w:/r/sites/obiba-wp2/Shared%20Documents/harmonisation/data%20upload%20preparation/handbook_datauploadprep.docx?d=w15b8e9fe38734104a507dcedc3af3d49&csf=1&web=1&e=6Hu6Lm)

1.  Inspect the Cohort 2019 and COVID substudy databases.
2.  Harmonization process: 2.1. Create as many new variables as needed, as per
    the OPAL handbook for WP2, for 2019 cohort & COVID subestudy. 2.2. Transform
    variables that require transformation outside the OBIBA environment
    (sentitive data) 2.3. Recode missing data
3.  Merge all the assessment waves in a dataset with a number of rows equal to
    wavesBYparticipants.
4.  Remove all columns that are not included in the RESPOND WP2 codebook.
5.  Create a new hashed ID and remove the old one.
6.  Export a .csv file to be uploaded to OPAL.

## Required libraries

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
library(lubridate)
library(naniar)
library(stringi)
library(readstata13)
library(readxl)
library(ecs.data)
```

## Constants on variable harmonization

*Coding of missing values:*

-   -991 specifies a variable has not been assessed in general (e.g., at this
    point of data collection), so it is missing by design.

-   -992 specifies 'refused to answer' NAs

-   -993 specifies missings (default) from data collections that actually took
    place (eg, this exact questionnaire had been assessed at this timepoint, but
    the participant did not answer for whatever reason).

```{r constants}

MISSING_DESIGN <- -991
REFUSED_ANSWER <- -992 
NON_RESPONSE <- -993

BASELINE_FILEPATH <- file.path(read_ecs_folder("DB"),
                               "Ola_3/Cohorte_2019/rawdata_c2019w1.dta")
COVID_FILEPATH <- file.path(read_ecs_folder("DB"), 
                        "Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")
```

## Data importation

Data is extracted from the OneDrive folders `Bases de datos maestras`. For
RESPOND WP2, the used folders are `Cohort 2019`and `COVID Substudy`. Files are
in .dta format, which is a double format. It contains:

-   the variable type (class)
-   the label (label, part of the metadata)

For ease of work, it is necessary to make variable transformations so that
`value-label` does not interfere, as it doesn't say anything about the
categorical or continuous consideration of the variables.

**Before doing the data analysis it is required to convert the vectors with**
**`value_labels`** into factors, numeric or character vectors. To do this, it is
possible to use `unlabelled()`, `to_factor()` o `unclass()` before data cleaning
or after that, to keep the info in the export process.

The original databases are then imported and copies are created for testing
purposes.

```{r data-importation}
data_2019 <- read_dta(BASELINE_FILEPATH, encoding = "UTF-8")
data_COVID <- read_dta(COVID_FILEPATH)
```

# Step 1. Data inspection

## Checking columns

We check that the variable names are correct, if there are duplicate columns and
if the column names of each wave are unique. This should be the case because of
the nature of the coding of the `Edad con Salud` interviews.

```{r}
raw_2019_colnames <- colnames(data_2019)
raw_COVID_colnames <- colnames(data_COVID)
```

```{r}
intersect(raw_2019_colnames, raw_COVID_colnames)
```

```{r}
print(raw_2019_colnames[duplicated(raw_2019_colnames)])
print(raw_COVID_colnames[duplicated(raw_COVID_colnames)])
```

The variables common to both datasets are `ID_ECS` and `origin`. `ID_ECS` would
be the key variable to join both datasets. There are no duplicates on each
dataset and everything looks perfectly fine on this respect.

```{r}
rm(raw_2019_colnames)
rm(raw_COVID_colnames)
```

## Checking rows

On COVID substudy there's one case that is not on baseline wave. We have to
remove it. Firstly, we detect it using anti_join():

```{r}
id_ecs_subs_notBL <- data_COVID %>%
                anti_join(data_2019, by = "ID_ECS") %>% 
                select(ID_ECS) %>% pull()
```

And then we remove it (is ID_ECS == 6900702)

```{r}
data_COVID <- data_COVID %>% 
  filter(ID_ECS != id_ecs_subs_notBL)
```

Now we duplicate both datasets for testing purposes:

```{r}
data_2019_test <- data_2019
data_COVID_test <- data_COVID
```

## Identifying waves

```{r}
data_2019_test <- data_2019 %>%
              add_column(wave = 1, .before = "ID_ECS")
  
```

```{r}
data_COVID_test <- data_COVID %>%
              add_column(wave = 2, .before = "ID_ECS")
  
```

## Follow-up cases

In order to know what cases are in both waves, we use semi_join:

```{r}
id_ecs_both <- data_COVID_test %>%
               semi_join(data_2019_test, by = "ID_ECS") %>% 
               select(ID_ECS) %>% 
               pull()
```

## Adjusting date format

Date format is important because we are using this variables to create some of
the required variables for RESPOND WP2.

```{r dates-format}
data_2019_test <- data_2019_test %>% 
  mutate(
    q0006_date = lubridate::ymd(q0006_date),
    q1010_birth_date = lubridate::ymd(q1010_birth_date)
  )


data_COVID_test <- data_COVID %>% 
  mutate(
  FECHAFIN = lubridate::dmy(FECHAFIN)
)  
  
birthday <- data_2019_test %>% 
  mutate(
    q1010_birth_date = lubridate::ymd(q1010_birth_date)) %>% 
  select(q1010_birth_date) %>% 
  pull()

interview2019 <- data_2019_test %>% 
      select(q0006_date) %>% 
      pull()

interviewcovid <- data_COVID_test %>% 
    select(FECHAFIN) %>% 
    pull()
  
```

# Step 2. Wave 1 harmonization

Variables to be harmonized are the following:

-   Gender
-   coresidence
-   Migration
-   Age: categorical
-   Age: continuous
-   Employment status
-   Type of contract
-   Employment type
-   Healthcare workers
-   Profession
-   Education
-   Relationship status
-   Children
-   Children household
-   Number of children
-   Living alone
-   Household
-   Income quartiles
-   Income quintiles
-   NUTS code - left for when we have both waves harmonised

## 2.1. Gender

**Self-identified gender** - 1: male - 2: female - 3: other/diverse -991: not
assessed -992: refused to answer -993: missing (default)

Our categories are: - 1 = male; - 2 = female (the question is not about the
self-identified gender, but sex).

### Variable exploration

```{r}
data_2019 %>%
  freq_table(q1009_sex)

data_2019 %>%
  select(q1009_sex) %>%
  summarise_all(funs(sum(is.na(.))))
```

### Variable harmonization

In this case we simply rename this variable and convert it into a factor,
changing the labels as they are the same (the ones we have and the proposed
ones)

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(gender = factor(x = q1009_sex,
                          levels = c("1", "2", "3", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("male", 
                                    "female",
                                    "other/diverse",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(gender)
```

## 2.2 Country of residence

There's no variable from which to create, but knowing that all participants are
from Spain, we can do it from scratch. This variable should be complemented with
the NUTS code (see below/later on on this script).

### Variable harmonization

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    coresidence = "ES"
  )
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(coresidence)
```

## 2.3. Migration

**Country of birth other than country of residence**: - 1 = Yes - 2 = No - 3 =
No information - 991 = missing by design - 992 = refused to answer - 993 =
missing (default)

Our variable has registered the name of each country. As we did the sample
collection in Spain, we can assume that responses that are different than Spain
are indicators of migration.

### Variable exploration

```{r}
data_2019 %>%
  select(q1018_country) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>% 
  freq_table(q1018_country) # 1 = Spain, !1 = other countries
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    migration = if_else(q1018_country == 1, 2, 1), 
    migration = factor(x = migration,
                       levels = c("1", "2", "3", MISSING_DESIGN,
                                                REFUSED_ANSWER, 
                                                NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "no information",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(migration)
```

## 2.4. & 2.5. Age

The variable `age_continuous` is a continuous variable (1-100). `age_cat` is the
categorical version with the following levels:

-   \< 18
-   18 - 44
-   45 - 64
-   65 - 94
-   \> 95

### Variable exploration

To create these variables we are going to use `q1010_birth_date` and `q1011_age`
because there are some IDs that their information on birthdate is lost. Firstly,
we create a vector that contains those IDs.

```{r}
ID_NAs <- c(
  18702401,
  5600601,
  3100602,
  18702701,
  2802002,
  17801501,
  16602601,
  5800201,
  19600501,
  3300201,
  7101202,
  7101401,
  14300101,
  16800301
) 
```

For those cases, we have the corect information on variables `age` and
`q1010_year` (birthdate - year).

```{r}
data_2019 %>%  
  filter(ID_ECS %in% ID_NAs) %>% 
  select(q1010_birth_date, q1011_age, q1010_year, q1010_month, q1010_day) %>% 
  View()
```

### Variables' creation

The next steps were followed: 1. Create the difference in years between
birthdate and 2019 interview date (in years). 2. Create `age_continuous`: if we
have the complete information, use the diff. just created to stablish the age of
the participants; if this data is missing, use `q1011_age`. 3. Create `age_cat`
by recategorizing `age_continuous`.

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    diff_bday_int = year(interview2019) - year(birthday),
    diff_bday_int = as.double(diff_bday_int),
    age_continuous = if_else(
                        ID_ECS %in% ID_NAs, q1011_age, 
                        diff_bday_int
                        ),
    age_cat = case_when(
           age_continuous < 18 ~ 1,
           age_continuous >= 18 & age_continuous <= 44 ~ 2,
           age_continuous >= 45 & age_continuous <= 64 ~ 3,
           age_continuous >= 65 & age_continuous <= 94 ~ 4, 
           age_continuous >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels = c("1", "2", "3", "4", "5",
                                     MISSING_DESIGN,
                                     REFUSED_ANSWER,
                                     NON_RESPONSE),
                          labels = c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(age_cat)

data_2019_test %>% 
  select(age_continuous, age_cat, q1011_age, q1010_birth_date) %>% 
  View()

#TODO: There are some cases where the continuous age is a higher number than the
#established age. 
```

## 2.6. Employment status (`q1503_work_now` & `q1504_reason`.)

**Employment status** has the following levels:

-   1 = Have a job (employed or self-employed)
-   2 = In education
-   3 = Care work (family) / homeworker/ on parental leave
-   4 = On long-term sick leave/disability
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
-   6 = unemployed or job-seeking
-   7 = retired

-991 = not assessed -993 = missing (default)

`q1503_work_now` (c2019_w1) *Currently working?*: - 1 = Yes - 2 = No

`q1504_reason` (c2019_w1) *Reason not working*:

-   1 = homemaker
-   2 = couldn't find a job
-   3 = unpaid/voluntary
-   4 = studies/training
-   5 = health
-   6 = care family
-   7 = no need
-   8 = not permitted
-   9 = retired/too old
-   10 = laid off
-   11 = seasonal work
-   12 = does not want to for a while
-   13 = vacation/sick or maternity leave
-   87 = other.

As a proposal, the re-categorization to be done has to be: - 1 = Have a job
(employed or self-employed) == `1 (q1503_work_now)` - 2 = In education
(currently studying) == `4 (q1504_reason)` - 3 = Care work (family) / homeworker
/ on parental leave == `1, 6` `(q1504_reason)`\*\* - 4 = On long-term sick
leave/disability == `5 (health) (q1504_reason)`, - 5 = Unable to work due to
reasons not mentioned elsewhere in this list (other) ==
`3 (unpaid/voluntary), 7 (no need), 8 (not permitted), 11,`
`12 (does not want to for a while), 13, 87 (other)` - 6 = unemployed or
job-seeking == `2 (couldn't find a job), 10 (laid off)`, `11 (seasonal work)`, -
7 = retired == `9 (retired/too old)`

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    employment_st = case_when(
      q1503_work_now == 1 ~ 1,
      #have a job
      q1504_reason == 4 ~ 2,
      #studying
      q1504_reason == 1 | q1504_reason == 6 ~ 3,
      #care work
      q1504_reason == 5 ~ 4,
      # on long term sick leave disability
      q1504_reason == 3 |
        q1504_reason == 7 |
        q1504_reason == 8 |
        q1504_reason == 11 |
        q1504_reason == 12  |
        q1504_reason == 13 | q1504_reason == 87 ~ 5,
      #other reasons
      q1504_reason == 2 |
        q1504_reason == 10 | q1057 == 11 ~ 6,
      #unemployed or job-seeking
      q1504_reason == 9 ~ 7,
      #retired,
      is.na(q1504_reason) |
        is.na(q1503_work_now) ~ NON_RESPONSE
    ),
    employment_st = factor(
      x = employment_st,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "have a job (employed or self-employed)",
        "in education",
        "care work (familiy) / homeworker/ on parental leave",
        "on long-term sick leave/disability",
        "unable to work due to reasons not mentioned elsewhere in this list",
        "unemployed or job-seeking",
        "retired",
        "not assessed",
        "refused to answer",
        "missing (default)"
      )
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(employment_st) %>%
  freq_table(employment_st)
```

## 2.7. Contract (q1510b_contract_earner)

**Permanent/temporary contract**

Changes made after consulting with IPD-Respond team:

-   1 officer ===== 1 permanent
-   2 indefinite period (not officer) ===== 4 (other)
-   3 temporal or contract of works and services ===== 2 temporary
-   4 verbal or without contract ===== 4
-   888 DK ===== -993
-   999 refused to answer ===== -992

### Variable exploration

```{r}
data_2019 %>%
  select(q1510b_contract_earner) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  freq_table(q1510b_contract_earner)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(contract = case_when(
        q1510b_contract_earner == 1 ~ 1, #officer --> permanent
        q1510b_contract_earner == 3  ~ 2, #temporal or contract of works and services --> temporary
        q1510b_contract_earner == 4 |
        q1510b_contract_earner == 2 ~ 4, #verbal or without contract & indefinite period (not officer) --> other
        q1510b_contract_earner == 888 ~ NON_RESPONSE, 
        q1510b_contract_earner == 999 ~ REFUSED_ANSWER,
        is.na(q1510b_contract_earner) ~ NON_RESPONSE

         ),
          contract = factor(x = contract,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
 )))

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(contract)
```

## 2.8. Employment type (`q1510_workday`)

-   1 - Full time
-   2 - Part time
-   3 - No paid work
-   4 - Other
-   -991 not assessed
-   -992 refused to answer
-   -993 missing (default)

In EcS (`q1510_workday`):

-   1 Part time (morning and afternoon) ===== 2
-   2 Continuous morning working day ===== 1
-   3 Continuous afternoon working day ===== 1
-   4 Continuous night working day ===== 1
-   5 Reduced work day ===== 4
-   6 Shift work / irregular or variable work ==== 4
-   7 Other type ==== 4
-   888 DK ==== -992

### Variable exploration

```{r}
data_2019 %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>%
  freq_table(q1510e_workday)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(employment_ty = case_when(
       q1510e_workday == 1 ~ 2, #part time --> part time
       q1510e_workday == 2 ~ 1, #continuous morning working day --> full time
       q1510e_workday == 3  ~ 1, #continuous afternoon working day --> full time
       q1510e_workday == 4 ~ 1, #continuous night working day --> full time
       q1510e_workday == 5 ~ 4, #reduced work day --> other
       q1510e_workday == 6 ~ 4, #shift work --> other
       q1510e_workday == 7 ~ 4, #other --> other
       q1510e_workday == 888 ~ REFUSED_ANSWER,
        is.na(q1510e_workday) ~ NON_RESPONSE

         ),
          employment_ty = factor(x = employment_ty,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
 )))


```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(employment_ty)
```

## 2.9. HC worker

\*defined as: *A healthcare worker is anyone who works in a healthcare or
social* *care setting, including healthcare students on clinical placement,
frontline* *healthcare workers and other healthcare workers not in direct
patient contact.*

*These settings include, but are not limited to, state-funded and private*
*organisations providing services in the following areas: disability, older*
*persons, nursing homes, acute and non acute hospitals, community hospitals,*
*mental health, social inclusion, palliative care, chronic illness, primary
care* *(GP, dental, pharmacies, physiotherapy clinics), health and well being,
hospice,* *rehabilitation, home care, paramedics, and community services (e.g.
youth,* *substance abuse, suicide prevention, community development).*

HC_worker has to be a dichotomous variable that indicates if a participants fits
in the previous definition (1 = yes; 2 = no). In EcS we have `q1510_occ`on base-
line, which indicates in a free-text variable the occupation of the
participants. `q1510_catoccu` uses the CIUO-08 (ISCO codes from OIT) from
categorize the occupations of the participants.

To proceed, we follow the next steps:

1.  Explore unique values of this variable & see if `q1510_catoccu`is useful.
2.  Extract patterns that are of our interest.
3.  Create the new variable.

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_occ, q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.)))) #Both variables has the same NAs, 
#only is just that on the free-text variable, NAs looks like "".
```

```{r}
occ_unique <- data_2019 %>%
  select(q1510_occ) %>%
  distinct()  
```

```{r}
View(occ_unique)
```

There are 1824 unique values for this variable and 347 NAs (in both variables;
in free-text they appear as ""). This would be useful in order to process the
variable"profession" later on.

`q1510_catoccu`indicates the categorization of the 10 main groups, but not the
subcategories, which are the ones that could be interesting to use. We'll try if
using it as a filter is useful.

Barely it does, as the principal category of our interest leaves out interesting
occupations (e.g., auxiliar de enfermería), which are on groups 2, 3, 7, 8. As
it doesn't allow us to differentiate health care workers from other
professionals, we'll just work with `q1510_occ`and explore manually all the
free-text unique values. The ones that are interesting for us are on
`"HC_workersCat.txt"`.

To facilitate pattern detection, we convert to lowercase all the values of
`q1510_occ` using `str_to_lower()`de `stringr`. To eliminate accents,
`stri_trans_general(x, "Latin-ASCII")`.

```{r}
data_2019_test %>% 
  mutate(
    q1510_occ_utf8 = as_utf8(q1510_occ),
    q1510_occ_utf8 = str_to_lower(q1510_occ_utf8, locale = "spa"),
    q1510_occ_itf8 = stringi::stri_trans_general(q1510_occ_utf8, "Latin-ASCII")
  ) %>% 
  select(q1510_occ, q1510_occ_utf8) %>% 
  View()
```

### Variable creation

Import the .txt that has all the responses to create HC_workers:

```{r}
library(readr)
occ_unique <- read_delim("C:/Users/Cristina/Downloads/HC-workerCat.txt", 
     delim = "\t", escape_double = FALSE, 
     col_names = FALSE, trim_ws = TRUE)
```

```{r}
data_2019_test <- data_2019 %>% 
  mutate( 
    hc_worker = if_else(q1510_occ %in% occ_unique$X1, 1, 2),
    hc_worker = factor(x = hc_worker,
                                  levels = c("1", "2",
                                             MISSING_DESIGN, 
                                             REFUSED_ANSWER, 
                                             NON_RESPONSE),
                                  labels = c("yes",
                                            "no",
                                            "not assessed",
                                            "refused to answer",
                                            "missing (default)"
                                            )))
#TODO: Explore another way of doing this using stringr (str_detect); maybe there
#are some values that we just missed.
```

### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(hc_worker)
```

## 2.10. Profession (q1510_catoccu)

**Best description of current occupation(s)** We will include this variable in
raw format in the database just for knowing levels of OIT categorization rather
than sector. Following recommendations of IPD-RESPOND team, we would try to keep
assumptions to a minimum and when in doubt, code things as other:

-   1 Legislators === 7 (civil services, politics)
-   2 Professionals === 14 (others)
-   3 Technicians ==== 14 (others)
-   4 Clerks ===== 12 (installation, maintenance, cleaning and repairs)
-   5 Service workers ==== 5 (first responder: paramedic/firefighter/police)
-   6 Skilled agricultural workers ==== 14 (others)
-   7 Craft workers ==== 14 (others)
-   8 Plant operators ==== 14 (other)
-   9 Elementary occupations ==== 14 (others)
-   10 Armed forces === 6 (military)

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  freq_table(q1510_catoccu) 
```

### Variable creation

```{r}
#Creamos la variable
data_2019_test <-
  data_2019_test %>%
  mutate(
    profession = case_when(
      q1510_catoccu ==  5  ~  5 ,
      #service workers --> first responders: paramedic/firefighter/police
      q1510_catoccu ==  10  ~  6 ,
      #armed forces --> military
      q1510_catoccu ==  1  ~  7 ,
      #legislators --> civil services, politics
      q1510_catoccu ==  4  ~  12 ,
      #clerks --> installation, maintenance, cleaning and reparis
      q1510_catoccu ==  8 |
        q1510_catoccu ==  3 |
        q1510_catoccu ==  6 |
        q1510_catoccu ==  7 |
        q1510_catoccu ==  9 |
        q1510_catoccu ==  2  ~  14,
      #others
      is.na(q1510_catoccu) ~ NON_RESPONSE
      
    ),
    profession = factor(
      x = profession,
      levels = c(
        "1",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "11",
        "12",
        "13",
        "14",
        MISSING_DESIGN,
        REFUSED_ANSWER,
        NON_RESPONSE
      ),
      labels = c(
        "undergoing education",
        "education and research",
        "arts, entertainment, sports and media",
        "healthcare",
        "first responder (paramedic/firefighter/police)",
        "military",
        "civil services, politics",
        "finance and economy",
        "industry",
        "sales and services (incl. restaurants and bars)",
        "transport (goods and people)",
        "installation, maintenance, cleaning, and repairs",
        "currently not working",
        "other",
        "not assessed",
        "refused to answer",
        "missing (default)"
      )
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(profession)
#TODO: 1429 as "others"
```

## 2.11. Education (q1016_highest)

**Highest level of education according to ISCED Classification**:

-   1 = primary/basic: (primary education and lower secundary education)
-   2 = secondary/intermediate: (upper secondary education, post-secondary
    non-tertiary education)
-   3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or
    equivalent level, master's or equivalent level, doctoral or equivalent
    level)
-   4 = no formal education / less than basic (no schooling, early childhood
    education) -991 = not assessed -993: level not stated - if following yellow
    box, if not, "missing (default)"

Our variable, `q1016_highest`, has as levels (doesn't have *non-tertiary
education*): - 0 = No formal education - 1 = Primary education not completed - 2
= Primary education completed - 3 = Lower secondary education completed - 4 =
Upper secondary education completed - 5 = University/college completed - 6 =
Master degree, PhD completed - 888 = don't know

As a proposal, I suggest:

-   1 = primary/basic --\> 1, 2, 3
-   2 = secondary/intermediate --\> 4
-   3 = tertiary/advanced --\> 5, 6
-   4 = no formal education / less than basic: 0

## Variable exploration

```{r}
data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs, but 888 as DK.

data_2019 %>% 
  freq_table(q1016_highest)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(
    education = case_when(
      q1016_highest == 0 ~ 4,
      q1016_highest == 1 |
        q1016_highest == 2 | q1016_highest == 3 ~ 1,
      q1016_highest == 4 ~ 2,
      q1016_highest == 5 | q1016_highest == 6 ~ 3,
      q1016_highest == 888 ~ NON_RESPONSE,
    ),
    education = factor(
      x = education,
      levels = c("1", "2", "3", "4", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
      labels = c(
        "primary/basic",
        "secondary/intermediate",
        "tertiary/advanced",
        "no formal education",
        "not assessed",
        "refused to answer",
        "missing (default)"
      )
    )
  )

```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(education)
```

## 2.12. Relationship status (q1012_mar_stat)

**Relationship status** is a categorical variable with the following levels:

-   1 = Single
-   2 = Married /in a civil union
-   3 = in a relationship and living together
-   4 = in a relationship and living apart
-   5 = divorced/separated
-   6 = widowed
-   7 = other

Our variable `q1012_mar_stat` is coded as:

1 = never married (and no cohabiting)
2 = currently married/law-partner
3 = cohabiting
4 = separated/divorced
5 = widowed

As the categories doesn't match exactly, I propose the following categorisation:

-   1 = single --\> 1 (never married and no cohabiting)
-   2 = married / in a civil union --\> 2 (currently married/law-partner)
-   3 = in a relationship and living together --\> 3 (cohabiting)
-   4 = in a relationship and living apart --\> MISSING_DESIGN
-   5 = divorced/separated --\> 4 (separated/divorced)
-   6 = widowed --\> 5 (widowed)
-   7 = other --\> MISSING_DESIGN

### Variable exploration

```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  freq_table(q1012_mar_stat)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(relationship = case_when(
           q1012_mar_stat == 1 ~ 1,
           q1012_mar_stat == 2 ~ 2,
           q1012_mar_stat == 3 ~ 3,
           q1012_mar_stat == 4 ~ 5, 
           q1012_mar_stat == 5 ~ 6,
         ), 
         relationship = factor(x = relationship,
                          levels = c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, REFUSED_ANSWER, NON_RESPONSE),
                          labels = c("single", 
                                    "married/in a civil union",
                                    "in a relationship and living together",
                                    "in a relationship and living apart",
                                    "divorced/separated",
                                    "widowed",
                                    "other",
                                    "not assessed", 
                                    "refused to answer",
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  freq_table(relationship)
```
