---
title: "Preparando el archivo variable_list con los datos de Edad con Salud"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), '%d de %B de %Y')`"
output:
  html_notebook: null
  toc: yes
  toc_float: yes
  keep_md: yes
  html_document:
    df_print: paged
institute: CCOMS, Universidad Autónoma de Madrid
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 80
---

# Preparación

## Librerías necesarias

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
library(readstata13)
library(stringi)
install.packages("utf8")
library(utf8)
```

## Constantes en la armonización de variables

Valores perdidos: Coding of missing values: -91 specifies a variable has not
been assessed in general (eg, at this point of data collection), so it is
missing by design. -93 specifies missings (default) from data collections that
actually took place (eg, this exact questionnaire had been assessed at this
timepoint, but the participant did not answer for whatever reason).

```{r constantes}

MISSING_DESIGN <- -991
NON_RESPONSE <- -993

```

## Lectura de datos

Los datos se extraen de las carpetas de OneDrive "Bases de datos maestras". Se
encuentran en formato .dta, que es un formato doble - por un lado, tipo de
variable (class) y por otro, la etiqueta (label, parte de los metadatos). Esto
hace que sea un poco complicado trabajar con estas variales, ya que los
`value- labels` no se utilizan para el análisis de los datos (no suponen una
implicación) sobre la consideración categórica o continua de las variables.

**Antes de hacer un análisis de datos es necesario convertir los vectores con**
**value_labels en factores, numéricos o caracteres**. Es un paso que se puede
hacer desde el principio con `unlabelled()`, `to_factor()` o `unclass()`, o
cuando ya se ha hecho la limpieza de datos y se quiere mantener esa info en la
exportación.

A continuación se importan las BBDD originales y se duplican para hacer pruebas
conservando lo anterior.

```{r}
data_2019 <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Ola_3/Cohorte_2019/rawdata_c2019w1.dta")

data_COVID <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")

data_2019_test <- data_2019 #Hago una copia del dataset original para probar cosas.
```

```{r}
data_2019 <- read.dta13("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Ola_3/Cohorte_2019/rawdata_c2019w1.dta", encoding = "UTF-8", fromEncoding = "CP1252")

data_COVID <- read.dta13("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta", encoding = "UTF-8", fromEncoding = "CP1252", nonint.factors = F)

data_2019_test <- data_2019
data_COVID_test <- data_COVID
```


# El archivo variable_list

Este archivo reúne **todas las variables** que tiene cada estudio. Es necesario
comprobar que todos los outcomes están incluidos (ver los archivos [mental
health
outcomes](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7BA66AD0BE-D072-4CB3-8072-F4FF5C92BF9D%7D&file=mental_health_measures_hs.xlsx&action=default&mobileredirect=true)
y
[predictores](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7B37F195E1-399B-48CE-9E11-5B2B8B83B210%7D&file=predictor_candidates_by_study_hs.xlsx&action=default&mobileredirect=true)
para comprobar que está todo lo que tiene que estar).

# Cambios a realizar

## CREATE HC WORKER from baseline wave using q1510_occ -wave 1)

HC Workers (health-care workers) es una variable dicotómica (1 = yes, 2 = no)
que se crea a partir de `q1510_occ` con los datos de la línea base. Este ítem de
formato abierto indica la ocupación en texto libre de los participantes.

Para proceder con esta variable establecemos distintos pasos.

1.  Explorar los valores únicos que tiene esta variable u otras que puedan ser
    de utilidad.
2.  Filtrar aquellos relativos a los "HC-workers"
3.  Crear la nueva variable.

### Exploración de variables

Exploramos la variable `q1510_occ`:

```{r}
glimpse(data_2019$q1510_occ)

data_2019 %>%
  select(q1510_occ) %>%
  distinct()

data_2019 %>%
  select(q1510_occ, q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.)))) #Los NAs coinciden entre ambas; en 
#respuesta abierta son "".
```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(is.na(q1510_catoccu)) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(ID_ECS == 10300401) %>% 
  select(q1510_occ) %>% 
  View()

```

Esta variable contiene 1824 valores únicos  Y 347 valores perdidos. Exploramos otras variables del
cuestionario que permitan extraer la ocupación. En la BBDD hay otra variable,
`q1510_catoccu` que utiliza la estructura de la CIUO-08 (códigos ISCO, de la
OIT). Nos interesa la categorización:

**GRUPO 2: "PROFESIONALES CIENTÍFICOS E INTELECTUALES" \> PROFESIONALES DE LA**
**SALUD**

Exploramos `q1510_catoccu`

```{r}
glimpse(data_2019$q1510_catoccu)

data_2019 %>%
  select(q1510_catoccu) %>%
  distinct()

freq_table(data_2019, q1510_occ)

```

Esta variable sólo contiene la categorización de los 10 grupos principales, no
de los subgrupos. Por tanto, tenemos que descartar esta variable porque no nos
permite diferenciar los profesionales de la salud de otros profesionales y se
tiene que trabajar con la variable `q1510_occ`.


Para facilitar la detección de patrones, convertimos a minúsculas todos los
caracteres utilizando `str_to_lower()`de `stringr`. En el caso de que exista
textos con tildes, estas se pueden eliminar utilizando el siguiente comando: `stri_trans_general(x, "Latin-ASCII")`.

```{r}
data_2019_test %>% 
  mutate(
    q1510_occ_utf8 = as_utf8(q1510_occ),
    q1510_occ_utf8 = str_to_lower(q1510_occ_utf8, locale = "spa"),
    q1510_occ_itf8 = stringi::stri_trans_general(q1510_occ_utf8, "Latin-ASCII")
  ) %>% 
  select(q1510_occ, q1510_occ_utf8) %>% 
  View()

```

**IMPORTANTE** NO FUNCIONA UTF-8.


Vamos a crear una nueva variable con los
valores de `q1510_occ` filtrado a través de `q1510_catoccu`, teniendo en cuenta
esta consideración.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(as.numeric(q1510_catoccu) %in% c("2")) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View() #asignarlo a un objeto y luego imprimirlo
```

Aquí faltan algunas opciones (e.g., auxiliar de enfermería... que hemos visto
que existen. Vamos a filtrar por los que tengan un valor perdido en esta
variable.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(q1510_occ == "auxiliar de enfermeria") %>% 
  select(q1510_occ, q1510_catoccu) %>% 
  View()
```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(as.numeric(q1510_catoccu) %in% c("2", "3", "7", "8") ) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```

Con este filtro \^ obtenemos 1180 registros. Interesantes, en total, 69 casos.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```

Aquí no filtramos por categorías, vemos todos los casos (3002 observaciones).

Después de explorar "a mano" todas las respuestas abiertas, todas las de 
interés se encuentran en HC-workers.txt y su potencial categorización para 
posteriormente extraer patrones en HC_workersCat.txt.

### Utilizando expresiones regulares

`RegExplain` es un *addin* de R para manipular expresiones regulares y analizar
variables de texto libres (los valores únicos). Algunos de los primeros valores
que nos resultan de interés para la creación de esta variable son:

*SADSERVICIO ATENCION DOMICILIARIA enfermera mÃ©dica cardiÃ³loga* *medico
traumatologo auxiliar enfermera auxiliar de enfermeria* *MÃ©dico homeÃ³pata*

Estas han sido extraídas manualmente de los 100 primeros valores de los valores
únicos que tiene esta variable, pero necesitamos las 1824 disponibles:

```{r}
data_2019$q1510_occ %>% 
  str_extract_all("enf", simplify = T) 
```

Esto no ha funcionado.

<!-- TODO! -->

<!-- -   [ ] Buscar una manera de automatizarlo. -->

<!-- -   [X] Crear un dataset sólo con la variable `q1510_occ` filtrada a través de <!--         `q1510_catoccu` == 2, que resuma las ocupaciones de las personas que han -->

<!--      marcado esa categoría. Esto tiene el problema de que no todas las ocupaciones HC son 2. Se ha propuesto una lista de ítems que pueden ser interesantes, revisar con Dani.-->

<!-- - [ ] Incluir los nuevos ítems una vez la decisión esté tomada (Ver archivo HC-workers.txt). -->


### Creación de la variable

La idea es crear una nueva variable de manera que el patrón detectado suponga un
1, y el resto un 0:

```{r}
data_2019_test <- data_2019 %>%
                    mutate( # 1 = mental health worker; 0 = non mental health worker
                      occ_mhw = if_else(str_detect(q1510_occ, "enf"), 1,
                                        if_else(str_detect(q1510_occ, "med"), 1,
                                                if_else(str_detect(q1510_occ, "traum"), 1, 
                                                        if_else(str_detect(q1510_occ, "aux"), 1,
                                                                ifelse(str_detect(q1510_occ, "SADSERVICIO"), 1, 2)))))
                    )
glimpse(data_2019_test$occ_mhw)  #Funciona
```

Tareas pendientes:

-   [ ] Terminar de incluir todos los valores únicos.

## CREATE INCOME QUINTILES (HHQUINTILE) - wave 1

Las variables relacionadas con los ingresos que se manejan en esta BBDD son:

-   `q0410g_total`: ingresos personales brutos de todos los miembros de su
    familia durante los últimos 12M.
-   `q0410i_ss`: ingresos brutos de su hogar durante los últimos 12M procedentes
    de la pensión de jubilación.
-   `q0410j_government`: ingresos brutos de su hogar (...) procedentes de progra
    mas oficiales (paro, hijos dependientes, viudedad, orfan- dad, asistencia
    general)
-   `q0410k_other`: de fuentes privadas (pensiones, inversiones, alimenticias o
    de mantenimiento).

Se descarta `q1519` para este fin porque pregunta por la situación financiera en
la infancia.

### Exploración de variables

Vemos cuántos valores únicos hay por cada variable y las representamos gráfica-
mente. Se trata de una variable categórica que representa rangos. Se encuentran
34 valores distintos dentro de esta variable.

```{r}
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),
               names_to = "income", 
               values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)
```

```{r}
g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4)
```

-   [ ] Ver si existe alguna manera de simplificar este proceso.

#### Recodificación de la variable

Para proceder con el tratamiento de esta variable, Dani me envía su script
`Edad_con_Salud_Data.R`. La idea que se extrae de ese script es recodificar
estas cuatro variables por la mediana del rango establecido para poder sumarlas
y crear los quintiles en base a esto.

Debido al doble formato de Stata, primero convertimos las variables a numéricas
y luego a factores.

```{r}
data_2019_test %>% 
  mutate(
    q0410g_total = as.numeric(q0410g_total),
    q0410i_ss = as.numeric(q0410i_ss),
    q0410j_government = as.numeric(q0410j_government),
    q0410k_other = as.numeric(q0410k_other),
    
    q0410g_total = as.factor(q0410g_total),
    q0410i_ss = as.factor(q0410i_ss),
    q0410j_government = as.factor(q0410j_government),
    q0410k_other = as.factor(q0410k_other)
  )
```

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE, 
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )
```

Encontramos que la recodificación que se ha hecho no es la que buscábamos,
aunque si seleccionamos dos variables (original y recodificada) vemos que
podemos hacer otras cosas para seguir operando:

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410g_total_r) %>% 
  View()
```

Se han modificado los levels, pero no las labels. En cualquier cosa, para seguir
avanzando, tenemos que convertirlo a carácter y luego a integer:

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_total_r = as.character(q0410g_total_r),
        q0410i_ss_r = as.character(q0410i_ss_r),
        q0410j_government_r = as.character(q0410j_government_r),
        q0410k_other_r = as.character(q0410k_other_r),
        
        q0410g_total_r = as.integer(q0410g_total_r),
        q0410i_ss_r = as.integer(q0410i_ss_r),
        q0410j_government_r = as.integer(q0410j_government_r),
        q0410k_other_r = as.integer(q0410k_other_r)
  )
```

Necesitamos crear otra variable a partir de esta teniendo en cuenta los -92 y
-93 con missing para que no se tengan en cuenta a la hora de calcular los
quintiles, utilizando na_if().

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_tot_NA = na_if(q0410g_total_r, NON_RESPONSE),
        q0410i_ss_NA = na_if(q0410i_ss_r, NON_RESPONSE),
        q0410j_gov_NA = na_if(q0410j_government_r, NON_RESPONSE),
        q0410k_other_NA = na_if(q0410k_other_r, NON_RESPONSE)
)
```

Una vez que tenemos esto, ya podemos continuar operando.

#### Creación de la variable

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
    hh_income_r_NA = q0410g_tot_NA + q0410i_ss_NA + q0410j_gov_NA + q0410k_other_NA)

glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r_NA)
```

<!-- Calculamos los quintiles con `quantile(x)` y guardamos únicamente los valores de -->
<!-- los quintiles para acceder a través de ellos con los corchetes. -->

<!-- ```{r} -->
<!-- quintiles <- quantile(data_2019_test$hh_income_r_NA, na.rm = T) -->
<!-- quintiles <- unname(quintiles) -->
<!-- ``` -->

No hace falta calcular a mano los quintiles, sino que tenemos que utilizar 
los proporcionados por EUROSTAT.


```{r}
# income <- 
#   tibble(
#   year = as.double(c("2018", "2019", "2020")),
#   quintile_1 = c(8549, 8847, 9449),
#   quintile_2 = c(12647,12997,13840),
#   quintile_3 = c(17064,17422,18526),
#   quintile_4 = c(23666,24104,25189),
#   quartile_1 = c(9509,9816,10562),
#   quartile_2 = c(14785,15015,16043),
#   quartile_3 = c(21656,22024,23295)
# )

quintiles19 <- c(8847, 12997, 17422, 24104)
cuartiles19 <- c(9816, 1501, 22024)
```




Recodificamos en quintiles:

```{r}
# data_2019_test <- data_2019_test %>%
#   mutate(hhquintile =
#            if_else(hh_income_r_NA <= quintiles[1], 1,
#                     if_else(hh_income_r_NA > quintiles[1] & hh_income_r_NA <= quintiles[2], 2,
#                             if_else(hh_income_r_NA > quintiles[2] & hh_income_r_NA <= quintiles[3], 3,
#                                     if_else(hh_income_r_NA > quintiles[3] & hh_income_r_NA <= quintiles[4], 4,
#                                             if_else(hh_income_r_NA > quintiles[4] & hh_income_r_NA <= quintiles[5], 5, NA
#                                                     ))))))

data_2019_test <- data_2019_test %>% 
  mutate(hhquintile = case_when(
                          hh_income_r_NA <= quintiles19[1] ~ 1,
                          hh_income_r_NA > quintiles19[1] & hh_income_r_NA <= quintiles19[2] ~ 2,
                          hh_income_r_NA > quintiles19[2] & hh_income_r_NA <= quintiles19[3] ~ 3,
                          hh_income_r_NA > quintiles19[3] & hh_income_r_NA <= quintiles19[4] ~ 4,
                          hh_income_r_NA > quintiles19[4] ~ 5,
                          is.na(hh_income_r_NA) ~ NON_RESPONSE
    
  ),
        hhquartile = case_when(
                          hh_income_r_NA <= cuartiles19[1] ~ 1,
                          hh_income_r_NA > cuartiles19[1] & hh_income_r_NA <= cuartiles19[2] ~ 2,
                          hh_income_r_NA > cuartiles19[2] & hh_income_r_NA <= cuartiles19[3] ~ 3,
                          hh_income_r_NA > cuartiles19[3] ~ 4,
                          is.na(hh_income_r_NA) ~ NON_RESPONSE
        ))
```

```{r}
glimpse(data_2019_test$hhquintile)
data_2019_test %>% 
  select(hhquintile) %>% 
  freq_table(hhquintile)

glimpse(data_2019_test$hhquintile)
data_2019_test %>% 
  select(hhquartile) %>% 
  freq_table(hhquartile)

str(data_2019_test$hhquintile)
class(data_2019_test$hhquintile)
```

Hacemos que los NAs sean, de nuevo, NON_RESPONSE:
<!-- Esto no funciona -->
```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    hhquintile = case_when(
                        hhquintile == 1 ~ 1, 
                        hhquintile == 2 ~ 2, 
                        hhquintile == 3 ~ 3, 
                        hhquintile == 4 ~ 4,
                        hhquintile == 5 ~ 5, 
                        is.na(hhquintile) ~ NON_RESPONSE
  ))

```

Comprobamos:

```{r}
glimpse(data_2019_test$hhquintile)
data_2019_test %>% 
  select(hhquintile) %>% 
  freq_table(hhquintile)
```

<!-- -   [X] Ver si se puede utilizar con case_when() -->

<!-- -   [X] Hacer otra reconversión teniendo en cuenta el valor de hh_income_r para -->

<!-- <!--     volver a los -993 (última codificación a 20/10/2022) -->

<!-- Ver también funciones de interés: cut() y coalesce() -->

<!-- COMPLETA! -->

## STRESSOR (LIFE EVENTS)

La variable combinada es `lte` (está creada y habrá que importarla en la base de
datos final). Las variables individuales son:

-   q4659_ill
-   q4660_illrelative
-   q4661_died
-   q4662_diedrelative
-   q4663_separation
-   q4664_brokeoff
-   q4665_problem
-   q4666_unemployed
-   q4667_sacked
-   q4668_financial
-   q4669_police
-   q4670_stolen

No se necesita armonización previa; se trabajará una vez que esté en Opal.

```{r}
data_2019_test %>% 
  select(q4659_ill,
          q4660_illrelative, 
          q4661_died, 
          q4662_diedrelative, 
          q4663_separation, 
          q4664_brokeoff, 
          q4665_problem, 
          q4666_unemployed, 
          q4667_sacked, 
          q4668_financial, 
          q4669_police,
          q4670_stolen) %>% 
  View()
```

-   [x] Añadir en variable_list.xlsx una fila por cada ítem por separado.

## LIVING ALONE (q0401_hh_total) - wave 1

**¿Cuál es el número total de personas que viven habitualmente en este hogar?**
Dos categorías: - 1 = alone; - 2 = not alone.

En ECS partimos de `q0401_hh_total`, que es una variable cuantitativa del 1 al
10.

### Exploración de variables

```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total)

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos
```

### Creación de la variable

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(living_alone = if_else(q0401_hh_total == 1, 1, 2),
         living_alone = factor(x = living_alone,
                               levels = c("1", "2"),
                               labels = c("alone", "not alone"))) %>%
  select(living_alone) %>% 
    glimpse()


# data_2019_test$living_alone
# glimpse(data_2019_test$living_alone)

str(data_2019_test$living_alone)

var_label(data_2019_test$living_alone) <- "Living alone"

```

<!-- Preparada. -->

## HOUSEHOLD SIZE (q0401_hh_total)

**¿Cuántas personas viven en el hogar?** Con categorías: - 1: one person - 2:
two persons - 3: three or four persons - 4: five or more persons - 5: live in an
institution

La variable `q0401_hh_total` sólo contempla el número de personas (1-10 hasta 10
personas), no si viven institucionalizadas o no. Esto lo hace el ítem `q0400a`
que no se encuentra en línea base porque ningún participante era
institucionalizado en línea base. Por tanto, simplemente se trata de no incluir
ningún valor etiquetado como 5.

-   [ ] Revisar si está en Ola 2 (subestudio COVID)

### Exploración de variables

```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total) 
```

### Creación de la variable

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(hh_size = case_when(
                  q0401_hh_total == 1 ~ "1",
                  q0401_hh_total == 2 ~ "2",
                  q0401_hh_total == 3 ~ "3",
                  q0401_hh_total == 4 ~ "3",
                  q0401_hh_total >= 5 ~ "4"),
         
         hh_size = factor(x = hh_size,
                          levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("one person", 
                                    "two persons", 
                                    "three or four persons", 
                                    "five or more persons", 
                                    "live in an institution", 
                                    "not assessed", 
                                    "missing (default)"))
  )

var_label(data_2019_test$hh_size) <- "Household size"

```

### Comprobación del funcionamiento de la nueva variable

```{r}
freq_table(data_2019_test, hh_size)

data_2019_test %>%
  group_by(hh_size) %>% 
  pivot_longer(hh_size, names_to = "size", values_to = "value") %>% 
  select(size, value) %>% 
  distinct() %>% 
  arrange(size, value) %>% 
  print(n = 150)
```

<!-- Completada. -->

## CHILDREN HOUSEHOLD (q0407_age_01-q0407_age_08/q0407_age_10)

**Are there children in your household?** - 1 = Yes; - 2 = No.

Según los comentarios encontrados en variable_list.xlsx, es necesario combinar
las tres variables: (q0407_age_01-q0407_age_08/q0407_age_10)

### Exploración de variables

```{r}
freq_table(data_2019_test, q0407_age_01)
data_2019_test %>% 
  select(q0407_age_01) %>% 
  arrange(q0407_age_01) #No hay menores de edad

freq_table(data_2019_test, q0407_age_08)
data_2019_test %>% 
  select(q0407_age_08) %>% 
  arrange(q0407_age_08) #Aquí aparecen cuatro menores de edad que no se están codificando bien. También hay NAs que no cambian su comportamiento (a -93)

freq_table(data_2019_test, q0407_age_10)
data_2019_test %>% 
  select(q0407_age_10) %>% 
  arrange(q0407_age_10) #Hay un menor de edad y el resto son NAs. 

data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>% 
  glimpse()
```

### Creación de variables

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children_hh = case_when(
    q0407_age_01 < 18 | q0407_age_08 < 18 | q0407_age_10 < 18 ~ 1,
    q0407_age_01 >= 18 | q0407_age_08 >= 18 | q0407_age_10 >= 18 ~ 2,
    is.na(q0407_age_01) | is.na(q0407_age_08) | is.na(q0407_age_10) ~ NON_RESPONSE
  ),
        children_hh = factor(x = children_hh,
                          levels = c("1", "2", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "not assessed", 
                                    "missing (default)"))
  )
```

### Comprobación

```{r}
freq_table(data_2019_test, children_hh) 
```

<!-- Con la cosa de TRUE ~ NON_RESPONSE queda solucionado parcialmente, pero es una -->

<!-- solución torticera. -->

## GENDER (q1009_sex)

**Self-identified gender** - 1: male - 2: female - 3: other/diverse -991: not
assessed -993: missing (default)

Our categories are: 1 = male; 2 0 female (and the question is not about the
self-identified gender, but sex).

### Variable exploration

```{r}
data_2019 %>%
  select(q1009_sex) %>%
  freq_table(q1009_sex)

data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  summarise_all(funs(sum(is.na(.))))

```

### Variable creation

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(gender = factor(x = q1009_sex,
                          levels = c("1", "2", "3", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("male", 
                                    "female",
                                    "other/diverse",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  select(gender) %>%
  freq_table(gender)
```

## AGE (q1010_birth_date &/OR q1011_age)

The variable **age_continuous** is a continuous variable from 1 to 100. There is
also another variable, **age_cat**, a categorical v. with the following
levels: - \< 18 - 18 - 44 - 45 - 64 - 65 - 94 - \> 95

To obtain it we have two variables: date of birth and age.

There's no NAs in any of the variables. Elvira points out that there are
problems with the date of birth variable in some IDs (ID_ECS):

    18702401
    5600601
    3100602
    18702701
    2802002
    17801501
    16602601
    5800201
    19600501
    3300201
    7101202
    7101401
    14300101
    16800301

### Variable exploration

```{r}
data_2019 %>%
  select(q1010_birth_date, q1011_age) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>%  
  filter(ID_ECS == 18702401 |
         ID_ECS == 5600601 |
         ID_ECS == 3100602 |
         ID_ECS == 18702701 | 
         ID_ECS == 2802002 |
         ID_ECS == 17801501 | 
         ID_ECS == 16602601 | 
         ID_ECS == 5800201 |
         ID_ECS == 19600501 | 
         ID_ECS == 3300201 |
         ID_ECS == 7101202 |
         ID_ECS == 7101401 |
         ID_ECS == 14300101 | 
         ID_ECS == 16800301) %>% 
  select(q1010_birth_date, q1011_age) %>% 
  View()

```

Can we use exclusively the Age variable?

```{r}
data_2019_test %>%
  select(q1011_age) %>%
  freq_table(q1011_age) %>% 
  print(n = 82)
```

### Variables creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(age_continuous = q1011_age,
         age_cat = case_when(
           q1011_age < 18 ~ 1,
           q1011_age >= 18 & q1011_age <= 44 ~ 2,
           q1011_age >= 45 & q1011_age <= 64 ~ 3,
           q1011_age >= 65 & q1011_age <= 94 ~ 4, 
           q1011_age >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variables

```{r}
data_2019_test %>% 
  select(age_cat) %>% 
  freq_table(age_cat)

data_2019_test %>% 
  select(age_continuous) %>% 
  View()
```

## RELATIONSHIP STATUS (q1012_mar_stat)

**Relationship status** is a categorical variable with the following levels: 1 =
Single 2 = Married /in a civil union 3 = in a relationship and living together 4
= in a relationship and living apart 5 = divorced/separated 6 = widowed 7 =
other

Our variable `q1012_mar_stat` is coded as: 1 = never married (and no cohabiting)
2 = currently married/law-partner 3 = cohabiting 4 = separated/divorced 5 =
widowed

As the categories doesn't match exactly, I propose the following categorisation:
1 = single --\> 1 (never married and no cohabiting) 2 = married / in a civil
union --\> 2 (currently married/law-partner) 3 = in a relationship and living
together --\> 3 (cohabiting) 4 = in a relationship and living apart --\>
MISSING_DESIGN 5 = divorced/separated --\> 4 (separated/divorced) 6 = widowed
--\> 5 (widowed) 7 = other --\> MISSING_DESIGN

### Variable exploration

```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  select(q1012_mar_stat) %>%
  freq_table(q1012_mar_stat)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(relationship = case_when(
           q1012_mar_stat == 1 ~ 1,
           q1012_mar_stat == 2 ~ 2,
           q1012_mar_stat == 3 ~ 3,
           q1012_mar_stat == 4 ~ 5, 
           q1012_mar_stat == 5 ~ 6,
         ), 
         relationship = factor(x = relationship,
                          levels = c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("single", 
                                    "married/in a civil union",
                                    "in a relationship and living together",
                                    "in a relationship and living apart",
                                    "divorced/separated",
                                    "widowed",
                                    "other",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>% 
  select(relationship) %>% 
  freq_table(relationship)
```

## EDUCATION (q1016_highest)

**Highest level of education according to ISCED Classification**:

-   1 = primary/basic: (primary education and lower secundary education)
-   2 = secondary/intermediate: (upper secondary education, post-secondary
    non-tertiary education)
-   3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or
    equivalent level, master's or equivalent level, doctoral or equivalent
    level)
-   4 = no formal education / less than basic (no schooling, early childhood
    education) -991 = not assessed -993: level not stated - if following yellow
    box, if not, "missing (default)"

Our variable, `q1016_highest`, has as levels (doesn't have *non-tertiary
education*): - 0 = No formal education - 1 = Primary education not completed - 2
= Primary education completed - 3 = Lower secondary education completed - 4 =
Upper secondary education completed - 5 = University/college completed - 6 =
Master degree, PhD completed - 888 = don't know

As a proposal, I suggest: - 1 = primary/basic --\> 1, 2, 3 - 2 =
secondary/intermediate: 4, - 3 = tertiary/advanced: 5, 6 - 4 = no formal
education / less than basic: 0

### Variable exploration

```{r}
data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs, but 888 as DK.

data_2019 %>% 
  select(q1016_highest) %>%
  freq_table(q1016_highest)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(education = case_when(
           q1016_highest == 0 ~ 4,
           q1016_highest == 1 | q1016_highest == 2 | q1016_highest == 3 ~ 1,
           q1016_highest == 4 ~ 2, 
           q1016_highest == 5 | q1016_highest == 6 ~ 3,
           q1016_highest == 888 ~ NON_RESPONSE,
         ), 
         education = factor(x = education,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("primary/basic", 
                                    "secondary/intermediate",
                                    "tertiary/advanced",
                                    "no formal education",
                                    "not assessed", 
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(education) %>%
  freq_table(education)
```

## MIGRATION (q1018_country)

**Country of birth other than country of residence**: - 1 = Yes - 2 = No - 3 =
No information - 991 - 993

Our variable has registered the name of each country. As we did the sample
collection in Spain, we can assume that responses that are different than Spain
are indicators of migration.

### Variable exploration

```{r}
data_2019 %>%
  select(q1018_country) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>% 
  select(q1018_country) %>%
  freq_table(q1018_country)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    migration = if_else(q1018_country == 1, 2, 1),
    migration = factor(x = migration,
                       levels= c("1", "2", "3", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("yes", 
                                    "no",
                                    "no information",
                                    "not assessed", 
                                    "missing (default)")))
```

-   [ ] Does it make sense to have No information and the other two categories
    of NAs?

### Checking new variable

```{r}
data_2019_test %>% 
  select(migration) %>%
  freq_table(migration)
```

## CHILDREN (q1056/q1058)

**Do you have children, live with children or take care of children in your
household?** - 1 = yes, - 2 = no - 991 - 993

Our variables `q1056` & `q1058` ask about biological and adopted children
(separated) (1 = yes; 2 = no). Elvira suggested to combine them and we'll follow
this approach.

### Variable exploration

```{r}
data_2019 %>%
  select(q1056, q1058) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1056) %>%
  freq_table(q1056) #1 = yes; #2 = no

data_2019 %>% 
  select(q1058) %>% #1 = yes; #2 = no
  freq_table(q1058) 

```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children = case_when(
           q1056 == 1 | q1058 == 1 ~ 1,
           q1056 == 2 | q1058 == 2 ~ 2
         ), 
         children = factor(x = children,
                          levels = c("1", "2", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "not assessed", 
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(children) %>%
  freq_table(children)
```

-   [ ] These results doesn't add up with children household (children_hh)
    variable. Following children_hh, there are no children in most of households
    sampled.

## N. O. CHILDREN (q1057/q1059)

Is the same as the previous one but in a continuous way: \_\_How many children
do you have? (including children who are not your own but live in the same
household or who you care for in your household?) - 1 = no children - 2 = one
child - 3 = two or three - 4 = four or more - 991 - 993

Variables in ECS makes a differentiation between biological and adopted children
(1+, DK). As a proposal, it is suggested to combine the two variables.

### Variable exploration

```{r}
data_2019 %>%
  select(q1057, q1059) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs

data_2019 %>% 
  select(q1057) %>%
  freq_table(q1057) #variable cuanti (1 = 1... Etc.) 888 = Don't know (sustituir esto por -93 ¿?. Los NAs hay que sustituirlos por 1)

data_2019 %>% 
  select(q1059) %>% #variable cuanti (1 = 1, 2 = 2, 3 = 3, 2978 NAs, que hay que sustituirlos por 1 (No children))
  freq_table(q1059) 

```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
         q1057_NA = na_if(q1057, 888),
         q1057_NA = replace_na(q1057_NA, 0),
         q1059_NA = replace_na(q1059, 0),
         add_children = q1057_NA + q1059_NA, 
         
         nofchildren = case_when(
                                  add_children == 0 ~  1, #no children
                                  add_children == 1 ~ 2, #one children
                                  add_children == 2 | add_children == 3 ~ 3, #two or three children
                                  add_children >= 4 ~ 4 # four or more
                                 
         ), 
         nofchildren = factor(x = nofchildren,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("no children", 
                                    "one child",
                                    "two or three",
                                    "four or more",
                                    "not assessed", 
                                    "missing (default)")))


```

-   [x] Darle una segunda vuelta a esto, porque igual hay gente que tiene hijos
    adoptados e hijos biológicos al mismo tiempo. En ese caso hay que sumarlos.
    -   [ ] Darle otra vuelta a la no coincidencia de los NAs. (--\> Link a
        children-issue.Rmd)

### Checking new variable

```{r}
data_2019_test %>% 
  select(nofchildren) %>%
  freq_table(nofchildren)
```

# EMPLOYMENT STATUS (`q1503_work_now` & `q1504_reason`.)

**Employment status** has the following levels:

-   1 = Have a job (employed or self-employed)
-   2 = In education
-   3 = Care work (family) / homeworker/ on parental leave
-   4 = On long-term sick leave/disability
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
-   6 = unemployed or job-seeking
-   7 = retired

-991 = not assessed -993 = missing (default)

`q1503_work_now` (c2019_w1) *Currently working?*: - 1 = Yes - 2 = No

`q1504_reason` (c2019_w1) *Reason not working*:

-   1 = homemaker
-   2 = couldn't find a job
-   3 = unpaid/voluntary
-   4 = studies/training
-   5 = health
-   6 = care family
-   7 = no need
-   8 = not permitted
-   9 = retired/too old
-   10 = laid off
-   11 = seasonal work
-   12 = does not want to for a while
-   13 = vacation/sick or maternity leave
-   87 = other.

As a proposal, I suggest the following combination of both variables:

-   1 = Have a job (employed or self-employed) == `1 (q1503_work_now)`
-   2 = In education (currently studying) == `4 (q1504_reason)`
-   3 = Care work (family) / homeworker / on parental leave == `1, 6, 13`
    `(q1504_reason)`** 
-   4 = On long-term sick leave/disability == `13, 5 (health) (q1504_reason)`,
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
    (other) == `3 (unpaid/voluntary), 7 (no need), 8 (not permitted), 12 (does`
    `not want to for a while), 87 (other)`
-   6 = unemployed or job-seeking == `2 (couldn't find a job), 10 (laid off)`, 
`11 (seasonal work)`,
-   7 = retired == `9 (retired/too old)`

**Our category 13 (vacation/sick or maternity leave) overlaps with the 
proposed categories 3 (care work/homeworker/or parental leave) and 
4(On long-term sick leave/disability)

### Variable exploration

```{r}
data_2019 %>%
  select(q1503_work_now, q1504_reason) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs (347 en work-now y 1387 en reason)

data_2019 %>% 
  select(q1503_work_now) %>%
  freq_table(q1503_work_now) #1 = yes; 2 = no; NAs = -93

data_2019 %>% 
  select(q1504_reason) %>% 
  freq_table(q1504_reason) 

```

### Variable creation

```{r}

data_2019_test <-
  data_2019_test %>%
  mutate(employment_st = case_when(
                  q1503_work_now == 1 ~ 1, #have a job
                  q1504_reason == 4 ~ 2, #studying
           q1504_reason == 1 | q1504_reason == 6 ~ 3, #care work 
           q1504_reason == 5 ~ 4, # on long term sick leave disability
           q1504_reason == 3 | q1504_reason == 7 | q1504_reason == 8 | q1504_reason == 11 | q1504_reason == 12  | q1504_reason == 13 | q1504_reason == 87 ~ 5, #other reasons, added '13' here
           q1504_reason == 2 | q1504_reason == 10 |q1057 == 11 ~ 6, #unemployed or job-seeking
           q1504_reason == 9 ~ 7, #retired,
           is.na(q1504_reason) | is.na(q1503_work_now) ~ NON_RESPONSE
         ),
          employment_st = factor(x = employment_st,
                          levels = c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("Have a job (employed or self-employed)",
                                    "In education",
                                    "Care work (familiy) / homeworker/ on parental leave",
                                    "On long-term sick leave/disability",
                                    "Unable to work due to reasons not mentioned elsewhere in this list",
                                    "unemployed or job-seeking",
                                    "retired",
                                    "not assessed",
                                    "missing (default)"
                                    )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(employment_st) %>%
  freq_table(employment_st)
```

# PROFESSION (q1510_catoccu)

**Best description of current occupation(s)**

-   1 = undergoing education
-   2 = education and research
-   3 = arts, entertainment, sports and media
-   4 = healthcare
-   5 = first responder (paramedic/firefighter/police)
-   6 = military
-   7 = civil services, politics
-   8 = finance and economy
-   9 = industry
-   10 = sales and services (incl. restaurants and bars)
-   11 = transport (goods and people)
-   12 = installation, maintenance, cleaning, and repairs
-   13 = currently not working
-   14 = other (please specify)

`q1510_catoccu` follows the OIT categorization; differs almost in every level
with the one proposed for RESPOND. What to do?

-   1 Legislators === 7 (civil services, politics)
-   2 Professionals === 2 (education and research),
-   3 Technicians ==== 8 (finance and economy)
-   4 Clerks ===== 12 (installation, maintenance, cleaning and repairs)
-   5 Service workers ==== 5 (first responder: paramedic/firefighter/police)
-   6 Skilled agricultural workers ==== 11 (transport - goods and people)
-   7 Craft workers ==== 3 (arts, entertainment, sports and media)
-   8 Plant operators ==== 14 (other)
-   9 Elementary occupations ==== 10 (sales and services)
-   10 Armed forces === 6 (military)


We will include this variable in raw format in the database just for 
knowing levels of OIT categorization rather than sector. Following
recommendations of IPD-RESPOND team, we would try to keep assumptions to a
minimum and when in doubt, code things as other:


-   1 Legislators === 7 (civil services, politics)
-   2 Professionals === 14 (others)
-   3 Technicians ==== 14 (others) 
-   4 Clerks ===== 12 (installation, maintenance, cleaning and repairs)
-   5 Service workers ==== 5 (first responder: paramedic/firefighter/police)
-   6 Skilled agricultural workers ==== 14 (others)
-   7 Craft workers ==== 14 (others)
-   8 Plant operators ==== 14 (other)
-   9 Elementary occupations ==== 14 (others)
-   10 Armed forces === 6 (military)

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510_catoccu) %>%
  freq_table(q1510_catoccu) 
```

### Variable creation

```{r}
#Creamos la variable
data_2019_test <-
  data_2019_test %>%
  mutate(profession = case_when(
                      q1510_catoccu ==  5  ~  5 , #service workers --> first responders: paramedic/firefighter/police
                      q1510_catoccu ==  10  ~  6 , #armed forces --> military
                      q1510_catoccu ==  1  ~  7 , #legislators --> civil services, politics
                      q1510_catoccu ==  4  ~  12 , #clerks --> installation, maintenance, cleaning and reparis
                      q1510_catoccu ==  8 | 
                      q1510_catoccu ==  3 | 
                      q1510_catoccu ==  6 |
                      q1510_catoccu ==  7 | 
                      q1510_catoccu ==  9 | 
                      q1510_catoccu ==  2  ~  14, #others
                      is.na(q1510_catoccu) ~ NON_RESPONSE
                      
         ), 
         profession = factor(x = profession,
                                  levels = c("1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14",
                                             MISSING_DESIGN, NON_RESPONSE),
                                  labels = c("undergoing education",
                                            "education and research",
                                            "arts, entertainment, sports and media",
                                            "healthcare",
                                            "first responder (paramedic/firefighter/police)",
                                            "military",
                                            "civil services, politics",
                                            "finance and economy",
                                            "industry",
                                            "sales and services (incl. restaurants and bars)",
                                            "transport (goods and people)",
                                            "installation, maintenance, cleaning, and repairs",
                                            "currently not working",
                                            "other",
                                            "not assessed",
                                            "missing (default)"
                                            )))

```


### Checking new variable

```{r}
data_2019_test %>% 
  select(profession) %>%
  freq_table(profession)
```

## CONTRACT (q1510b_contract_earner)

**Permanent/temporary contract** -

-   1 permanent
-   2 temporary
-   3 self-employed
-   4 other
-   Missing values/categories:\
    -   -991 not assessed - -993 missing (default)

In EcS:

-   1 officer ===== 1 permanent
-   2 indefinite period (not officer) ===== 3 self-employed
-   3 temporal or contract of works and services ===== 2 temporary
-   4 verbal or without contract ===== 4
-   888 DK ===== -993
-   999 refused to answer ===== -993

Changes made after consulting with IPD-Respond team:

-   1 officer ===== 1 permanent
-   2 indefinite period (not officer) ===== 4 (other)
-   3 temporal or contract of works and services ===== 2 temporary
-   4 verbal or without contract ===== 4
-   888 DK ===== -993
-   999 refused to answer ===== -993

### Variable exploration

```{r}
data_2019 %>%
  select(q1510b_contract_earner) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510b_contract_earner) %>%
  freq_table(q1510b_contract_earner)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(contract = case_when(
        q1510b_contract_earner == 1 ~ 1, #officer --> permanent
        q1510b_contract_earner == 3  ~ 2, #temporal or contract of works and services --> temporary
        q1510b_contract_earner == 4 |
        q1510b_contract_earner == 2 ~ 4, #verbal or without contract & indefinite period (not officer) --> other
        q1510b_contract_earner == 888 ~ NON_RESPONSE, 
        q1510b_contract_earner == 999 ~ NON_RESPONSE,
        is.na(q1510b_contract_earner) ~ NON_RESPONSE

         ),
          contract = factor(x = contract,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "missing (default)"
 )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(contract) %>%
  freq_table(contract)
```

# EMPLOYMENT TYPE (`q1510_workday`)

-   1 - Full time
-   2 - Part time
-   3 - No paid work
-   4 - Other
-   -991 not assessed
-   -992 refused to answer
-   -993 missing (default)

In EcS (`q1510_workday`):

-   1 Part time (morning and afternoon) ===== 2
-   2 Continuous morning working day ===== 1
-   3 Continuous afternoon working day ===== 1
-   4 Continuous night working day ===== 1
-   5 Reduced work day ===== 4
-   6 Shift work / irregular or variable work ==== 2
-   7 Other type ==== 4
-   888 DK ==== -993

### Variable exploration

```{r}
data_2019 %>%
  select(q1510e_workday) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510e_workday) %>%
  freq_table(q1510e_workday)

```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(employment_ty = case_when(
       q1510e_workday == 1 ~ 2, #part time --> part time
       q1510e_workday == 2 ~ 1, #continuous morning working day --> full time
       q1510e_workday == 3  ~ 1, #continuous afternoon working day --> full time
       q1510e_workday == 4 ~ 1, #continuous night working day --> full time
       q1510e_workday == 5 ~ 4, #reduced work day --> other
       q1510e_workday == 6 ~ 1, #shift work --> full time
       q1510e_workday == 7 ~ 4, #other --> other
       q1510e_workday == 888 ~ NON_RESPONSE, 
       q1510e_workday == 999 ~ NON_RESPONSE,
        is.na(q1510e_workday) ~ NON_RESPONSE

         ),
          contract = factor(x = employment_ty,
                          levels = c("1", "2", "3", "4",  MISSING_DESIGN, NON_RESPONSE),
                          labels = c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "missing (default)"
 )))


```

### Checking new variable

```{r}
data_2019_test %>% 
  select(employment_ty) %>%
  freq_table(employment_ty)
```


## RESILIENCE SCALE (BRS)

### Ola 1

Tenemos resilience_scale y los ítems individuales: q7537, q7538, q7539, q7540,
q7541, q7542

-   [x] TODO: Añadir una fila por cada ítem individual.

### Ola 2

Tenemos resilience_scale y los ítems individuales: SM26_1, SM26_2, SM26_3,
SM26_4, SM26_5, SM26_6

-   [x] TODO: Añadir una fila por cada ítem individual.
-   [x] duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato
    long)

## Social support

### Ola 1

Tenemos social_support y los ítems individuales:

-   [x] TODO: encontrar los ítems individuales

```{r}
data_2019_test %>% 
  select(q6310_help_neig, q6320_close, q6330_concern) %>% 
  View()
```

-   [x] TODO: Añadir una fila por cada ítem individual.

### Ola 2

Tenemos social_support y los ítems individuales:

```{r}
data_COVID %>% 
  select(SOLO9A, SOLO9B, SOLO9C) %>% 
  View()
```

-   [x] TODO: Añadir una fila por cada ítem individual.
-   [x] TODO: encontrar los ítems individuales

## C.O RESIDENCE

-   [ ] TODO: To be created (comment from Elvira: this variable should be
    created)
-   [ ] TODO: Ver qué variables pueden formar esta variable.
-   [ ] TODO: variable dictionary: "residence" is a new variable and replaces
    the formerly included variable "c.o. residence". Note variables NUTS-1 to
    NUTS-3 (s. variable dictionaries 20 to 22) are "20_geographics NUTS-1",
    "21_geographics NUTS-2", and "22_geographics areno NUTS-3" are discarded.

Find NUTS territorial unit codes at:
<https://drzmainz.sharepoint.com/:x:/s/obiba-wp2/Ecl70YGS_79HmKhWAGd3QzsBz9BGEIHRfuIOeSgpqRaYGw?e=4rfPmo> -
[ ] Me da error: internal users only - [ ] Comentario de Elvira: All
participants live din Spain. We could create this variable.

## Stressor (life events)

Tenemos la escala completa: lte. Los ítems individuales: q4659_ill
q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff
q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police
q4670_stolen

-   [x] TODO: Crear nuevas filas por cada ítem.

## SOCIAL PARTICIPATION:

To be created from baseline using q6613-q6621 (Adaptación del Índice de
Aislamiento Social - Shankar, McMunn, Banks y Steptoe (2011))

¿Con qué frecuencia en los últimos 12 meses usted

- q6613_club: ... asistió a una reunión con algún grupo, club u organización?
- q6618_relig: ... asistió a actividades religiosas (no incluya bodas y 
funerales)?
- q6619_leave: ... salió de su hogar/vivienda para asistir a reuniones sociales,
actividades, programas o eventos o para visitar a amigos/as familiares?
- q6621_assoc: ... acudió a centros o asociaciones de mayores, centros de día,
grupos de autoayuda, universidades para la tercera edad?

- 1: Nunca
- 2: Una o dos veces al año 
- 3: Una o dos veces al mes
- 4: Una o dos veces por semana
- 5: A diario

- 999: NA


```{r}
data_2019_test %>% 
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>% 
  glimpse()

data_2019 %>%
  select(q6613_club, q6618_relig, q6619_leave, q6621_assoc) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q6613_club) %>%
  freq_table(q6613_club)


data_2019 %>% 
  select(q6618_relig) %>%
  freq_table(q6618_relig)

data_2019 %>% 
  select(q6619_leave) %>%
  freq_table(q6619_leave)

data_2019 %>% 
  select(q6621_assoc) %>%
  freq_table(q6621_assoc)


```
To create this variable:
- Not married/not cohabiting with a partner == 1, 
- had less than monthly contact with children, other inmediate family and friends
(q6619_leave == 2 & 1)
- if no participation in any organization,s, religious groups, or committees 
(q6613_club == 1; q6621_assoc == 1)

En total es una escala de 5 puntos (la original), pero como aquí sólo tenemos 4
la escala irá de 0 a 4 señalando que mayores puntuaciones tienen una mayor
aislamiento social. 

Lo podemos reconvertir a la inversa para que señale participación social. 

\*En variable_list.xlsx aparece una fila duplicada con social participation que
dice "size_sn", pero es una variable que no existe en la BBDD ni en la
documentación de cohorte 2019.

```{r}
data_2019_test <-
  data_2019_test %>%
  mutate(q6613_club_r =
           case_when(
             q6613_club == 3 | q6613_club == 4 |  q6613_club == 5 ~ 1,
             TRUE ~ 0),
         
          q6618_relig_r = 
           case_when(
             q6618_relig == 3 | q6618_relig == 4 |  q6618_relig == 5 ~ 1,
             TRUE ~ 0),
         
         q6619_leave_r =
           case_when(
             q6619_leave == 3 | q6619_leave == 4 |  q6619_leave == 5 ~ 1,
             TRUE ~ 0),
         
         q6621_assoc_r =
           case_when(
             q6621_assoc == 3 | q6621_assoc == 4 |  q6621_assoc == 5 ~ 1,
             
             q6621_assoc == 999 ~ NON_RESPONSE,
             TRUE ~ 0),
         
         social_participation = q6613_club_r + 
                                q6618_relig_r + 
                                q6619_leave_r +
                                q6621_assoc_r,
         
         social_participation =
           case_when(
             social_participation < 0 ~ NON_RESPONSE,
             TRUE ~ social_participation
           )
             )
```

```{r}
data_2019_test %>% 
  select(social_participation) %>%
  freq_table(social_participation)
```



```{r}
data_2019_test %>% 
  select(size_sn) %>% 
  View()
```

También aparecen otras variables que se laman "social_int_ff_pre",
"social_int_total_pre", "social_int_vr_pre", que tampoco aparecen por ningún
lado.

## SUBSTANCE USE

```{r}
data_2019_test %>% 
  select(alcohol) %>% 
  View()
```

## DEPRESSION

```{r}
data_2019_test %>% 
  select(ewb_pre) %>% 
  View()

data_COVID %>% 
  select(ewb_pre)
```

## Código que hemos utilizado para explorar los ítems individuales
```{r}
data_2019 %>% select(starts_with("q6010"))
data_2019 %>% select(starts_with("q621"))
data_2019 %>% select(starts_with("q621")) %>% View()
data_2019 %>% select(starts_with("q621")) %>% colnames()
data_2019 %>% select(starts_with("q6010")) %>% colnames()
data_2019 %>% select(q4585_ideation:q4599c_hospi) %>% colnames()
```

