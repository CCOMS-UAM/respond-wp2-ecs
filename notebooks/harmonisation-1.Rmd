---
title: "Preparando el archivo variable_list con los datos de Edad con Salud"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), '%d de %B de %Y')`"
institute: CCOMS, Universidad Autónoma de Madrid
output: 
  html_notebook:
  toc: yes
  toc_float: yes
  keep_md: yes
editor_options: 
  chunk_output_type: console
---

# Preparación

## Librerías necesarias

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
```

## Constantes en la armonización de variables

Valores perdidos: Coding of missing values: -91 specifies a variable has not
been assessed in general (eg, at this point of data collection), so it is
missing by design. -93 specifies missings (default) from data collections that
actually took place (eg, this exact questionnaire had been assessed at this
timepoint, but the participant did not answer for whatever reason).

```{r constantes}

MISSING_DESIGN <- -991
NON_RESPONSE <- -993

```

## Lectura de datos

Los datos se extraen de las carpetas de OneDrive "Bases de datos maestras". Se
encuentran en formato .dta, que es un formato doble - por un lado, tipo de
variable (class) y por otro, la etiqueta (label, parte de los metadatos). Esto
hace que sea un poco complicado trabajar con estas variales, ya que los
`value- labels` no se utilizan para el análisis de los datos (no suponen una
implicación) sobre la consideración categórica o continua de las variables.

**Antes de hacer un análisis de datos es necesario convertir los vectores con**
**value_labels en factores, numéricos o caracteres**. Es un paso que se puede
hacer desde el principio con `unlabelled()`, `to_factor()` o `unclass()`, o
cuando ya se ha hecho la limpieza de datos y se quiere mantener esa info en la
exportación.

A continuación se importan las BBDD originales y se duplican para probar cosas.

```{r}
data_2019 <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Ola_3/Cohorte_2019/rawdata_c2019w1.dta")

data_COVID <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")

data_2019_test <- data_2019 #Hago una copia del dataset original para probar cosas.
```

Tareas pendientes:

-   [ ] Revisar codificación UTF-8

# El archivo variable_list

Este archivo reúne **todas las variables** que tiene cada estudio. Es necesario
comprobar que todos los outcomes están incluidos (ver los archivos [mental
health
outcomes](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7BA66AD0BE-D072-4CB3-8072-F4FF5C92BF9D%7D&file=mental_health_measures_hs.xlsx&action=default&mobileredirect=true)
y
[predictores](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7B37F195E1-399B-48CE-9E11-5B2B8B83B210%7D&file=predictor_candidates_by_study_hs.xlsx&action=default&mobileredirect=true)
para comprobar que está todo lo que tiene que estar).

# Cambios a realizar

## CREATE HC WORKER from baseline wave using q1510_occ -wave 1)

HC Workers (health-care workers) es una variable dicotómica (1 = yes, 2 = no)
que se crea a partir de `q1510_occ` con los datos de la línea base. Este ítem de
formato abierto indica la ocupación en texto libre de los participantes.

Para proceder con esta variable establecemos distintos pasos.

1.  Explorar los valores únicos que tiene esta variable u otras que puedan ser
    de utilidad.
2.  Filtrar aquellos relativos a los "HC-workers"
3.  Crear la nueva variable.

### Exploración de variables

Exploramos la variable `q1510_occ`:

```{r}
glimpse(data_2019$q1510_occ)

data_2019 %>%
  select(q1510_occ) %>%
  distinct()

data_2019 %>%
  select(q1510_occ, q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.)))) #Sólo hay NAs en catoccu
```

Esta variable contiene 1824 valores únicos. Exploramos otras variables del
cuestionario que permitan extraer la ocupación. En la BBDD hay otra variable,
`q1510_catoccu` que utiliza la estructura de la CIUO-08 (códigos ISCO, de la
OIT). Nos interesa la categorización:

__GRUPO 2: "PROFESIONALES CIENTÍFICOS E INTELECTUALES" \> PROFESIONALES DE LA__
__SALUD__

Exploramos `q1510_catoccu`

```{r}
glimpse(data_2019$q1510_catoccu)

data_2019 %>%
  select(q1510_catoccu) %>%
  distinct()

freq_table(data_2019, q1510_catoccu)

```

Esta variable sólo contiene la categorización de los 10 grupos principales, no
de los subgrupos. Por tanto, tenemos que descartar esta variable porque no nos
permite diferenciar los profesionales de la salud de otros profesionales y se
tiene que trabajar con la variable `q1510_occ`.

Cuenta con 347 valores perdidos. Vamos a crear una nueva variable con los
valores de `q1510_occ` filtrado a través de `q1510_catoccu`, teniendo en cuenta
esta consideración.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(as.numeric(q1510_catoccu) %in% c("2")) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```
Aquí faltan algunas opciones (e.g., auxiliar de enfermería... que hemos visto que existen. Vamos a filtrar por los que tengan un valor perdido en esta variable.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(is.na(q1510_catoccu)) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(ID_ECS == 10300401) %>% 
  select(q1510_occ) %>% 
  View()

```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(q1510_occ == "auxiliar de enfermeria") %>% 
  select(q1510_catoccu) %>% 
  View()
```

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  filter(as.numeric(q1510_catoccu) %in% c("2", "3", "7", "8") ) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```
Con este filtro ^ obtenemos 1180 registros. Interesantes, en total, 69 casos.

```{r}
data_2019_test %>% 
  group_by(ID_ECS) %>% 
  select(q1510_catoccu, q1510_occ) %>% 
  View()
```
Aquí no filtramos por categorías, vemos todos los casos (3002 observaciones).
<!-- Explorar cuáles son los 347 casos pendientes.HECHO: Estos no tienen valores en q1510_occ asociados, por qué no aparecen como NAs? -->

### Utilizando expresiones regulares

`RegExplain` es un *addin* de R para manipular expresiones regulares y analizar
variables de texto libres (los valores únicos). Algunos de los primeros valores
que nos resultan de interés para la creación de esta variable son:

*SADSERVICIO ATENCION DOMICILIARIA enfermera mÃ©dica cardiÃ³loga* *medico
traumatologo auxiliar enfermera auxiliar de enfermeria* *MÃ©dico homeÃ³pata*

Estas han sido extraídas manualmente de los 100 primeros valores de los valores
únicos que tiene esta variable, pero necesitamos las 1824 disponibles:

```{r}
data_2019$q1510_occ %>% 
  str_extract_all("enf", simplify = T) 
```

Esto no ha funcionado.
<!-- TODO! -->
<!-- -   [ ] Buscar una manera de automatizarlo. -->
<!--    -   [X] Crear un dataset sólo con la variable `q1510_occ` filtrada a través de -->
<!--          `q1510_catoccu` == 2, que resuma las ocupaciones de las personas que han -->
<!--           marcado esa categoría. 
                  Esto tiene el problema de que no todas las ocupaciones HC son 2. Se ha 
                  propuesto una lista de ítems que pueden ser interesantes, revisar con Dani.
                  -->
<!--         - [ ] Incluir los nuevos ítems una vez la decisión esté tomada (Ver archivo HC-workers.txt). -->
<!--   -   [ ] Revisar los valores perdidos de ambas categorías. La variable de texto libre  -->
<!--                   en teoría no tiene NAs, pero cuando combinas ambas dos, sí. ¿Qué está  -->
<!--                   pasando?-->

### Creación de la variable

La idea es crear una nueva variable de manera que el patrón detectado suponga un
1, y el resto un 0:

```{r}
data_2019_test <- data_2019 %>%
                    mutate( # 1 = mental health worker; 0 = non mental health worker
                      occ_mhw = if_else(str_detect(q1510_occ, "enf"), 1,
                                        if_else(str_detect(q1510_occ, "med"), 1,
                                                if_else(str_detect(q1510_occ, "traum"), 1, 
                                                        if_else(str_detect(q1510_occ, "aux"), 1,
                                                                ifelse(str_detect(q1510_occ, "SADSERVICIO"), 1, 0)))))
                    )
glimpse(data_2019_test$occ_mhw)  #Funciona
```

Tareas pendientes:

-   [ ] Terminar de incluir todos los valores únicos.

## CREATE INCOME QUINTILES (HHQUINTILE) - wave 1

Las variables relacionadas con los ingresos que se manejan en esta BBDD son:

-   `q0410g_total`: ingresos personales brutos de todos los miembros de su
    familia durante los últimos 12M.
-   `q0410i_ss`: ingresos brutos de su hogar durante los últimos 12M procedentes
    de la pensión de jubilación.
-   `q0410j_government`: ingresos brutos de su hogar (...) procedentes de progra
    mas oficiales (paro, hijos dependientes, viudedad, orfan- dad, asistencia
    general)
-   `q0410k_other`: de fuentes privadas (pensiones, inversiones, alimenticias o
    de mantenimiento).

Se descarta `q1519` para este fin porque pregunta por la situación financiera en
la infancia.

### Exploración de variables

Vemos cuántos valores únicos hay por cada variable y las representamos gráfica-
mente. Se trata de una variable categórica que representa rangos. Se encuentran
34 valores distintos dentro de esta variable.

```{r}
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),
               names_to = "income", 
               values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)
```

```{r}
g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4)
```

-   [ ] Ver si existe alguna manera de simplificar este proceso.

#### Recodificación de la variable

Para proceder con el tratamiento de esta variable, Dani me envía su script
`Edad_con_Salud_Data.R`. La idea que se extrae de ese script es recodificar
estas cuatro variables por la mediana del rango establecido para poder sumarlas
y crear los quintiles en base a esto.

Debido al doble formato de Stata, primero convertimos las variables a numéricas
y luego a factores.

```{r}
data_2019_test %>% 
  mutate(
    q0410g_total = as.numeric(q0410g_total),
    q0410i_ss = as.numeric(q0410i_ss),
    q0410j_government = as.numeric(q0410j_government),
    q0410k_other = as.numeric(q0410k_other),
    
    q0410g_total = as.factor(q0410g_total),
    q0410i_ss = as.factor(q0410i_ss),
    q0410j_government = as.factor(q0410j_government),
    q0410k_other = as.factor(q0410k_other)
  )
```

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = NON_RESPONSE,
                                          "888" = NON_RESPONSE, 
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )
```

Encontramos que la recodificación que se ha hecho no es la que buscábamos,
aunque si seleccionamos dos variables (original y recodificada) vemos que
podemos hacer otras cosas para seguir operando:

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410g_total_r) %>% 
  View()
```

Se han modificado los levels, pero no las labels. En cualquier cosa, para seguir
avanzando, tenemos que convertirlo a carácter y luego a integer:

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_total_r = as.character(q0410g_total_r),
        q0410i_ss_r = as.character(q0410i_ss_r),
        q0410j_government_r = as.character(q0410j_government_r),
        q0410k_other_r = as.character(q0410k_other_r),
        
        q0410g_total_r = as.integer(q0410g_total_r),
        q0410i_ss_r = as.integer(q0410i_ss_r),
        q0410j_government_r = as.integer(q0410j_government_r),
        q0410k_other_r = as.integer(q0410k_other_r)
  )
```

Necesitamos crear otra variable a partir de esta teniendo en cuenta los -92 y
-93 con missing para que no se tengan en cuenta a la hora de calcular los
quintiles, utilizando na_if().

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_tot_NA = na_if(q0410g_total_r, NON_RESPONSE),
        q0410i_ss_NA = na_if(q0410i_ss_r, NON_RESPONSE),
        q0410j_gov_NA = na_if(q0410j_government_r, NON_RESPONSE),
        q0410k_other_NA = na_if(q0410k_other_r, NON_RESPONSE)
)
```

Una vez que tenemos esto, ya podemos continuar operando.

#### Creación de la variable

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
    hh_income_r_NA = q0410g_tot_NA + q0410i_ss_NA + q0410j_gov_NA + q0410k_other_NA)

glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r_NA)
```

Calculamos los quintiles con `quantile(x)` y guardamos únicamente los valores de
los quintiles para acceder a través de ellos con los corchetes.

```{r}
quintiles <- quantile(data_2019_test$hh_income_r_NA, na.rm = T)
quintiles <- unname(quintiles)
```

Recodificamos en quintiles:

```{r}
# data_2019_test <- data_2019_test %>%
#   mutate(hhquintile =
#            if_else(hh_income_r_NA <= quintiles[1], 1,
#                     if_else(hh_income_r_NA > quintiles[1] & hh_income_r_NA <= quintiles[2], 2,
#                             if_else(hh_income_r_NA > quintiles[2] & hh_income_r_NA <= quintiles[3], 3,
#                                     if_else(hh_income_r_NA > quintiles[3] & hh_income_r_NA <= quintiles[4], 4,
#                                             if_else(hh_income_r_NA > quintiles[4] & hh_income_r_NA <= quintiles[5], 5, NA
#                                                     ))))))

data_2019_test <- data_2019_test %>% 
  mutate(hhquintile = case_when(
                          hh_income_r_NA <= quintiles[1] ~ 1,
                          hh_income_r_NA > quintiles[1] & hh_income_r_NA <= quintiles[2] ~ 2,
                          hh_income_r_NA > quintiles[2] & hh_income_r_NA <= quintiles[3] ~ 3,
                          hh_income_r_NA > quintiles[3] & hh_income_r_NA <= quintiles[4] ~ 4,
                          hh_income_r_NA > quintiles[4] & hh_income_r_NA <= quintiles[5] ~ 5
    
  ))
```

```{r}
glimpse(data_2019_test$hhquintile)
data_2019_test %>% 
  select(hhquintile) %>% 
  freq_table(hhquintile)

str(data_2019_test$hhquintile)
class(data_2019_test$hhquintile)
```

Hacemos que los NAs sean, de nuevo, NON_RESPONSE:

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    hhquintile = case_when(
                        hhquintile == 1 ~ 1, 
                        hhquintile == 2 ~ 2, 
                        hhquintile == 3 ~ 3, 
                        hhquintile == 4 ~ 4,
                        hhquintile == 5 ~ 5, 
                        is.na(hhquintile) ~ NON_RESPONSE
  ))

```

Comprobamos:
```{r}
glimpse(data_2019_test$hhquintile)
data_2019_test %>% 
  select(hhquintile) %>% 
  freq_table(hhquintile)
```


<!-- -   [X] Ver si se puede utilizar con case_when() -->
<!-- -   [X] Hacer otra reconversión teniendo en cuenta el valor de hh_income_r para -->
<!-- <!--     volver a los -993 (última codificación a 20/10/2022) -->
<!-- Ver también funciones de interés: cut() y coalesce() -->
<!-- COMPLETA! -->

## STRESSOR (LIFE EVENTS)
La variable combinada es `lte` (está creada y habrá que importarla en la base de datos final). 
Las variables individuales son:

- q4659_ill
- q4660_illrelative 
- q4661_died 
- q4662_diedrelative 
- q4663_separation 
- q4664_brokeoff 
- q4665_problem 
- q4666_unemployed 
- q4667_sacked 
- q4668_financial 
- q4669_police
- q4670_stolen

No se necesita armonización previa; se trabajará una vez que esté en Opal. 
- [ ] Añadir en variable_list.xlsx una fila por cada ítem por separado. 




## LIVING ALONE (q0401_hh_total) - wave 1
__¿Cuál es el número total de personas que viven habitualmente en este hogar?__
Dos categorías:
- 1 = alone;
- 2 = not alone.

En ECS partimos de `q0401_hh_total`, que es una variable cuantitativa del 1 al 10. 

### Exploración de variables
```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total)

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos
```

### Creación de la variable
```{r}
data_2019_test <- data_2019_test %>% 
  mutate(living_alone = if_else(q0401_hh_total == 1, 1, 2),
         living_alone = factor(x = living_alone,
                               levels = c("1", "2"),
                               labels = c("alone", "not alone"))) %>%
  select(living_alone) %>% 
    glimpse()


# data_2019_test$living_alone
# glimpse(data_2019_test$living_alone)

str(data_2019_test$living_alone)

var_label(data_2019_test$living_alone) <- "Living alone"

```

<!-- Preparada. -->


## HOUSEHOLD SIZE (q0401_hh_total)
__¿Cuántas personas viven en el hogar?__ Con categorías:
- 1: one person
- 2: two persons
- 3: three or four persons
- 4: five or more persons
- 5: live in an institution

La variable `q0401_hh_total` sólo contempla el número de personas (1-10 hasta 10 personas),
no si viven institucionalizadas o no. Esto lo hace el ítem `q0400a` que no se encuentra en 
línea base porque ningún participante era institucionalizado en línea base. Por tanto, simplemente se trata de no incluir ningún valor etiquetado como 5.

- [ ] Revisar si está en Ola 2 (subestudio COVID)

### Exploración de variables
```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total) 
```

### Creación de la variable

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(hh_size = case_when(
                  q0401_hh_total == 1 ~ "1",
                  q0401_hh_total == 2 ~ "2",
                  q0401_hh_total == 3 ~ "3",
                  q0401_hh_total == 4 ~ "3",
                  q0401_hh_total >= 5 ~ "4"),
         
         hh_size = factor(x = hh_size,
                          levels = c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("one person", 
                                    "two persons", 
                                    "three or four persons", 
                                    "five or more persons", 
                                    "live in an institution", 
                                    "not assessed", 
                                    "missing (default)"))
  )

var_label(data_2019_test$hh_size) <- "Household size"

```

### Comprobación del funcionamiento de la nueva variable
```{r}
freq_table(data_2019_test, hh_size)

data_2019_test %>%
  group_by(hh_size) %>% 
  pivot_longer(hh_size, names_to = "size", values_to = "value") %>% 
  select(size, value) %>% 
  distinct() %>% 
  arrange(size, value) %>% 
  print(n = 150)
```

<!-- Completada. -->

## CHILDREN HOUSEHOLD (q0407_age_01-q0407_age_08/q0407_age_10)
__Are there children in your household?__
- 1 = Yes;
- 2 = No.

Según los comentarios encontrados en variable_list.xlsx, es necesario
combinar las tres variables: (q0407_age_01-q0407_age_08/q0407_age_10)

### Exploración de variables
```{r}
freq_table(data_2019_test, q0407_age_01)
data_2019_test %>% 
  select(q0407_age_01) %>% 
  arrange(q0407_age_01) #No hay menores de edad

freq_table(data_2019_test, q0407_age_08)
data_2019_test %>% 
  select(q0407_age_08) %>% 
  arrange(q0407_age_08) #Aquí aparecen cuatro menores de edad que no se están codificando bien. También hay NAs que no cambian su comportamiento (a -93)

freq_table(data_2019_test, q0407_age_10)
data_2019_test %>% 
  select(q0407_age_10) %>% 
  arrange(q0407_age_10) #Hay un menor de edad y el resto son NAs. 

data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>% 
  glimpse()
```

### Creación de variables
```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children_hh = case_when(
    q0407_age_01 < 18 | q0407_age_08 < 18 | q0407_age_10 < 18 ~ 1,
    q0407_age_01 >= 18 | q0407_age_08 >= 18 | q0407_age_10 >= 18 ~ 2,
    q0407_age_01 == is.na(q0407_age_01) | q0407_age_08 == is.na(q0407_age_08) | q0407_age_10 == is.na(q0407_age_01) ~ NON_RESPONSE
  ),
        children_hh = factor(x = children_hh,
                          levels = c("1", "2", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("yes", 
                                    "no",
                                    "not assessed", 
                                    "missing (default)"))
  )
```

### Comprobación
```{r}
freq_table(data_2019_test, children_hh) 
```

## GENDER (q1009_sex)

**Self-identified gvender** - 1: male - 2: female - 3: other/diverse -991: not
assessed -993: missing (default)

Our categories are: 1 = male; 2 0 female (and the question is not about the
self-identified gender, but sex).

### Variable exploration

```{r}
data_2019 %>%
  select(q1009_sex) %>%
  freq_table(q1009_sex)

data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  summarise_all(funs(sum(is.na(.))))

```

### Variable creation

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(gender = factor(x = q1009_sex,
                          levels = c("1", "2", "3", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("male", 
                                    "female",
                                    "other/diverse",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>%
  select(gender) %>%
  freq_table(gender)
```

## AGE (q1010_birth_date &/OR q1011_age)

The variable **age_continuous** is a continuous variable from 1 to 100. There is
also another variable, **age_cat**, a categorical v. with the following
levels: - \< 18 - 18 - 44 - 45 - 64 - 65 - 94 - \> 95

To obtain it we have two variables: date of birth and age.

There's no NAs in any of the variables. Elvira points out that there are
problems with the date of birth variable in some IDs (ID_ECS):

    18702401
    5600601
    3100602
    18702701
    2802002
    17801501
    16602601
    5800201
    19600501
    3300201
    7101202
    7101401
    14300101
    16800301

### Variable exploration

```{r}
data_2019 %>%
  select(q1010_birth_date, q1011_age) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>%  
  filter(ID_ECS == 18702401|
         ID_ECS == 5600601 |
         ID_ECS == 3100602 |
         ID_ECS == 18702701| 
         ID_ECS == 2802002 |
         ID_ECS == 17801501| 
         ID_ECS == 16602601| 
         ID_ECS == 5800201 |
         ID_ECS == 19600501| 
         ID_ECS == 3300201 |
         ID_ECS == 7101202 |
         ID_ECS == 7101401 |
         ID_ECS == 14300101| 
         ID_ECS == 16800301) %>% 
  select(q1010_birth_date, q1011_age) %>% 
  View()

```

Can we use exclusively the Age variable?

```{r}
data_2019_test %>%
  select(q1011_age) %>%
  freq_table(q1011_age) %>% 
  print(n = 82)
```

### Variables creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(age_continuous = q1011_age,
         age_cat = case_when(
           q1011_age < 18 ~ 1,
           q1011_age >= 18 & q1011_age <= 44 ~ 2,
           q1011_age >= 45 & q1011_age <= 64 ~ 3,
           q1011_age >= 65 & q1011_age <= 94 ~ 4, 
           q1011_age >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels= c("1", "2", "3", "4", "5", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variables

```{r}
data_2019_test %>% 
  select(age_cat) %>% 
  freq_table(age_cat)

data_2019_test %>% 
  select(age_continuous) %>% 
  View()
```

## RELATIONSHIP STATUS (q1012_mar_stat)

**Relationship status** is a categorical variable with the following levels: 1 =
Single 2 = Married /in a civil union 3 = in a relationship and living together 4
= in a relationship and living apart 5 = divorced/separated 6 = widowed 7 =
other

Our variable `q1012_mar_stat` is coded as: 1 = never married (and no cohabiting)
2 = currently married/law-partner 3 = cohabiting 4 = separated/divorced 5 =
widowed

As the categories doesn't match exactly, I propose the following categorisation:
1 = single --\> 1 (never married and no cohabiting) 2 = married / in a civil
union --\> 2 (currently married/law-partner) 3 = in a relationship and living
together --\> 3 (cohabiting) 4 = in a relationship and living apart --\>
MISSING_DESIGN 5 = divorced/separated --\> 4 (separated/divorced) 6 = widowed
--\> 5 (widowed) 7 = other --\> MISSING_DESIGN

### Variable exploration

```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>%
  select(q1012_mar_stat) %>%
  freq_table(q1012_mar_stat)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(relationship = case_when(
           q1012_mar_stat == 1 ~ 1,
           q1012_mar_stat == 2 ~ 2,
           q1012_mar_stat == 3 ~ 3,
           q1012_mar_stat == 4 ~ 5, 
           q1012_mar_stat == 5 ~ 6,
         ), 
         relationship = factor(x = relationship,
                          levels= c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("single", 
                                    "married/in a civil union",
                                    "in a relationship and living together",
                                    "in a relationship and living apart",
                                    "divorced/separated",
                                    "widowed",
                                    "other",
                                    "not assessed", 
                                    "missing (default)")))
```

### Checking new variable

```{r}
data_2019_test %>% 
  select(relationship) %>% 
  freq_table(relationship)
```

## EDUCATION (q1016_highest)

**Highest level of education according to ISCED Classification**:

-   1 = primary/basic: (primary education and lower secundary education)
-   2 = secondary/intermediate: (upper secondary education, post-secondary
    non-tertiary education)
-   3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or
    equivalent level, master's or equivalent level, doctoral or equivalent
    level)
-   4 = no formal education / less than basic (no schooling, early childhood
    education) -991 = not assessed -993: level not stated - if following yellow
    box, if not, "missing (default)"

Our variable, `q1016_highest`, has as levels (doesn't have *non-tertiary
education*): - 0 = No formal education - 1 = Primary education not completed - 2
= Primary education completed - 3 = Lower secondary education completed - 4 =
Upper secondary education completed - 5 = University/college completed - 6 =
Master degree, PhD completed - 888 = don't know

As a proposal, I suggest: - 1 = primary/basic --\> 1, 2, 3 - 2 =
secondary/intermediate: 4, - 3 = tertiary/advanced: 5, 6 - 4 = no formal
education / less than basic: 0

### Variable exploration

```{r}
data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs, but 888 as DK.

data_2019 %>% 
  select(q1016_highest) %>%
  freq_table(q1016_highest)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(education = case_when(
           q1016_highest == 0 ~ 4,
           q1016_highest == 1 | q1016_highest == 2 | q1016_highest == 3 ~ 1,
           q1016_highest == 4 ~ 2, 
           q1016_highest == 5 | q1016_highest == 6 ~ 3,
           q1016_highest == 888 ~ NON_RESPONSE,
         ), 
         education = factor(x = education,
                          levels= c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("primary/basic", 
                                    "secondary/intermediate",
                                    "tertiary/advanced",
                                    "no formal education",
                                    "not assessed", 
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(education) %>%
  freq_table(education)
```

## MIGRATION (q1018_country)

**Country of birth other than country of residence**: - 1 = Yes - 2 = No - 3 =
No information - 991 - 993

Our variable has registered the name of each country. As we did the sample
collection in Spain, we can assume that responses that are different than Spain
are indicators of migration.

### Variable exploration

```{r}
data_2019 %>%
  select(q1018_country) %>%
  summarise_all(funs(sum(is.na(.)))) #No NAs

data_2019 %>% 
  select(q1018_country) %>%
  freq_table(q1018_country)
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(
    migration = if_else(q1018_country == 1, 2, 1),
    migration = factor(x = migration,
                       levels= c("1", "2", "3", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("yes", 
                                    "no",
                                    "no information",
                                    "not assessed", 
                                    "missing (default)")))
```

-   [ ] Does it make sense to have No information and the other two categories
    of NAs?

### Checking new variable

```{r}
data_2019_test %>% 
  select(migration) %>%
  freq_table(migration)
```

## Children (q1056/q1058)

**Do you have children, live with children or take care of children in your
household?** - 1 = yes, - 2 = no - 991 - 993

Our variables `q1056` & `q1058` ask about biological and adopted children
(separated) (1 = yes; 2 = no). Elvira suggested to combine them and we'll follow
this approach.

### Variable exploration

```{r}
data_2019 %>%
  select(q1056, q1058) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1056) %>%
  freq_table(q1056) #1 = yes; #2 = no

data_2019 %>% 
  select(q1058) %>% #1 = yes; #2 = no
  freq_table(q1058) 

```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(children = case_when(
           q1056 == 1 | q1058 == 1 ~ 1,
           q1056 == 2 | q1058 == 2 ~ 2
         ), 
         children = factor(x = children,
                          levels= c("1", "2", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("yes", 
                                    "no",
                                    "not assessed", 
                                    "missing (default)")))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(children) %>%
  freq_table(children)
```

-   [ ] These results doesn't add up with children household (children_hh)
    variable. Following children_hh, there are no children in most of households
    sampled.

## N. O. CHILDREN (q1057/q1059)

Is the same as the previous one but in a continuous way: \_\_How many children
do you have? (including children who are not your own but live in the same
household or who you care for in your household?) - 1 = no children - 2 = one
child - 3 = two or three - 4 = four or more - 991 - 993

Variables in ECS makes a differentiation between biological and adopted children
(1+, DK). As a proposal, it is suggested to combine the two variables.

### Variable exploration

```{r}
data_2019 %>%
  select(q1057, q1059) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs

data_2019 %>% 
  select(q1057) %>%
  freq_table(q1057) #variable cuanti (1 = 1... Etc.) 888 = Don't know (sustituir esto por -93 ¿?. Los NAs hay que sustituirlos por 1)

data_2019 %>% 
  select(q1059) %>% #variable cuanti (1 = 1, 2 = 2, 3 = 3, 2978 NAs, que hay que sustituirlos por 1 (No children))
  freq_table(q1059) 

```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(nofchildren = case_when(
           q1057 == is.na(q1057) | q1059 == is.na(q1059) ~ 1, #no children
           q1057 == 1 | q1059 == 1 ~ 2, #one children
           q1057 == 2 | q1059 == 2 | q1057 == 3 | q1059 == 3 ~ 3, #two or three children
           q1057 >= 4 | q1059 >= 4 ~ 4, # four or more
           q1057 == 888 | q1059 == 888 ~ NON_RESPONSE
         ), 
         nofchildren = factor(x = nofchildren,
                          levels= c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("no children", 
                                    "one child",
                                    "two or three",
                                    "four or more",
                                    "not assessed", 
                                    "missing (default)")))

```

-   [ ] Darle una segunda vuelta a esto, porque igual hay gente que tiene hijos
    adoptados e hijos biológicos al mismo tiempo. En ese caso hay que sumarlos.
    -   [ ] Ver qué filas tienen casos en los dos mayores o iguales a 1.

### Checking new variable

```{r}
data_2019_test %>% 
  select(nofchildren) %>%
  freq_table(nofchildren)
```

## EMPLOYMENT STATUS (`q1503_work_now` & `q1504_reason`.)

**Employment status** has the following levels: 1 = Have a job (employed or
self-employed) 2 = In education 3 = Care work (familiy) / homeworker/ on
parental leave 4 = On long-term sick leave/disability 5 = Unable to work due to
reasosn not mentioned elsewhere in this list 6 = unemployed or job-seeking 7 =
retired

-991 = not assessed -993 = missing (default)

`q1503_work_now` (c2019_w1) *Currently working?*: - 1 = Yes - 2 = No

`q1504_reason` (c2019_w1) *Reason not working*: - 1 = homemaker - 2 = couldn't
find a job - 3 = unpaid/voluntary - 4 = studies/training - 5 = health - 6 = care
family - 7 = no need - 8 = not permited - 9 = retired/too old - 10 = laid off -
11 = seasonal work - 12 = does not want to for a while - 13 = vacation/sick or
maternity leave - 87 = other.

As a proposal, I suggest the following combination of both variables:

-   1 = Have a job (employed or self-employed) == 1 (q1503_work_now)
-   2 = In education (currently studying) == 4 (q1504_reason)
-   3 = Care work (family) / homeworker / on parental leave == 1, 6, 13
    (q1504_reason), - cuidado con 13 porque se solapa con la opción "4" de
    vardict
-   4 = On long-term sick leave/disability == 13 (q1504_reason), 5 (health),
-   5 = Unable to work due to reasons not mentioned elsewhere in this list
    (other) == 3 (unpaid/voluntary), 7 (no need), 8 (not permitted), 12 (does
    not want to for a while), 87
-   6 = unemployed or job-seeking == 2 (couldn't find a job), 10 (laid off), 11
    (seasonal work),
-   7 = retired == 9

### Variable exploration

```{r}
data_2019 %>%
  select(q1503_work_now, q1504_reason) %>%
  summarise_all(funs(sum(is.na(.)))) #NAs (347 en work-now y 1387 en reason)

data_2019 %>% 
  select(q1503_work_now) %>%
  freq_table(q1503_work_now) #1 = yes; 2 = no; NAs = -93

data_2019 %>% 
  select(q1504_reason) %>% #Sustituiremos los NA como -93
  freq_table(q1504_reason) 

```

### Variable creation

```{r}

data_2019_test <-
  data_2019_test %>% 
  mutate(employment_st = case_when(
           q1503_work_now == 1 ~ 1, #have a job
           q1504_reason == 4 ~ 2, #studying
           q1504_reason == 1 | q1504_reason == 6 ~ 3, #care work (eliminamos la 13 para meterla en la siguiente - LA 13 es vacation/sick or maternity leave)
           q1504_reason == 13 | q1504_reason == 5 ~ 4, # on long term sick leave disability
           q1504_reason == 3 | q1504_reason == 7 | q1504_reason == 8 | q1504_reason == 11 | q1504_reason == 12 | q1504_reason == 87 ~ 5, #other reasons
           q1504_reason == 2 | q1504_reason == 10 |q1057 == 11 ~ 6, #unemployed or job-seeking
           q1504_reason == 9 ~ 7,
           q1504_reason == is.na(q1504_reason) | q1503_work_now == is.na(q1503_work_now) ~ NON_RESPONSE
         ), 
          employment_st = factor(x = employment_st,
                          levels= c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("Have a job (employed or self-employed)", 
                                    "In education",
                                    "Care work (familiy) / homeworker/ on parental leave",
                                    "On long-term sick leave/disability",
                                    "Unable to work due to reasons not mentioned elsewhere in this list", 
                                    "unemployed or job-seeking", 
                                    "retired",
                                    "not assessed",
                                    "missing (default)"
                                    )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(employment_st) %>%
  freq_table(employment_st)
```

## PROFESSION (q1510_catoccu)

**Best description of current occupation(s)** - 1 undergoing education - 2
education and research - 3 arts, entertainment, sports and media - 4
healthcare - 5 first responder (paramedic/firefighter/police) - 6 military - 7
civil services, politics - 8 finance and economy - 9 industry - 10 sales and
services (incl. restaurants and bars) - 11 transport (goods and people) - 12
installation, maintenance, cleaning, and repairs - 13 currently not working - 14
other (please specify)

`q1510_catoccu` follows the OIT categorization; differs almost in every level
with the one proposed for RESPOND. What to do? - 1 Legislators -----\> 7 (civil
services, politics) - 2 Professionals ----\> - 3 Technicians - 4 Clerks ------\>
12 (installation, maintenance, cleaning and repairs) - 5 Service workers - 6
Skilled agricultural workers - 7 Craft workers - 8 Plant operators - 9
Elementary occupations - 10 Armed forces -----\> 6 (military)

-   [ ] TO-DO: Establish a new system categorisation for accommodating our data
    into RESPOND characteristics.

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_catoccu) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510_catoccu) %>%
  freq_table(q1510_catoccu) #Hay 347 NAs.

```

### Variable creation

```{r}
#Creamos la variable
data_2019_test <-
  data_2019_test %>% 
  mutate(profession = case_when(
           
         ), 
          profession = factor(x = profession,
                          levels= c("1", "2", "3", "4", "5", "6", "7", MISSING_DESIGN, NON_RESPONSE),
                          labels= c("undergoing education", 
                                    "education and research",
                                    "arts, entertainment, sports and media",
                                    "healthcare",
                                    "first responder (paramedic/firefighter/police)", 
                                    "military", 
                                    "civil services, politics",
                                    "finance and economy",
                                    "sales and services (incl. restaurants and bars)",
                                    "transport (goods and people)",
                                    "installation, maintenance, cleaning, and repairs",
                                    "currently not working",
                                    "other",
                                    "not assessed",
                                    "missing (default)"
                                    )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(pofession) %>%
  freq_table(profession)
```

## CONTRACT (q1510b_contract_earner)

**Permanent/temporary contract** - 1 permanent - 2 temporary - 3 self-employed -
4 other - Missing values/categories:\
- -991 not assessed - -993 missing (default)

In EcS: - 1 officer ----\> 1 permanent - 2 indefinite period (not officer)
----\> 3 self-employed - 3 temporal or contract of works and services ---\> 2
temporary - 4 verbal or without contract ---\> 4 - 888 DK --\> -993 - 999
refused to answer ---\> -993

-   [ ] As the variables are not exactly the same, there's a need to clarificate
    and agree on a combination proposal.

### Variable exploration

```{r}
data_2019 %>%
  select(q1510b_contract_earner) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510b_contract_earner) %>%
  freq_table(q1510b_contract_earner) #Hay NAs que codificar a -93
```

### Variable creation

```{r}
data_2019_test <-
  data_2019_test %>% 
  mutate(contract = case_when(
           
         ), 
          contract = factor(x = contract,
                          levels= c("1", "2", "3", "4",  MISSING_DESIGN, NON_RESPONSE),
                          labels= c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "missing (default)"
 )))

```

### Checking new variable

```{r}
data_2019_test %>% 
  select(contract) %>%
  freq_table(contract)
```

## EMPLOYMENT TYPE (q1510_workday)

-   1 - Full time
-   2 - Part time
-   3 - No paid work
-   4 - Other
-   -91 not assessed
-   -92 refused to answer
-   -93 missing (default)

In EcS: - 1 Part time (morning and afternoon) ---\> 2 - 2 Continuous morning
working day ---\> 1 - 3 Continuous afternoon working day ----\> 1 - 4 Continuous
night working day ----\> 1 - 5 Reduced work day ---\> 4 - 6 Shift work /
irregular or variable work --\> 2 - 7 Other type ---\> 4 - 888 DK ---\> -92

-   [ ] TODO: Comprobar si se han incluido en todas las olas; modificarlo si es
    necesario.

### Variable exploration

```{r}
data_2019 %>%
  select(q1510_workday) %>%
  summarise_all(funs(sum(is.na(.))))

data_2019 %>% 
  select(q1510e_workday) %>%
  freq_table(q1510e_workday)

```

### Variable creation

### Checking new variable

## RESILIENCE SCALE (BRS)

### Ola 1

Tenemos resilience_scale y los ítems individuales: q7537, q7538, q7539, q7540,
q7541, q7542 TODO: Añadir una fila por cada ítem individual.

### Ola 2

Tenemos resilience_scale y los ítems individuales: SM26_1, SM26_2, SM26_3,
SM26_4, SM26_5, SM26_6 - [ ] TODO: Añadir una fila por cada ítem individual. - [
] duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato long)

## Social support

### Ola 1

Tenemos social_support y los ítems individuales: - [ ] TODO: Añadir una fila por
cada ítem individual.

### Ola 2

Tenemos social_support y los ítems individuales: - [ ] TODO: Añadir una fila por
cada ítem individual. - [ ] TODO duda: ¿hay que cambiar el nombre de los items
en la BBDD final? (formato long) - [ ] TODO: encontrar los ítems individuales

## C.O RESIDENCE

-   [ ] TODO: To be created (comment from Elvira: this variable should be
    created)
-   [ ] TODO: Ver qué variables pueden formar esta variable.
-   [ ] TODO: variable dictionary: "residence" is a new variable and replaces
    the formerly included variable "c.o. residence". Note variables NUTS-1 to
    NUTS-3 (s. variable dictionaries 20 to 22) are "20_geographics NUTS-1",
    "21_geographics NUTS-2", and "22_geographics areno NUTS-3" are discarded.

Find NUTS territorial unit codes at:
<https://drzmainz.sharepoint.com/:x:/s/obiba-wp2/Ecl70YGS_79HmKhWAGd3QzsBz9BGEIHRfuIOeSgpqRaYGw?e=4rfPmo> -
[ ] Me da error: internal users only - [ ] Comentario de Elvira: All
participants live din Spain. We could create this variable.

## Stressor (life events)

Tenemos la escala completa: lte. Los ítems individuales: q4659_ill
q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff
q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police
q4670_stolen

-   [] TODO: Crear nuevas filas por cada ítem.

