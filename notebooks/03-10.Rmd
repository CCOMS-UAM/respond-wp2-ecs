---
title: "Preparating variable_list.xlsx with Edad con Salud data"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), '%d de %B de %Y')`"
institute: CCOMS, Universidad Autónoma de Madrid
output: 
  html_notebook:
  toc: yes
  toc_float: yes
  keep_md: yes
editor_options: 
  chunk_output_type: console
---

```{r library}
#library calls 
#puede ser interesante revisar packup package (esto se recomienda que esté arriba)
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
```

```{r read-data}
#Aquí se leen todos los archivos de datos
#¿Cómo se puede utilizar una ruta relativa para OneDrive sin querer trabajar luego en esa carpeta?
#Una opción es establecer UAM como wd al principio y luego cambiarlo, esto es un poco confuso¿?
data_2019 <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Ola_3/Cohorte_2019/rawdata_c2019w1.dta")

data_COVID <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")

data_2019_test <- data_2019
#El formato importado desde .dta a R es un formato doble: la clase y la etiqueta (el label). Las labels son parte de los metadatos que tienen los datos (vectores y columnas de un dataframe). Esto dificulta un poco las cosas. Los value labels no suponen una implicación sobre la consideración categórica o continua (no se utilizan para el análisis de datos). Por eso, antes de hacer un análisis de datos es necesario convertir los vectores con value labels en factores o en vectores clásicos numéricos/carácteres. 

#Esto se puede hacer de dos maneras: o ya desde el principio se conviert en factores o en vectores numéricos o carácter con unlabelled(), to_factor() o unclass(), o cuando ya se ha hecho la limpieza de los datos y se quiere mantener esa info para la exportación. 

```

A la espera de nuevos correos, vamos a ir haciendo los preparativos para organizar el dataset de Edad con Salud para RESPOND.

# El archivo variable_list.xlsx

Este archivo reúne **todas las variables** que tiene cada estudio. Es necesario comprobar que todos los outcomes están incluidos (ver los archivos [mental health outcomes](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7BA66AD0BE-D072-4CB3-8072-F4FF5C92BF9D%7D&file=mental_health_measures_hs.xlsx&action=default&mobileredirect=true) y [predictores](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7B37F195E1-399B-48CE-9E11-5B2B8B83B210%7D&file=predictor_candidates_by_study_hs.xlsx&action=default&mobileredirect=true) para comprobar que está todo lo que tiene que estar). 

```{r}

# Coding of missing values:
# -91 specifies a variable has not been assessed in general (eg, at this point of data collection), so it is missing by design.
# 
# -93 specifies missings (default) from data collections that actually took place (eg, this exact questionnaire had been assessed at this timepoint, but the participant did not answer for whatever reason).
```


# Cambios a realizar

## Create HC Worker from baseline wave using q1510_occ (wave 1)
```{r}
glimpse(data_2019$q1510_occ)

data_2019 %>%
  select(q1510_occ) %>%
  distinct()

#Existen 1824 valores únicos para esta variable y se hace necesario filtrarla para ver los que sean "health care workers" (1 = Sí, 0 = No)

#TODO: Explorar otras variables/ítems del cuestionario que permitan extraer la ocupación (e.g., códigos ISCO). Contamos principalmente con dos variables que registran la ocupación: q1510_occ (abierta) y q1510cat, que utiliza la estructura de la CIUO-08 (códigos ISCO, de la OIT). A nosotros nos interesa la categorización:

# GRUPO 2 "PROFESIONALES CIENTÍFICOS E INTELECTUALES" > PROFESIONALES DE LA SALUD
#*Aunque incluso con esto no sabemos si son health care workers (e.g., administrativos?).


#TODO: Revisar la pregunta ISCO que tiene categorizado esto (para no tener que analizar todo el contenido)
glimpse(data_2019$q1510_catoccu)

data_2019 %>%
  select(q1510_catoccu) %>%
  distinct()

freq_table(data_2019, q1510_catoccu)

#Vemos cómo sólo contiene la categorización de los 10 grupos principales, no de los subgrupos. 

#Conclusión: Lo descartamos porque no hay una variable que diferencie a los profesionales de la salud. Se tiene que trabajar con la variable q1510.

#TODO: Hay alguna manera de automatizar esto?
# Probamos con las expresiones regulares. RegExplain es un addin de R para manipular las expresiones regulares. Vemos que algunos de las opciones de texto que nos interesan son:

#SADSERVICIO ATENCION DOMICILIARIA enfermera mÃ©dica cardiÃ³loga medico traumatologo auxiliar enfermera auxiliar de enfermeria MÃ©dico homeÃ³pata

#Sin embargo, sólo se han mostrado las 100 primeras únicas. Necesitamos las 1824:

data_2019$q1510_occ %>% 
  str_extract_all("enf", simplify = T) #Esto no ha funcionado.


#La idea es crear una nueva variable de manera que el patrón detectado suponga un 1, y el resto un 0. 

data_2019_test <- data_2019 %>%
                    mutate( # 1 = mental health worker; 0 = non mental health worker
                      occ_mhw = if_else(str_detect(q1510_occ, "enf"), 1,
                                        if_else(str_detect(q1510_occ, "med"), 1,
                                                if_else(str_detect(q1510_occ, "traum"), 1, 
                                                        if_else(str_detect(q1510_occ, "aux"), 1,
                                                                ifelse(str_detect(q1510_occ, "SADSERVICIO"), 1, 0)))))
                    )
glimpse(data_2019_test$occ_mhw)  #Funciona

#TODO: Ver cómo conseguir una lista de todos los patrones que nos interesan. 

```

##Income quartiles (hhquintile) - wave 1
```{r}
# TODO: Buscar ítems relacionados con los ingresos.

#Las preguntas relacionadas con los ingresos son escasas (¿?): q1519 pregunta por la situación financiera en la infancia;las preguntas q0410g, i, j, k, l, n también hablan de ello:
# g: Ingresos personales brutos de todos los miembros de su familia durante los últimos 12 meses 
# i: ingresos brutos de su hogar durante los últimos 12 meses procedentes de la pensión de jubilación
# j: de programas de ayudas oficiales (paro, hijos dependientes, viudedad, orfandad, asistencia general),
# k: de fuentes privadas (pensiones, inversiones, alimenticias o de mantenimiento). 

#Subset de las variables de interés:
data_2019 %>%
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 

#Ver cuántos valores únicos hay por cada variable
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),names_to = "income", values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)



#Exploración gráfica de las variables

g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4) #Tiene que haber otra manera, pero bueno

#TODO: preguntar a Dani cómo gestionar esta variable porque se encuentra en rangos (es una variable categórica con 34 niveles a los que pertenece un rango distinto)

#Dani me pasa el archivo Edad_con_Salud_Data.R. La idea que tengo es la de recodificar estas cuatro variables por la mediana del rango establecido en la codificación, ya que las preguntas q0410 establecen rangos de respuesta. Esta manera de proceder la extraigo de su script de R. 

#El formato de stata es doble: por un lado el valor numérico y por otro la etiqueta. Como del script de Dani ya tenemos los valores numéricos, lo que hacemos es transformarlas a variables numéricas:


data_2019_test <- data_2019
data_2019_test$q0410g_total <- as.numeric(data_2019_test$q0410g_total)
data_2019_test$q0410i_ss <- as.numeric(data_2019_test$q0410i_ss)
data_2019_test$q0410j_government <- as.numeric(data_2019_test$q0410j_government)
data_2019_test$q0410k_other <- as.numeric(data_2019_test$q0410k_other) #Tiene que haber una manera más tidy de hacer esto


str(data_2019_test$q0410g_total)

#También lo podemos recodificar a factor

data_2019_test$q0410g_total <- as.factor(data_2019_test$q0410g_total)
data_2019_test$q0410i_ss <- as.factor(data_2019_test$q0410i_ss)
data_2019_test$q0410j_government <- as.factor(data_2019_test$q0410j_government)
data_2019_test$q0410k_other <- as.factor(data_2019_test$q0410k_other) #Tiene que haber otra forma más tidy de hacer esto


data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )


#TODO: Ver por qué no se recodifica bien

#TODO: Qué hacer con los valores perdidos? -92 y -93
#DONE: Ver las variable_list (refused vs no-disponible)




#TODO: Una suma de todas esas variables para encontrar los ingresos totales y luego hacer los quintiles?
#Tenemos las variables en factor:

str(data_2019_test$q0410g_total_r)

#Hay que convertirlas a numeric para poder hacer la suma

data_2019_test <- 
  data_2019_test %>% 
    mutate(q0410g_total_r = as.numeric(q0410g_total_r),
           q0410i_ss_r = as.numeric(q0410i_ss_r),
           q0410j_government_r = as.numeric(q0410j_government_r),
           q0410k_other_r = as.numeric(q0410k_other_r))

data_2019_test <- data_2019_test %>%
  filter(!q0410g_total_r == -92, !q0410g_total_r == -93, 
         !q0410i_ss_r == -92, !q0410i_ss_r == -93,
         !q0410j_government_r == -92, !q0410j_government_r == -93,
         !q0410k_other_r == -92, !q0410k_other_r == -93) %>%
  mutate(hh_income_r = q0410g_total_r + q0410i_ss_r + q0410j_government_r + q0410k_other_r)

glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r)

#TODO: Calculamos los cuantiles con quantile(x)
quintiles <- quantile(data_2019_test$hh_income_r) #Los quintiles son 4, 6, 22, 33, 106 (esto está mal)
quintiles <- unname(quintiles)

quintiles[1]
#Recodificamos en quintiles

data_2019_test <- data_2019_test %>% 
  mutate(hhquintile = if_else(hh_income_r <= quintiles[1], 1,
                             if_else(hh_income_r > quintiles[1] & hh_income_r <= quintiles[2], 2,
                                     if_else(hh_income_r > quintiles[2] & hh_income_r <= quintiles[3], 3,
                                             if_else(hh_income_r > quintiles[3] & hh_income_r <= quintiles[4], 4,
                                                    if_else(hh_income_r > quintiles[4] & hh_income_r <= quintiles[5], 5,
                                                            if_else(hh_income_r == -92, -92,
                                                                    if_else(hh_income_r == -93, -93, 0))))))))

glimpse(data_2019_test$inc_quint)

#TODO: Falta por corregir la recodificación en variables factor (por qué no salen con la etiqueta asignada y queda la anterior). Falta por corregir el tema de los valores perdidos en la suma (quizás proponer después una regla que sea que los múltiplos de -92 o -93 se vuelvan a codificar por este número)

```
## Stressor (life events)
```{r}
# Los ítems son: lte / q4659_ill q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police q4670_stolen
#TODO: lte es una variable que ya existe. Queda añadir una columna por cada ítem por separado.
#TODO: ver las variable dictionaries por si habría que añadir algo
#TODO: No hay variable dictionaries. Preguntar en la drop-in session (17/10/2022)
#DONE: Se sube simplemente el listado de variables; hay una armonización que se hará dentro de Opal. 
```



## Living alone (q0401_hh_total) - wave 1
_¿Cuál es el número total de personas que viven habitualmente en este hogar?_
It has to be categorised as 1 = alone; 2 = not alone.
En la actualidad es una variable que va del 1 al 10 
```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total)

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos

data_2019_test <- data_2019_test %>% 
  mutate(living_alone = if_else(q0401_hh_total == 1, 1, 2),
         living_alone = factor(x = living_alone,
                               levels = c("1", "2"),
                               labels = c("alone", "not alone"))) %>% 
    glimpse(living_alone) #Por qué esto no funciona?


data_2019_test$living_alone
glimpse(data_2019_test$living_alone)

#TODO: Preparada.
#TODO: Añadir labels
#DONE!
```

##Household size (q0401_hh_total)
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta
#Las categorías son:
##1: one person
##2: two persons
##3: three or four persons
##4: five or more persons
##5: live in an institution
##-91: not assessed
##-92: refused to answer
##-93: missing (default)

#El problema es que el ítem q0401_hh_total sólo contempla el número de personas (1-10 hasta 10 personas), no si viven en una institución o no. Eso lo hace el ítem q0400a

data_2019 %>%
  select(q1007_HH_member) %>%
  freq_table(q1007_HH_member) #esta indica el número de persona que es en el hogar

data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total) #esta indica el nº de personas que hay en el hogar totales


glimpse(data_2019_test$q1007_HH_member)
glimpse(data_2019_test$q1007_HH_member)

data_2019 %>%
  select(q0405_relation_02) %>%
  freq_table(q0405_relation_02)

glimpse(data_2019$q0405_relation_02) #estas variables indican el tipo de relación que hay con la persona que recibe más ingresos del hogar
glimpse(data_2019$q0405_relation_03)
glimpse(data_2019$q0405_relation_04)
glimpse(data_2019$q0405_relation_05)
glimpse(data_2019$q0405_relation_06)
glimpse(data_2019$q0405_relation_07)
glimpse(data_2019$q0405_relation_08)
glimpse(data_2019$q0405_relation_09)

#TODO: Hablar con Dani para ver qué podemos hacer a este respecto.
#TODO: Correo a Marta
#TODO: En línea base no se incluyen personas institucionalizadas, por lo que para crear la variable sólo es necesario utilizar q0401_hh_total y en 5 marcar NA

data_2019 %>%
  select(q0401_hh_total) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos

#Creamos la variable. Nuestra variable de partida tiene 10 categorías (1-10) y las tenemos que resumir en:
#Las categorías son:
##1: one person
##2: two persons
##3: three or four persons
##4: five or more persons
##5: live in an institution
##-91: not assessed
##-92: refused to answer
##-93: missing (default)

data_2019_test <- data_2019_test %>% 
  mutate(hh_size = case_when(
                  q0401_hh_total == 1 ~ "1",
                  q0401_hh_total == 2 ~ "2",
                  q0401_hh_total == 3 ~ "3",
                  q0401_hh_total == 4 ~ "3",
                  q0401_hh_total >= 5 ~ "4"),
         
         hh_size = factor(x = hh_size,
                          levels= c("1", "2", "3", "4", "5", "-91", "-92", "-93"),
                          labels= c("one person", 
                                    "two persons", 
                                    "three or four persons", 
                                    "five or more persons", 
                                    "live in an institution", 
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)"))
  )

glimpse(data_2019_test$hh_size)
freq_table(data_2019_test, hh_size)
freq_table(data_2019_test, q0401_hh_total)

data_2019_test %>%
  group_by(hh_size) %>% 
  pivot_longer(hh_size, names_to = "size", values_to = "value") %>% 
  select(size, value) %>% 
  distinct() %>% 
  arrange(size, value) %>% 
  print(n = 150)

#Esta versión de aquí no funciona, ver por qué.
# data_2019_test <- data_2019_test %>% 
#   mutate(hh_size = if_else(q0401_hh_total == 1, 1,
#                            if_else(q0401_hh_total == 2, 2,
#                                    if_else(q0401_hh_total == 3, 3,
#                                            if_else(q0401_hh_total == 4, 3,
#                                                    if_else >= 5, 4)))),
#          hh_size = factor(x = hh_size,
#                           levels= c("1", "2", "3", "4", "5", "-91", "-92", "-93"),
#                           labels= c("one person", 
#                                     "two persons", 
#                                     "three or four persons", 
#                                     "five or more persons", 
#                                     "live in an institution", 
#                                     "not assessed", 
#                                     "refused to answer", 
#                                     "missing(default)")))
#         

#TODO: Done!!
```


## Children household (q0407_age_01-q0407_age_08/q0407_age_10)
Es necesario combinar todas estas variables en una sola.
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta
#La variable es Are there children in your household? 1 = Yes; 2 = No. 

#TODO: crear una nueva variable que combine todos los ítems en uno solo. 
#Vamos a ver qué tiene cada variable:
freq_table(data_2019_test, q0407_age_01)
data_2019_test %>% 
  select(q0407_age_01) %>% 
  arrange(q0407_age_01) #No hay menores de edad

freq_table(data_2019_test, q0407_age_08)
data_2019_test %>% 
  select(q0407_age_08) %>% 
  arrange(q0407_age_08) #Aquí aparecen cuatro menores de edad que no se están codificando bien. También hay NAs que no cambian su comportamiento (a -93)

freq_table(data_2019_test, q0407_age_10)
data_2019_test %>% 
  select(q0407_age_10) %>% 
  arrange(q0407_age_10) #Hay un menor de edad y el resto son NAs. 



data_2019 %>% 
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>% 
  glimpse()

#FIXME!!!! No funciona (no se convierten a NAs)
data_2019_test <-
  data_2019_test %>% 
  mutate(children_hh = case_when(
    # q0407_age_01 < 18 | q0407_age_08 < 18 | q0407_age_10 < 18 ~ 1,
    # q0407_age_01 >= 18 | q0407_age_08 >= 18 | q0407_age_10 >= 18 ~ 2,
    # q0407_age_01 == NA | q0407_age_08 == NA | q0407_age_10 == NA ~ -93
    
    
    
    # q0407_age_01 < 18 ~ "1",
    # q0407_age_01 >= 18 ~ "2",
    # q0407_age_01 == NA ~ "-93",
    # q0407_age_08 < 18 ~ "1",
    # q0407_age_08 >= 18 ~ "2",
    # q0407_age_08 == NA ~ "-93",
    # q0407_age_10 < 18 ~ "1",
    # q0407_age_10 >= 18 ~ "2",
    # 
    # q0407_age_10 == NA_integer_ ~ "-93"
  ),
        children_hh = factor(x = children_hh,
                          levels= c("1", "2", "-91", "-92", "-93"),
                          labels= c("Yes", 
                                    "No",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)"))
  ) #Este no me funciona. Voy a probar con if_else


data_2019_test <-
  data_2019_test %>% 
  mutate(
    children_hh = if_else()
  )

#Aquí vemos el resultado
freq_table(data_2019_test, children_hh)


```

## Gender (q1009_sex)
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta
# 1 = male; 2 = female; 3 = other/diverse
# Supongo que el problema viene por género =/= sexo, pero establecer qué es lo que ocurre. Nuestra categorización es 1 = male; 2 = female

data_2019 %>%
  select(q1009_sex) %>%
  freq_table(q1009_sex) #Ya está codificado como debería. No hay NAS.

data_2019_test <- data_2019_test %>% 
  mutate(gender = factor(x = q1009_sex,
                          levels= c("1", "2", "3", "-91", "-92", "-93"),
                          labels= c("male", 
                                    "female",
                                    "other/diverse",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)")))
data_2019_test %>%
  select(gender) %>%
  freq_table(gender)

#TODO: Done!!
```

## Age q1010_birth_date &/OR q1011_age
```{r}
#TODO: esperar respuesta de Dani (Elvira quería comentar con él alguna cosa y la cuestión del EPQR-A)
#TODO: Elvira nos cuenta que al revisar el cuestionario de seguimiento de cohorte 2019 se dio cuenta de que había fechas de nacimiento erróneas en la BBDD. No hay datos perdidos en la echa de nacimiento de línea base, pero la fecha de nacimiento q1010_birth_date está mal en los siguientes ID_ECS:
# 
# 18702401
# 5600601
# 3100602
# 18702701
# 2802002
# 17801501
# 16602601
# 5800201
# 19600501
# 3300201
# 7101202
# 7101401
# 14300101
# 16800301

#TODO:Revisar estas variables, crear una nueva variable única

data_2019 %>%  
  filter(ID_ECS == 18702401|
         ID_ECS == 5600601 |
         ID_ECS == 3100602 |
         ID_ECS == 18702701| 
         ID_ECS == 2802002 |
         ID_ECS == 17801501| 
         ID_ECS == 16602601| 
         ID_ECS == 5800201 |
         ID_ECS == 19600501| 
         ID_ECS == 3300201 |
         ID_ECS == 7101202 |
         ID_ECS == 7101401 |
         ID_ECS == 14300101| 
         ID_ECS == 16800301) %>% 
  select(q1010_birth_date, q1011_age)

#Efectivamente las fechas están mal. ¿Podemos utilizar sólo la variable edad?
data_2019_test %>%
  select(q1011_age) %>%
  freq_table(q1011_age) %>% 
  print(n = 82)

#Comprobamos que no tiene valores perdidos:
data_2019 %>%
  select(q1011_age) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos. 

#La variable 'age_continuous' va de 1-100, pero tenemos un caso con 101. 
#TODO. Ver qué hacer con esto. 

data_2019_test <-
  data_2019_test %>% 
  mutate(age_continuous = q1011_age,
         age_cat = case_when(
           q1011_age < 18 ~ 1,
           q1011_age >= 18 & q1011_age <= 44 ~ 2,
           q1011_age >= 45 & q1011_age <= 64 ~ 3,
           q1011_age >= 65 & q1011_age <= 94 ~ 4, 
           q1011_age >= 95 ~ 5
         ), 
         age_cat = factor(x = age_cat,
                          levels= c("1", "2", "3", "4", "5", "-91", "-92", "-93"),
                          labels= c("below 18 years", 
                                    "18-44",
                                    "45-64",
                                    "65-94",
                                    "95 years or older",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)"))) 
data_2019_test %>% 
  select(age_cat) %>% 
  freq_table(age_cat)

#TODO. Done!!

```



##Relationship status (q1012_mar_stat)
```{r}
#TODO: ver las variable dictionaries (relationship)
# Tiene que estar codificada como:
# 1 = Single
# 2 = Married /in a civil union
# 3 = in a relationship and living together
# 4 = in a relationship and living apart
# 5 = divorced/separated 
# 6 = widowed
# 7 = other

#-91: not assessed
#-92: refused to answer
#-93: missing (default)

#Nuestra variable está codificada como:
#1 = never married (and no cohabiting)
#2 = currently married/law-partner
#3 = cohabiting
#4 = separated/divorced
#5 = widowed

#TODO: Preguntar a Dani qué hacemos con los valores que no tienen exactamente el mismo significado.
data_2019 %>%
  select(q1012_mar_stat) %>%
  freq_table(q1012_mar_stat)

data_2019 %>%
  select(q1012_mar_stat) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos.

#Propuesta: Tenemos que cambiar la codificación de las últimas 4 categorías. En la final, 4 = in a relationship and living apart va a tener NAs (-91) porque en nuestra variable no recogemos esa información; 5 = divorced/separated va a ser nuestra categoría 4; la categoría 6 = widowed es nuestra categoría 5 y hay que crear una categoría 7. 

data_2019_test <-
  data_2019_test %>% 
  mutate(relationship = case_when(
           q1012_mar_stat == 1 ~ 1,
           q1012_mar_stat == 2 ~ 2,
           q1012_mar_stat == 3 ~ 3,
           q1012_mar_stat == 4 ~ 5, 
           q1012_mar_stat == 5 ~ 6,
         ), 
         relationship = factor(x = relationship,
                          levels= c("1", "2", "3", "4", "5", "6", "7", "-91", "-92", "-93"),
                          labels= c("single", 
                                    "married/in a civil union",
                                    "in a relationship and living together",
                                    "in a relationship and living apart",
                                    "divorced/separated",
                                    "widowed",
                                    "other",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)")))

#¿Es necesario asignar 4 == -91? ¿Cómo se podría hacer?
data_2019_test %>% 
  select(relationship) %>% 
  freq_table(relationship)

#TODO. Done!!
```

## Education (q1016_highest)
```{r}
#TODO: ver las variable dictionaries
#Highest achieved level of education according to ISCED classification
# 1  = primary/basic: (primary education and lower secundary education)
# 2 = secondary/intermediate: (upper secondary education, post-secondary non-tertiary education)
# 3 = tertiary/advanced: (short-cicle tertiary education, bachelor's or equivalent level, master's or equivalent level, doctoral or equivalent level)
# 4 = no formal education / less than basic (no schooling, early childhood education)
#-91 = not assessed
#-92 = refused to answer
#-93: level not stated - siguiendo el cuadrado amarillo, si no debería ser "missing(default)"

#Nuestra variable está codificada tal que: (nuestra variable NO recoge non-tertiary education)
#0 = No formal education
#1 = Primary education not completed
#2 = Primary education completed
#3 = Lower secondary education completed
#4 = Upper secondary education completed
#5 = University/college completed
#6 = Master degree, PhD completed
#888 = don't know

#TODO: recodificar la variable en una nueva con los valores de la variable dictionary.


data_2019 %>% 
  select(q1016_highest) %>%
  freq_table(q1016_highest)

data_2019 %>%
  select(q1016_highest) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos, pero 888 es DK.

data_2019_test <-
  data_2019_test %>% 
  mutate(education = case_when(
           q1016_highest == 0 ~ 4,
           q1016_highest == 1 | q1016_highest == 2 | q1016_highest == 3 ~ 1,
           q1016_highest == 4 ~ 2, 
           q1016_highest == 5 | q1016_highest == 6 ~ 3,
           q1016_highest == 888 ~ -93,
         ), 
         education = factor(x = education,
                          levels= c("1", "2", "3", "4", "-91", "-92", "-93"),
                          labels= c("primary/basic", 
                                    "secondary/intermediate",
                                    "tertiary/advanced",
                                    "no formal education",
                                    "not assessed", 
                                    "refused to answer", 
                                    "level not stated")))
data_2019_test %>% 
  select(education) %>%
  freq_table(education)

#TODO: Done!!!

```

## Migration (q1018_country)
```{r}
#TODO: ver las variable dictionaries
# Country of birth other than country of residence
# 1 = Yes, 2= No, 3 = No information
# -91 = not assessed
# -92 = refused to answer 
#-93 = missing (default)

#Nuestra variable:
#1. Spain
#2. Germany
#3. Bulgary
#4. France
#5. Portugal
#6. UK
#7. Romania
#8. Morocco
#9. Dominican Republic
#11. Argentina
#12. Bolivia
#13. Brazil
#14. Colombia
#15. Ecuador
#19. Italy
#21. Pakistan
#22. Russia
#23 Paraguay
#87. Other

#TODO: Propuesta: Estamos en España recogiendo muestra; por tanto, todo distinto a España es migración.

data_2019 %>% 
  select(q1018_country) %>%
  freq_table(q1018_country)

data_2019 %>%
  select(q1018_country) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay datos perdidos

data_2019_test <-
  data_2019_test %>% 
  mutate(
    migration = if_else(q1018_country == 1, 2, 1),
    migration = factor(x = migration,
                       levels= c("1", "2", "3", "-91", "-92", "-93"),
                          labels= c("yes", 
                                    "no",
                                    "no information",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)")))

data_2019_test %>% 
  select(migration) %>%
  freq_table(migration)

#TODO. Done!!!!!
```

## Children (q1056/q1058)
```{r}
#TODO: ver las variable dictionaries
#Do you have children, live with children or take care of children in your household?
#1 = yes; 2 = no
# -91 = not assessed
# -92 = refused to answer 
# -93 = missing (default)

#TODO. Explorar ambas variables.

data_2019 %>%
  select(q1056, q1058) %>%
  summarise_all(funs(sum(is.na(.)))) #No hay valores perdidos

data_2019 %>% 
  select(q1056) %>%
  freq_table(q1056) #1 = yes; #2 = no

data_2019 %>% 
  select(q1058) %>% #1 = yes; #2 = no
  freq_table(q1058) 

#TODO. Estos resultados no cuadran con la variable children household (por la que no hay menores en casa y aquí sí que los hay?)
#TODO. Nuestras variables responden a la categoría de niños biológicos y niños adoptados (1 = yes; 2 = no). Los deberíamos combinar? Propuesta: sí

data_2019_test <-
  data_2019_test %>% 
  mutate(children = case_when(
           q1056 == 1 | q1058 == 1 ~ 1,
           q1056 == 2 | q1058 == 2 ~ 2
         ), 
         children = factor(x = children,
                          levels= c("1", "2", "-91", "-92", "-93"),
                          labels= c("yes", 
                                    "no",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)")))
data_2019_test %>% 
  select(children) %>%
  freq_table(children)

#TODO. Done!!!!
```
## N.o. children (q1057/q1059)
```{r}
#TODO: ver las variable dictionaries
#How many children do you have? (including children who are not your own but live in the same household or who you care for in your household?)
# 1 = no children
#2 = one child
#3 = two or three
#4 = four or more
# -91 = not assessed
# -92 = refused to answer 
# -93 = missing (default)

#TODO. Nuestras variables responden a la categoría de niños biológicos y niños adoptados (1+; DK). Los deberíamos combinar?
#TODO. Qué diferencia hay con la de children household? (la anterior es categórica y esta es continua.)
#TODO. Debido al error que también señalaba en la variable anterior (children), propongo crear children household a partir de esta variable. 

#Exploramos las variables.


data_2019 %>%
  select(q1057, q1059) %>%
  summarise_all(funs(sum(is.na(.)))) #Existen valores perdidos

data_2019 %>% 
  select(q1057) %>%
  freq_table(q1057) #variable cuanti (1 = 1... Etc.) 888 = Don't know (sustituir esto por -93 ¿?. Los NAs hay que sustituirlos por 1)

data_2019 %>% 
  select(q1059) %>% #variable cuanti (1 = 1, 2 = 2, 3 = 3, 2978 NAs, que hay que sustituirlos por 1 (No children))
  freq_table(q1059) 

#Creamos la nueva variable
data_2019_test <-
  data_2019_test %>% 
  mutate(nofchildren = case_when(
           q1057 == NA | q1059 == NA ~ 1, #no children
           q1057 == 1 | q1059 == 1 ~ 2, #one children
           q1057 == 2 | q1059 == 2 | q1057 == 3 | q1059 == 3 ~ 3, #two or three children
           q1057 >= 4 | q1059 >= 4 ~ 4, # four or more
           q1057 == 888 | q1059 == 888 ~ -93
         ), 
         nofchildren = factor(x = nofchildren,
                          levels= c("1", "2", "3", "4", "-91", "-92", "-93"),
                          labels= c("no children", 
                                    "one child",
                                    "two or three",
                                    "four or more",
                                    "not assessed", 
                                    "refused to answer", 
                                    "missing (default)")))
data_2019_test %>% 
  select(nofchildren) %>%
  freq_table(nofchildren)

#TODO. Resolver duda general al transformar NAs con case_when. Queda resolver esto para poder terminar la variable. 

```

## Employment status
Hay que crear esta variable a partir de los items `q1503_work_now` y `q1504_reason`.
```{r}
#TODO: crear la variable. Ver variable dictionaries.
#1 = Have a job (employed or self-employed)
#2 = In education
#3 = Care work (familiy) / homeworker/ on parental leave
#4 = On long-term sick leave/disability
#5 = Unable to work due to reasosn not mentioned elsewhere in this list
#6 = unemployed or job-seeking
#7 = retired

# -91 = not assessed
# -92 = refused to answer
# -93 = missing (default)


#Nosotras tenemos:
#Currently working? (c2019_w1; q1503_work_now): 1 = yes; 2 = no
#Reason not working (c2019_w1, q1504_reason): 
#1 = homemaker, 2 = couldn't find a job, 3 = unpaid/voluntary; 4 = studies/training; 5 = health; 6 = care family; 7 = no need; 8 = not permited; 9 = retired/too old; 10 = laid off; 11 = seasonal work; 12 = does not want to for a while; 13 = vacation/sick or maternity leave; 87= other.

#TODO. Establecer paralelismos entre las categorías propuestas y las nuestras.
# 1 = Have a job (employed or self-employed) == 1 (q1503_work_now)
# 2 = In education (currently studying) == 4 (q1504_reason)
# 3 = Care work (family) / homeworker / on parental leave == 1, 6, 13 (q1504_reason), - cuidado con 13 porque se solapa con la opción "4" de vardict
# 4 = On long-term sick leave/disability == 13 (q1504_reason), 5 (health), 
# 5 = Unable to work due to reasons not mentioned elsewhere in this list (other) == 3 (unpaid/voluntary), 7 (no need), 8 (not permitted),  12 (does not want to for a while), 87
# 6 = unemployed or job-seeking == 2 (couldn't find a job), 10 (laid off), 11 (seasonal work),
# 7 = retired == 9

#Exploramos las variables.

data_2019 %>%
  select(q1503_work_now, q1504_reason) %>%
  summarise_all(funs(sum(is.na(.)))) #Existen valores perdidos (347 en work-now y 1387 en reason)

data_2019 %>% 
  select(q1503_work_now) %>%
  freq_table(q1503_work_now) #1 = yes; 2 = no; NAs = -93

data_2019 %>% 
  select(q1504_reason) %>% #Sustituiremos los NA como -93
  freq_table(q1504_reason) 

#Creamos la variable

data_2019_test <-
  data_2019_test %>% 
  mutate(employment_st = case_when(
           q1503_work_now == 1 ~ 1, #have a job
           q1504_reason == 4 ~ 2, #studying
           q1504_reason == 1 | q1504_reason == 6 ~ 3, #care work (eliminamos la 13 para meterla en la siguiente - LA 13 es vacation/sick or maternity leave)
           q1504_reason == 13 | q1504_reason == 5 ~ 4, # on long term sick leave disability
           q1504_reason == 3 | q1504_reason == 7 | q1504_reason == 8 | q1504_reason == 11 | q1504_reason == 12 | q1504_reason == 87 ~ 5, #other reasons
           q1504_reason == 2 | q1504_reason == 10 |q1057 == 11 ~ 6, #unemployed or job-seeking
           q1504_reason == 9 ~ 7,
           q1504_reason == NA | q1503_work_now == NA ~ -93
         ), 
          employment_st = factor(x = employment_st,
                          levels= c("1", "2", "3", "4", "5", "6", "7", "-91", "-92", "-93"),
                          labels= c("Have a job (employed or self-employed)", 
                                    "In education",
                                    "Care work (familiy) / homeworker/ on parental leave",
                                    "On long-term sick leave/disability",
                                    "Unable to work due to reasons not mentioned elsewhere in this list", 
                                    "unemployed or job-seeking", 
                                    "retired",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
                                    )))


data_2019_test %>% 
  select(employment_st) %>%
  freq_table(employment_st) #Sigue el problema de los NAs.

#TODO. Resolver el problema de los NAs para cerrar esta variable.

```

## Profession (q1510_catoccu)
Esta variable igual también nos puede ayudar a hacer la variable HC worker. 

```{r}
#TODO: revisar variable dictionary
#Best description of current occupation(s)
# 1	undergoing education
# 2	education and research 
# 3	arts, entertainment, sports and media
# 4	healthcare
# 5	first responder (paramedic/firefighter/police)
# 6	military
# 7	civil services, politics
# 8	finance and economy
# 9	industry
# 10	sales and services (incl. restaurants and bars)
# 11	transport (goods and people)
# 12	installation, maintenance, cleaning, and repairs
# 13	currently not working
# 14	other (please specify)

#Nuestra variable:
# 1	Legislators -----> 7 (civil services, politics)
# 2	Professionals ----> 
# 3	Technicians
# 4	Clerks ------> 12 (installation, maintenance, cleaning and repairs)
# 5	Service workers 
# 6	Skilled agricultural workers 
# 7 Craft workers 
# 8	Plant operators 
# 9	Elementary occupations 
# 10	Armed forces -----> 6 (military)

#TODO: Establecer los paralelismos ocn las categorías existentes y las que nos solicitan, poner NA en el resto?
#TODO: Ninguna coincide con ninguna?! Qué hacer

#Exploramos la variable.
data_2019 %>% 
  select(q1510_catoccu) %>%
  freq_table(q1510_catoccu) #Hay 347 NAs.

#Creamos la variable
data_2019_test <-
  data_2019_test %>% 
  mutate(profession = case_when(
           
         ), 
          profession = factor(x = profession,
                          levels= c("1", "2", "3", "4", "5", "6", "7", "-91", "-92", "-93"),
                          labels= c("undergoing education", 
                                    "education and research",
                                    "arts, entertainment, sports and media",
                                    "healthcare",
                                    "first responder (paramedic/firefighter/police)", 
                                    "military", 
                                    "civil services, politics",
                                    "finance and economy",
                                    "sales and services (incl. restaurants and bars)",
                                    "transport (goods and people)",
                                    "installation, maintenance, cleaning, and repairs",
                                    "currently not working",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
                                    )))


data_2019_test %>% 
  select(pofession) %>%
  freq_table(profession) #Sigue el problema de los NAs.


```

## Contract (q1510b_contract_earner)
```{r}
#TODO: revisar variable dictionary
#Permanent/temporary contract
# 1	permanent
# 2	temporary
# 3	self-employed
# 4	other
# Missing values/categories:	
# -91	not assessed
# -92	refused to answer
# -93	missing (default)

#TODO: Establecer paralelismos entre ambas categorización y hacer los cambios necesarios.

#En Edad con Salud:
# 1	officer ----> 1 permanent
# 2	 indefinite period (not officer) ----> 3 self-employed
# 3	temporal or contract of works and services ---> 2 temporary
# 4	verbal or without contract ---> 4
# 888	DK --> -93
# 999	refused to answer ---> -92

#TODO: Esclarecer categorización.

#Exploramos la variable

data_2019 %>% 
  select(q1510b_contract_earner) %>%
  freq_table(q1510b_contract_earner) #Hay NAs que codificar a -93

# Creamos la nueva variable.
#Creamos la variable
data_2019_test <-
  data_2019_test %>% 
  mutate(contract = case_when(
           
         ), 
          contract = factor(x = contract,
                          levels= c("1", "2", "3", "4", "-91", "-92", "-93"),
                          labels= c("permanent",
                                    "temporary",
                                    "self-employed",
                                    "other",
                                    "not assessed",
                                    "refused to answer",
                                    "missing (default)"
 )))



```


## Employment type (q1510e_workday)
```{r}
#TODO: Ver variable dictionary. 
# 1 - Full time
# 2 - Part time
# 3 - No paid work
# 4 - Other
# -91 not assessed
# -92 refused to answer
# -93 missing (default)

#Nuestra variable: 
# 
# 1	 Part time (morning and afternoon) ---> 2
# 2	 Continuous morning working day ---> 1
# 3	 Continuous afternoon working day ----> 1
# 4	Continuous night working day ----> 1
# 5	 Reduced work day ---> 4
# 6	Shift work / irregular or variable work --> 2
# 7	 Other type  ---> 4
# 888	DK ---> -92 
#TODO: Comprobar si se han incluido en todas las olas; modificarlo si es necesario. 


data_2019 %>% 
  select(q1510e_workday) %>%
  freq_table(q1510e_workday)
```

## Resilience scale (BRS)
### Ola 1
```{r}
# Tenemos resilience_scale y los ítems individuales: q7537, q7538, q7539, q7540, q7541, q7542
# TODO: Añadir una fila por cada ítem individual. 


```

### Ola 2
```{r}
# Tenemos resilience_scale y los ítems individuales: SM26_1, SM26_2, SM26_3, SM26_4, SM26_5, SM26_6
# TODO: Añadir una fila por cada ítem individual. 
# TODO duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato long)

```


## Social support
### Ola 1
```{r}
# Tenemos social_support y los ítems individuales: 
# TODO: Añadir una fila por cada ítem individual. 


```

### Ola 2
```{r}
# Tenemos social_support y los ítems individuales: 
# TODO: Añadir una fila por cada ítem individual. 
# TODO duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato long)
# TODO: encontrar los ítems individuales

```
## c.o. residence

```{r}
#TODO: To be created (comment from Elvira: this variable should be created)
#TODO: Ver qué variables pueden formar esta variable.
#TODO: variable dictionary:
# "residence" is a new variable and replaces the formerly included variable "c.o. residence". Note variables NUTS-1 to NUTS-3 (s. variable dictionaries 20 to 22) are  "20_geographics NUTS-1", "21_geographics NUTS-2", and "22_geographics areno NUTS-3" are discarded.
#Find NUTS territorial unit codes at: https://drzmainz.sharepoint.com/:x:/s/obiba-wp2/Ecl70YGS_79HmKhWAGd3QzsBz9BGEIHRfuIOeSgpqRaYGw?e=4rfPmo
#Me da error: internal users only
#Comentario de Elvira: All participants live din Spain. We could create this variable. 

```

## Stressor (life events)
```{r}
#Tenemos la escala completa: lte. Los ítems individuales: q4659_ill q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police q4670_stolen

#TODO: Crear nuevas filas por cada ítem.
```

