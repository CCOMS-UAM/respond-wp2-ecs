---
title: "Preparating variable_list.xlsx with Edad con Salud data"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), '%d de %B de %Y')`"
institute: CCOMS, Universidad Autónoma de Madrid
output: 
  html_notebook:
  toc: yes
  toc_float: yes
  keep_md: yes
editor_options: 
  chunk_output_type: console
---

```{r library}
#library calls 
#puede ser interesante revisar packup package (esto se recomienda que esté arriba)
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
```

```{r read-data}
#Aquí se leen todos los archivos de datos
#¿Cómo se puede utilizar una ruta relativa para OneDrive sin querer trabajar luego en esa carpeta?
#Una opción es establecer UAM como wd al principio y luego cambiarlo, esto es un poco confuso¿?
data_2019 <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Ola_3/Cohorte_2019/rawdata_c2019w1.dta")

data_COVID <- read_dta("~/../UAM/Marta Miret Garcia - Bases de datos maestras Edad con Salud/Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")

#El formato importado desde .dta a R es un formato doble: la clase y la etiqueta (el label). Las labels son parte de los metadatos que tienen los datos (vectores y columnas de un dataframe). Esto dificulta un poco las cosas. Los value labels no suponen una implicación sobre la consideración categórica o continua (no se utilizan para el análisis de datos). Por eso, antes de hacer un análisis de datos es necesario convertir los vectores con value labels en factores o en vectores clásicos numéricos/carácteres. 

#Esto se puede hacer de dos maneras: o ya desde el principio se conviert en factores o en vectores numéricos o carácter con unlabelled(), to_factor() o unclass(), o cuando ya se ha hecho la limpieza de los datos y se quiere mantener esa info para la exportación. 

```

A la espera de nuevos correos, vamos a ir haciendo los preparativos para organizar el dataset de Edad con Salud para RESPOND.

# El archivo variable_list.xlsx

Este archivo reúne **todas las variables** que tiene cada estudio. Es necesario comprobar que todos los outcomes están incluidos (ver los archivos [mental health outcomes](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7BA66AD0BE-D072-4CB3-8072-F4FF5C92BF9D%7D&file=mental_health_measures_hs.xlsx&action=default&mobileredirect=true) y [predictores](https://drzmainz.sharepoint.com/:x:/r/sites/obiba-wp2/_layouts/15/Doc.aspx?sourcedoc=%7B37F195E1-399B-48CE-9E11-5B2B8B83B210%7D&file=predictor_candidates_by_study_hs.xlsx&action=default&mobileredirect=true) para comprobar que está todo lo que tiene que estar). 

# Cambios a realizar

## Create HC Worker from baseline wave using q1510_occ (wave 1)
```{r}
glimpse(data_2019$q1510_occ)

data_2019 %>%
  select(q1510_occ) %>%
  distinct()

#Existen 1824 valores únicos para esta variable y se hace necesario filtrarla para ver los que sean "health care workers" (1 = Sí, 0 = No)

#TODO: Explorar otras variables/ítems del cuestionario que permitan extraer la ocupación (e.g., códigos ISCO). Contamos principalmente con dos variables que registran la ocupación: q1510_occ (abierta) y q1510cat, que utiliza la estructura de la CIUO-08 (códigos ISCO, de la OIT). A nosotros nos interesa la categorización:

# GRUPO 2 "PROFESIONALES CIENTÍFICOS E INTELECTUALES" > PROFESIONALES DE LA SALUD
#*Aunque incluso con esto no sabemos si son health care workers (e.g., administrativos?).


#TODO: Revisar la pregunta ISCO que tiene categorizado esto (para no tener que analizar todo el contenido)
glimpse(data_2019$q1510_catoccu)

data_2019 %>%
  select(q1510_catoccu) %>%
  distinct()

freq_table(data_2019, q1510_catoccu)

#Vemos cómo sólo contiene la categorización de los 10 grupos principales, no de los subgrupos. 

#Conclusión: Lo descartamos porque no hay una variable que diferencie a los profesionales de la salud. Se tiene que trabajar con la variable q1510.

#TODO: Hay alguna manera de automatizar esto?
# Probamos con las expresiones regulares. RegExplain es un addin de R para manipular las expresiones regulares. Vemos que algunos de las opciones de texto que nos interesan son:

#SADSERVICIO ATENCION DOMICILIARIA enfermera mÃ©dica cardiÃ³loga medico traumatologo auxiliar enfermera auxiliar de enfermeria MÃ©dico homeÃ³pata

#Sin embargo, sólo se han mostrado las 100 primeras únicas. Necesitamos las 1824:

data_2019$q1510_occ %>% 
  str_extract_all("enf", simplify = T) #Esto no ha funcionado.


#La idea es crear una nueva variable de manera que el patrón detectado suponga un 1, y el resto un 0. 

data_2019_test <- data_2019 %>%
                    mutate( # 1 = mental health worker; 0 = non mental health worker
                      occ_mhw = if_else(str_detect(q1510_occ, "enf"), 1,
                                        if_else(str_detect(q1510_occ, "med"), 1,
                                                if_else(str_detect(q1510_occ, "traum"), 1, 
                                                        if_else(str_detect(q1510_occ, "aux"), 1,
                                                                ifelse(str_detect(q1510_occ, "SADSERVICIO"), 1, 0)))))
                    )
glimpse(data_2019_test$occ_mhw)  #Funciona

#TODO: Ver cómo conseguir una lista de todos los patrones que nos interesan. 

```

##Income quartiles (hhquintile) - wave 1
```{r}
# TODO: Buscar ítems relacionados con los ingresos.

#Las preguntas relacionadas con los ingresos son escasas (¿?): q1519 pregunta por la situación financiera en la infancia;las preguntas q0410g, i, j, k, l, n también hablan de ello:
# g: Ingresos personales brutos de todos los miembros de su familia durante los últimos 12 meses 
# i: ingresos brutos de su hogar durante los últimos 12 meses procedentes de la pensión de jubilación
# j: de programas de ayudas oficiales (paro, hijos dependientes, viudedad, orfandad, asistencia general),
# k: de fuentes privadas (pensiones, inversiones, alimenticias o de mantenimiento). 

#Subset de las variables de interés:
data_2019 %>%
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 

#Ver cuántos valores únicos hay por cada variable
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),names_to = "income", values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)



#Exploración gráfica de las variables

g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4) #Tiene que haber otra manera, pero bueno

#TODO: preguntar a Dani cómo gestionar esta variable porque se encuentra en rangos (es una variable categórica con 34 niveles a los que pertenece un rango distinto)

#Dani me pasa el archivo Edad_con_Salud_Data.R. La idea que tengo es la de recodificar estas cuatro variables por la mediana del rango establecido en la codificación, ya que las preguntas q0410 establecen rangos de respuesta. Esta manera de proceder la extraigo de su script de R. 

#El formato de stata es doble: por un lado el valor numérico y por otro la etiqueta. Como del script de Dani ya tenemos los valores numéricos, lo que hacemos es transformarlas a variables numéricas:


data_2019_test <- data_2019
data_2019_test$q0410g_total <- as.numeric(data_2019_test$q0410g_total)
data_2019_test$q0410i_ss <- as.numeric(data_2019_test$q0410i_ss)
data_2019_test$q0410j_government <- as.numeric(data_2019_test$q0410j_government)
data_2019_test$q0410k_other <- as.numeric(data_2019_test$q0410k_other) #Tiene que haber una manera más tidy de hacer esto


str(data_2019_test$q0410g_total)

#También lo podemos recodificar a factor

data_2019_test$q0410g_total <- as.factor(data_2019_test$q0410g_total)
data_2019_test$q0410i_ss <- as.factor(data_2019_test$q0410i_ss)
data_2019_test$q0410j_government <- as.factor(data_2019_test$q0410j_government)
data_2019_test$q0410k_other <- as.factor(data_2019_test$q0410k_other) #Tiene que haber otra forma más tidy de hacer esto


data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = -92,
                                          "888" = -93,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )


#TODO: Ver por qué no se recodifica bien

#TODO: Qué hacer con los valores perdidos? -92 y -93
#DONE: Ver las variable_list (refused vs no-disponible)




#TODO: Una suma de todas esas variables para encontrar los ingresos totales y luego hacer los quintiles?
#Tenemos las variables en factor:

str(data_2019_test$q0410g_total_r)

#Hay que convertirlas a numeric para poder hacer la suma

data_2019_test <- 
  data_2019_test %>% 
    mutate(q0410g_total_r = as.numeric(q0410g_total_r),
           q0410i_ss_r = as.numeric(q0410i_ss_r),
           q0410j_government_r = as.numeric(q0410j_government_r),
           q0410k_other_r = as.numeric(q0410k_other_r))

data_2019_test <- data_2019_test %>%
  filter(!q0410g_total_r == -92, !q0410g_total_r == -93, 
         !q0410i_ss_r == -92, !q0410i_ss_r == -93,
         !q0410j_government_r == -92, !q0410j_government_r == -93,
         !q0410k_other_r == -92, !q0410k_other_r == -93) %>%
  mutate(hh_income_r = q0410g_total_r + q0410i_ss_r + q0410j_government_r + q0410k_other_r)

glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r)

#TODO: Calculamos los cuantiles con quantile(x)
quintiles <- quantile(data_2019_test$hh_income_r) #Los quintiles son 4, 6, 22, 33, 106 (esto está mal)
quintiles <- unname(quintiles)

quintiles[1]
#Recodificamos en quintiles

data_2019_test <- data_2019_test %>% 
  mutate(hhquintile = if_else(hh_income_r <= quintiles[1], 1,
                             if_else(hh_income_r > quintiles[1] & hh_income_r <= quintiles[2], 2,
                                     if_else(hh_income_r > quintiles[2] & hh_income_r <= quintiles[3], 3,
                                             if_else(hh_income_r > quintiles[3] & hh_income_r <= quintiles[4], 4,
                                                    if_else(hh_income_r > quintiles[4] & hh_income_r <= quintiles[5], 5,
                                                            if_else(hh_income_r == -92, -92,
                                                                    if_else(hh_income_r == -93, -93, 0))))))))

glimpse(data_2019_test$inc_quint)

#TODO: Falta por corregir la recodificación en variables factor (por qué no salen con la etiqueta asignada y queda la anterior). Falta por corregir el tema de los valores perdidos en la suma (quizás proponer después una regla que sea que los múltiplos de -92 o -93 se vuelvan a codificar por este número)

```
## Stressor (life events)
```{r}
# Los ítems son: lte / q4659_ill q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police q4670_stolen
#TODO: lte es una variable que ya existe. Queda añadir una columna por cada ítem por separado.
#TODO: ver las variable dictionaries por si habría que añadir algo
#TODO: No hay variable dictionaries. Preguntar en la drop-in session (17/10/2022)
```



## Living alone (q0401_hh_total) - wave 1
#. ¿Cuál es el número total de personas que viven habitualmente en este hogar?
It has to be categorised as 1 = alone; 2 = not alone.
En la actualidad es una variable que va del 1 al 10 
```{r}
data_2019 %>%
  select(q0401_hh_total) %>%
  freq_table(q0401_hh_total)

data_2019_test <- data_2019_test %>% 
  mutate(living_alone = if_else(q0401_hh_total == 1, 1, 2)) %>% 
    glimpse(living_alone) #Por qué esto no funciona?


data_2019_test$living_alone

#TODO: Preparada.
#TODO: Añadir labels
```

##Household size (q0401_hh_total)
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta
#Las categorías son:
##1: one person
##2: two persons
##3: three or four persons
##4: five or more persons
##5: live in an institution
##-91: not assessed
##-92: refused to answer
##-93: missing (default)

#El problema es que el ítem q0401_hh_total sólo contempla el número de personas (1-10 hasta 10 personas), no si viven en una institución o no. Eso lo hace el ítem q0400a

data_2019_test$q1007
```


## Children household (q0407_age_01-q0407_age_08/q0407_age_10)
Es necesario combinar todas estas variables en una sola.
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta

#TODO: crear una nueva variable que combine todos los ítems en uno solo. 

data_2019 %>%
  select(q0407_age_01, q0407_age_08, q0407_age_10) %>%
  freq_table(q0407_age_10)

```

## Gender (q1009_sex)
```{r}
#TODO: revisar las variable dictionaries para ver qué es lo que ocurre con esta
data_2019 %>%
  select(q1009_sex) %>%
  freq_table(q1009_sex)


```
## Age q1010_birth_date &/OR q1011_age
```{r}
#TODO: esperar respuesta de Dani (Elvira quería comentar con él alguna cosa y la cuestión del EPQR-A)
```



##Relationship status (q1012_mar_stat)
```{r}
data_2019 %>%
  select(q1012_mar_stat) %>%
  freq_table(q1012_mar_stat)

#TODO: ver las variable dictionaries
```

## Education (q1016_highest)
```{r}
data_2019 %>% 
  select(q1016_highest) %>%
  freq_table(q1016_highest)

#TODO: ver las variable dictionaries
```

## Migration (q1018_country)
```{r}
data_2019 %>% 
  select(q1018_country) %>%
  freq_table(q1018_country)

#TODO: ver las variable dictionaries
```

## Children (q1056/q1058)
```{r}
data_2019 %>% 
  select(q1056) %>%
  freq_table(q1056)

data_2019 %>% 
  select(q1058) %>%
  freq_table(q1058)

#TODO: ver las variable dictionaries
```
## N.o. children (q1057/q1059)
```{r}
data_2019 %>% 
  select(q1057) %>%
  freq_table(q1057)

data_2019 %>% 
  select(q1059) %>%
  freq_table(q1059)

#TODO: ver las variable dictionaries
```

## Employment status
Hay que crear esta variable a partir de los items `q1503_work_now` y `q1504_reason`.
```{r}
#TODO: crear la variable. Ver variable dictionaries.
```

## Profession (q1510_catoccu)
Esta variable igual también nos puede ayudar a hacer la variable HC worker. 
```{r}
data_2019 %>% 
  select(q1510_catoccu) %>%
  freq_table(q1510_catoccu)

#TODO: revisar variable dictionary
```

## Contract (q1510b_contract_earner)
```{r}
data_2019 %>% 
  select(q1510b_contract_earner) %>%
  freq_table(q1510b_contract_earner)

#TODO: revisar variable dictionary
```


## Employment type (q1510e_workday)
```{r}
#TODO: Comprobar si se han incluido en todas las olas; modificarlo si es necesario. 
#TODO: Ver variable dictionary. 

data_2019 %>% 
  select(q1510e_workday) %>%
  freq_table(q1510e_workday)
```

## Resilience scale (BRS)
### Ola 1
```{r}
# Tenemos resilience_scale y los ítems individuales: q7537, q7538, q7539, q7540, q7541, q7542
# TODO: Añadir una fila por cada ítem individual. 


```

### Ola 2
```{r}
# Tenemos resilience_scale y los ítems individuales: SM26_1, SM26_2, SM26_3, SM26_4, SM26_5, SM26_6
# TODO: Añadir una fila por cada ítem individual. 
# TODO duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato long)

```


## Social support
### Ola 1
```{r}
# Tenemos social_support y los ítems individuales: 
# TODO: Añadir una fila por cada ítem individual. 


```

### Ola 2
```{r}
# Tenemos social_support y los ítems individuales: 
# TODO: Añadir una fila por cada ítem individual. 
# TODO duda: ¿hay que cambiar el nombre de los items en la BBDD final? (formato long)
# TODO: encontrar los ítems individuales

```
## c.o. residence

```{r}
#TODO: To be created (comment from Elvira: this variable should be created)
#TODO: Ver qué variables pueden formar esta variable.
```

## Stressor (life events)
```{r}
#Tenemos la escala completa: lte. Los ítems individuales: q4659_ill q4660_illrelative q4661_died q4662_diedrelative q4663_separation q4664_brokeoff q4665_problem q4666_unemployed q4667_sacked q4668_financial q4669_police q4670_stolen

#TODO: Crear nuevas filas por cada ítem.
```

