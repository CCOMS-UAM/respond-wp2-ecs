---
title: "Edad con Salud WP2 dataset harmonization process"
author: "Cristina Rodríguez-Prada"
date: "`r format(lubridate::today(), 'First created on 30 Sept. 2022. Updated on %d de %B de %Y')`"
output:
  html_notebook: 
  toc: yes
  toc_float: yes
institute: CCOMS, Universidad Autónoma de Madrid
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 80
---
## Required libraries

```{r library}
library(tidyverse)
library(haven)
library(freqtables)
#install.packages("freqtables")
library(ecs.data)
library(labelled)
#install.packages("labelled")
library(stringr)
library(gridExtra)
#install.packages("gridExtra")
library(lubridate)
library(naniar)
library(stringi)
library(readstata13)
library(readxl)
library(ecs.data)
```

```{r constants}

MISSING_DESIGN <- -991
REFUSED_ANSWER <- -992 
NON_RESPONSE <- -993

BASELINE_FILEPATH <- file.path(read_ecs_folder("DB"),
                               "Ola_3/Cohorte_2019/rawdata_c2019w1.dta")
COVID_FILEPATH <- file.path(read_ecs_folder("DB"), 
                        "Subestudio_COVID/Edad_con_salud_Fichero_Completo.dta")
```


```{r}
data_2019 <- read_dta(BASELINE_FILEPATH, encoding = "UTF-8")
data_COVID <- read_dta(COVID_FILEPATH)
```

# Dataset inspection

## Remove and rename variables

We want to check that the column names are adequate. 
```{r}
raw_2019_colnames <- colnames(data_2019)
raw_COVID_colnames <- colnames(data_COVID)
```

How many columns are duplicated?
```{r}
intersect(raw_2019_colnames, raw_COVID_colnames)
```
Are in each dataset unique values for columns? Yes.
```{r}
print(raw_2019_colnames[duplicated(raw_2019_colnames)])
print(raw_COVID_colnames[duplicated(raw_COVID_colnames)])
```

```{r}
raw_2019_colnames
```

```{r}
raw_COVID_colnames
```

On COVID Substudy there's one case that is not on baseline wave. We have to
remove it. Firstly, we detect it using anti_join():

```{r}
ID_ECS_subs <- data_COVID %>%
                anti_join(data_2019, by = "ID_ECS") %>% 
                select(ID_ECS) %>% pull()

```

And then we remove it (is ID_ECS == 6900702)
```{r}
data_COVID <- data_COVID %>% 
  filter(ID_ECS != ID_ECS_subs)
```

Then, we create a test-dataframe for both waves to try different strategies to
armonize the variables involved.

```{r}
data_2019_test <- data_2019
data_COVID_test <- data_COVID
```

## Waves identification
```{r}
data_2019_test <- data_2019 %>%
              add_column(wave = 1, .before = "ID_ECS")
  
```

```{r}
data_COVID_test <- data_COVID %>%
              add_column(wave = 2, .before = "ID_ECS")
  
```

## Follow-up cases
COVID substudy is a follow-up study from baseline. We have to know what cases
are in both waves:
```{r}
ID_ECS_both <- data_COVID_test %>%
               semi_join(data_2019_test, by = "ID_ECS") %>% 
               select(ID_ECS) %>% 
               pull()
  
```

This generates a vector that contains 1853 values: the cases that are in both
waves of the study.

```{r}
# ID_ECS_w1w2 <- integer(3002)
# ID_ECS_w1w2 <- ifelse(data_2019_test$ID_ECS == ID_ECS_both, 1, 0)

combi <- match(data_COVID_test$ID_ECS, data_2019_test$ID_ECS) #positions of the
#cases that are in both waves
fill0 <- rep(0, 3002 - length(ID_ECS_both))

ID_ECS_w1w2 <- ifelse(combi, ID_ECS_both, fill0)
length(ID_ECS_w1w2)
length(fill0)
```

```{r}
ids_2019 <- data_2019_test %>% select(ID_ECS, wave)
ids_covid <- data_COVID_test %>% select(ID_ECS, wave)

ids <- full_join(ids_2019, ids_covid); ids
```


```{r}
prueba <- left_join(data_2019_test, data_COVID_test, by = "ID_ECS")

birthday_COVID <- prueba %>% 
                  group_by(ID_ECS) %>% 
                  mutate(
                    birthday_COVID = case_when(
                      wave.x == 1 & wave.y == 2 ~ q1010_birth_date.x,
                      wave.x == 1 | wave.y == 2 ~ 0
                    )
                  )
```


We have to harmonize the format of dates:
Firstly, we create separate vectors with the dates:
```{r dates format}
fecha2019 <- lubridate::ymd(data_2019$q0006_date) #date of interview wave 1
fechaCOVID <- lubridate::dmy(data_COVID_test$FECHAFIN)
birthday <- lubridate::ymd(data_2019$q1010_birth_date)
birthday_COVID <- data_2019_test %>% 
                  filter(ID_ECS_both %in% ID_ECS) %>%
                  select(q1010_birth_date) %>% 
                  lubridate::ymd()
                  

```
## 18. INCOME QUARTILES

Las variables relacionadas con los ingresos que se manejan en esta BBDD son:

-   `q0410g_total`: ingresos personales brutos de todos los miembros de su
    familia durante los últimos 12M.
-   `q0410i_ss`: ingresos brutos de su hogar durante los últimos 12M procedentes
    de la pensión de jubilación.
-   `q0410j_government`: ingresos brutos de su hogar (...) procedentes de progra
    mas oficiales (paro, hijos dependientes, viudedad, orfan- dad, asistencia
    general)
-   `q0410k_other`: de fuentes privadas (pensiones, inversiones, alimenticias o
    de mantenimiento).

Se descarta `q1519` para este fin porque pregunta por la situación financiera en
la infancia.

### Exploración de variables

Vemos cuántos valores únicos hay por cada variable y las representamos gráfica-
mente. Se trata de una variable categórica que representa rangos. Se encuentran
34 valores distintos dentro de esta variable.

```{r}
data_2019 %>%
  group_by(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  pivot_longer(c(q0410g_total, q0410i_ss, q0410j_government, q0410k_other),
               names_to = "income", 
               values_to = "value") %>% 
  select(income, value) %>% 
  distinct() %>% 
  arrange(income, value) %>% 
  print(n = 150)
```

```{r}
data_2019 %>%
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>%
  summarise_all(funs(sum(is.na(.))))
```

```{r}
data_2019 %>% filter(q0410g_total == 1 | q0410i_ss == 1 |
                       q0410j_government == 1 |
                       q0410k_other == 1) %>%
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>%
  summarise(
    n())
```


```{r}
data_2019 %>% 
  freq_table(q0410g_total) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410i_ss) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410j_government) %>% 
  print(n = 50)
```

```{r}
data_2019 %>% 
  freq_table(q0410k_other) %>% 
  print(n = 50)
```

```{r}
g1 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410g_total)) +
  xlim(0, 40)

g2 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410i_ss)) +
  xlim(0, 40)

g3 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410j_government)) +
  xlim(0, 40)

g4 <- ggplot(data_2019) +
  geom_bar(mapping = aes(x = q0410k_other)) +
  xlim(0, 40)

grid.arrange(g1, g2, g3, g4)
```


#### Recodificación de la variable

Para proceder con el tratamiento de esta variable, Dani me envía su script
`Edad_con_Salud_Data.R`. La idea que se extrae de ese script es recodificar
estas cuatro variables por la mediana del rango establecido para poder sumarlas
y crear los quintiles en base a esto.

Debido al doble formato de Stata, primero convertimos las variables a numéricas
y luego a factores.

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410i_ss, q0410j_government, q0410k_other) %>% 
  View()
```


```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
    q0410g_total = as.numeric(q0410g_total),
    q0410i_ss = as.numeric(q0410i_ss),
    q0410j_government = as.numeric(q0410j_government),
    q0410k_other = as.numeric(q0410k_other),
    
    q0410g_total = as.factor(q0410g_total),
    q0410i_ss = as.factor(q0410i_ss),
    q0410j_government = as.factor(q0410j_government),
    q0410k_other = as.factor(q0410k_other)
  )
```

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(q0410g_total_r = recode_factor(q0410g_total,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
         
         q0410i_ss_r = recode_factor(q0410i_ss,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410j_government_r = recode_factor(q0410j_government,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE,
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000),
        q0410k_other_r = recode_factor(q0410k_other,
                                          "999" = REFUSED_ANSWER,
                                          "888" = NON_RESPONSE, 
                                          "1"  =           0, "2"  =      0, "3"  =    500, "4"  =    1500,
                                          "5"  =        2500, "6"  =   3500, "7"  =   4500, "8"  =    5500,
                                          "9"  =        6500, "10" =   7500, "11" =   8500, "12" =    9500,
                                          "13" =       10500, "14" =  11500, "15" =  12500, "16" =   13500,
                                          "17" =       14500, "18" =  15500, "19" =  16500, "20" =   17500,
                                          "21" =       18500, "22" =  19500, "23" =  22500, "24" =   27500,
                                          "25" =       32500, "26" =  37500, "27" =  42500, "28" =   47500,
                                          "29" =       62500, "30" =  87500, "31" = 125000, "32" =  175500,
                                          "33" =      250000, "34" = 400000, "35" = 750000, "36" = 1000000)
         )
```

```{r}
data_2019_test %>% 
  select(q0410g_total,  
         q0410g_total_r, 
         q0410i_ss, 
         q0410i_ss_r, 
         q0410j_government, 
         q0410j_government_r, 
         q0410k_other,
         q0410k_other_r) %>% 
  str()
```

Encontramos que la recodificación que se ha hecho no es la que buscábamos,
aunque si seleccionamos dos variables (original y recodificada) vemos que
podemos hacer otras cosas para seguir operando:

```{r}
data_2019_test %>% 
  select(q0410g_total, q0410g_total_r) %>% 
  View()
```

Se han modificado los levels, pero no las labels. En cualquier caso, para seguir
avanzando, tenemos que convertirlo a carácter y luego a integer:

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_total_r = as.character(q0410g_total_r),
        q0410i_ss_r = as.character(q0410i_ss_r),
        q0410j_government_r = as.character(q0410j_government_r),
        q0410k_other_r = as.character(q0410k_other_r),
        
        q0410g_total_r = as.integer(q0410g_total_r),
        q0410i_ss_r = as.integer(q0410i_ss_r),
        q0410j_government_r = as.integer(q0410j_government_r),
        q0410k_other_r = as.integer(q0410k_other_r)
  )
```

Comprobamos que están los NAs bien codificados (-993 y NA)
```{r}
data_2019_test %>%
  select(q0410g_total_r, q0410i_ss_r, q0410j_government_r, q0410k_other_r) %>%
  summarise_all(funs(sum(is.na(.)))) #Están bien los NAs, 91 de proxy
```

```{r}
data_2019_test %>% 
  freq_table(q0410g_total_r) %>%  # 371 + 819 = 1190 NON_RESPONSE
  print(n = 26)
```

```{r}
data_2019_test  %>% 
  freq_table(q0410i_ss_r) #267 + 824 = 1091 NON_RESPONSE
```

```{r}
data_2019_test  %>% 
  freq_table(q0410j_government_r) #230 + 766 = 966 NON_RESPONSE
```

```{r}
data_2019_test  %>% 
  freq_table(q0410k_other_r) #291 + 710 = 1001 NON_RESPONSE
```


Necesitamos crear otra variable a partir de esta teniendo en cuenta los -993 y
-93 con missing para que no se tengan en cuenta a la hora de calcular los
quintiles, utilizando na_if().

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
        q0410g_tot_NA = na_if(q0410g_total_r, NON_RESPONSE),
        q0410g_tot_NA = na_if(q0410g_tot_NA, REFUSED_ANSWER),
        q0410i_ss_NA = na_if(q0410i_ss_r, NON_RESPONSE),
        q0410i_ss_NA = na_if(q0410i_ss_NA, REFUSED_ANSWER),
        q0410j_gov_NA = na_if(q0410j_government_r, NON_RESPONSE),
        q0410j_gov_NA = na_if(q0410j_gov_NA, REFUSED_ANSWER),
        q0410k_other_NA = na_if(q0410k_other_r, NON_RESPONSE),
        q0410k_other_NA = na_if(q0410k_other_NA, REFUSED_ANSWER)
)
```

```{r}
data_2019_test  %>% 
 freq_table(q0410i_ss_NA)
```


```{r}
data_2019_test %>%
  select( q0410g_tot_NA, q0410i_ss_NA, q0410j_gov_NA, q0410k_other_NA) %>%
  summarise_all(funs(sum(is.na(.))))
```
Ahora mismo están como NAs los que son MISSING_DESIGN (proxy) y los NON_RESPONSE
Una vez que tenemos esto, ya podemos continuar operando.

```{r}
data_c2019w1 |> transmute(across(q0410g_total:q0410k_other, is.na)) |> distinct()
```


#### Creación de la variable

```{r}
data_2019_test <- 
  data_2019_test %>% 
  mutate(
    hh_income_r_NA = q0410g_tot_NA + q0410i_ss_NA + q0410j_gov_NA + q0410k_other_NA)
```

```{r}
data_2019_test %>% 
  freq_table(hh_income_r_NA)
```

Tenemos 1429 NAs, en los que se incluyen los MISSING_DESIGN y los NON_RESPONSE.

```{r}
glimpse(data_2019_test$q0410g_total)
glimpse(data_2019_test$hh_income_r_NA)
```


```{r}
quartiles19 <- c(9816, 15015, 22024) 
```

```{r}
data_2019_test <- data_2019_test %>% 
  mutate(
  hhquartile = case_when(
                          hh_income_r_NA <= quartiles19[1] ~ 1,
                          hh_income_r_NA > quartiles19[1] & hh_income_r_NA <= quartiles19[2] ~ 2,
                          hh_income_r_NA > quartiles19[2] & hh_income_r_NA <= quartiles19[3] ~ 3,
                          hh_income_r_NA > quartiles19[3] ~ 4,
                          is.na(hh_income_r_NA) & is.na(q0410g_total_r) & 
                                                  is.na(q0410i_ss_r) &
                                                  is.na(q0410j_government_r) &
                                                  is.na(q0410k_other_r)
                                                           ~ MISSING_DESIGN,
                          is.na(hh_income_r_NA) ~ NON_RESPONSE),                     

  hhquartile = factor(x = hhquartile,
                          levels = c("1", "2", "3", "4", MISSING_DESIGN, NON_RESPONSE),
                          labels = c("first quartile", 
                                    "second quartile", 
                                    "third quartile", 
                                    "fourth quartile", 
                                    "not assessed", 
                                    "missing (default)")))
                          
```

#### Checking new variable

```{r}
data_2019_test %>% 
  freq_table(hhquartile)
```